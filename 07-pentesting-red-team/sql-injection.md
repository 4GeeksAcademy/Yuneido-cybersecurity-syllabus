# SQL Injection

SQL injection is a type of injection attack in which an attacker inserts malicious code into a SQL query to execute unwanted commands in the database. Attackers can use command injection to execute arbitrary commands on the system, which could allow them to gain unauthorized access, modify or delete data, or even take full control of the system. Injections are often performed through input fields, such as web forms, URL parameters or HTTP headers.

The most useful WordPress plugins have some kind of interaction with the database. User input is often sent to the database, either because it needs to be stored in the database, needs to modify something in the database, or because it is used as part of a SELECT statement. If the user input is not properly validated and escaped, an attacker can replace that user input with commands that he can send directly to the database.

There are two types of SQL injection. A “classic” SQL injection vulnerability is one in which unfiltered user input allows an attacker to send commands to the database and the output is sent back to the attacker. A “blind” SQL injection vulnerability occurs when the attacker can send commands to the database but does not actually see the database output.

According to Wordfence analysis SQL injection vulnerabilities are the second most common vulnerability found in WordPress plugins.

![SQL 1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql1.png?raw=true)

[https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/](https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/)

How a classic SQL injection vulnerability works

To understand how a classic SQL injection vulnerability works, let's look at a WordPress example:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var(“select post_title from ‘ . $wpdb->posts . ’ where ID=” . $_GET['id']);
echo $title;
 |
| --- | --- |

The above code is an example of a SQL injection (SQLi) vulnerability. It is a SQLi vulnerability because the user input in $_GET['id'] is sent directly to the database without sanitization or escaping. This allows an attacker to send commands directly to the database.

Then, the database output is sent directly to the user's browser. Because the output is sent to the browser, this makes the vulnerability a classic SQLi vulnerability, as opposed to a blind SQL injection vulnerability, which is discussed below.

By using this vulnerability, an attacker can send commands directly to the database. These include SELECT commands to download your entire database, including the user's personally identifiable information (PII). In some cases, it also includes INSERT and UPDATE commands to create new user accounts or modify existing user accounts.

Fixing the above vulnerability is relatively easy. In WordPress you simply need to use the staging method which will automatically sanitize and escape any data you send to the database. The above code can be modified as follows to remove the SQLi vulnerability:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var($wpdb->prepare(“select post_title from ‘ . $wpdb->posts . ’ where ID=%d”, $_GET['id']));
echo $title;
 |
| --- | --- |

Note that we use the $wpdb->prepare() method to escape the data we are sending to the database. It has a similar syntax to the sprintf() function that allows you to use placeholders. %d is an integer, %f is a float (or decimal) and %s is a string (or text). If you use %s as a placeholder, you do not need to include quotes, as they are added automatically.

### How does a blind SQL injection work?

A blind SQL injection vulnerability looks like the following:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var(“select post_title from ‘ . $wpdb->posts . ’ where ID=” . $_GET['id']);
//Do something with title, but don't echo.
 |
| --- | --- |

In the above example, the raw, unsanitized user input is sent directly to the database by concatenating the $_GET['id'] variable directly to the SQL query. To fix this vulnerability, you would simply use the prepare() method as above to sanitize and escape any input from the database.

The difference here is that the result is never sent to the browser. A blind SQLi vulnerability is just as serious as a normal SQLi vulnerability because, in some cases, an attacker can easily insert or update data in your database. The difference is that it is more difficult to extract data from the database because the attacker cannot see the database result because it is not written to the web browser.

## Blind time-based SQL attacks

Generally, there are two ways an attacker extracts data from a database using a blind SQL injection attack. The first is to use a time-based attack. Suppose, using the SQLi vulnerability above, an attacker can send any command to the database, but they cannot see the result. They can only see the resulting web page.

An attacker could ask the database a query such as “Does the first letter of the first admin account start with ‘a’? If so, sleep for 5 seconds and if not, don't sleep at all. If the web page takes less than 5 seconds to generate and return to the web browser, they know that the administrator account does not begin with the letter 'a' and move on to the next letter, 'b', and ask. the same question.

With this technique, an attacker can launch a time-based attack on a website and determine the names of administrator accounts and can extract hashed user passwords.

The actual SQL sent to the database could look similar to the following:

| 1
2
3
4
5
6 | select post_title from wp_posts where ID=1
  union select IF(
    substring(wp_users.user_login,1,1)='a',
    BENCHMARK(5000000,ENCODE('blah','asdf')),
    null)
  from wp_users where ID=1
 |
| --- | --- |

What this SQL says is “select the title of the post where the post ID is 1, but combine in a query that will take a long time if we assume that the user account with ID 1 (which is usually an administrator account) has the letter ‘a’ as the first letter of the username”.

When this query is executed, if the page takes a long time to load, the attacker has correctly guessed the first letter of the administrator's username. They can then move on to letters two and three until they have their admin username. Once they have it, they can extract their admin hashed password, their admin email, any user email or any data they want, as long as they take enough time to execute the attack.

Remember, these attacks are automated and incorrect guesses take no time, so data can be extracted relatively quickly using this technique.

Content-based blind SQL injection attacks

A content-based blind SQL injection attack is another way for an attacker to extract data from a database when they cannot see the database output.

If the query that generates the content is as follows (remember, the result of the query is not sent to the user)

| 1 | select post_status from wp_posts where ID=1 |

Assume that the value '1' above is an unfiltered query parameter added to the database query as in our example above. Therefore, an attacker can control all the text after 'ID='.

An attacker can add the following to the query to verify that if they include a false condition, they will see unusual content generated:

| 1 | select post_status from wp_posts where ID=1 and 1=2 |

Obviously, 1 is not equal to 2, so in the above query the database will return an empty result set. The attacker will examine the resulting page and if it is a page with no content or an error message that says something like “no content”, he will know what the response of an empty query with a false condition looks like. Then, the attacker can include something like the following:

| 1
2
3 | select post_status from wp_posts where ID=1
  and (select ID from wp_users where
  user_login='admin' and ID=1)
 |
| --- | --- |

The above query will be empty if the database user with ID 1 does not have the username 'admin'. However, it will return a normal non-empty result to the browser if the user with ID 1 has the username 'admin'. With this technique, an attacker can extract data from a database by checking for empty and non-empty responses from the application.

Another example of a content-based blind SQL injection query is:

| 1
2
3 | select post_status from wp_posts where
  ID=1 and (select 1 from wp_users where
  substring(user_pass,1,1) = 'a' and ID=1) | |
| --- | --- |

The above query will check if the first letter of the hashed password for the user with ID 1 is an 'a'. With this technique, an attacker can check each character and extract the hashed password for administrator accounts.

## Consequences

> Consequences of SQL injection can include:

- **Data loss or alteration:** the attacker may delete, modify or extract information from the database.
- **System instability:** the malicious code can cause the database to stop functioning properly, which can result in downtime and loss of availability.
- **Difficulty in detecting and mitigating the attack:** due to the malicious code being inserted into a legitimate SQL query.
- **Possibility of attack propagation:** If the attacker has access to sensitive data, such as user passwords, he can use it to propagate the attack to other systems.
- **Unauthorized access:** An attacker could gain unauthorized access to the system or web application, allowing him to access sensitive information or perform malicious actions on the system.
- **Data modification:** An attacker could modify, delete or add data to the system, which could have serious consequences on the integrity and accuracy of the data.
- **Execution of malicious code:** an attacker could execute malicious code on the system, which could result in taking control of the system or stealing confidential information.
- **Denial of service:** an attacker could use command injection to overload the system and render it inoperable.
- **Failure to correct this flaw can cause unauthorized disclosure of your and your customers' information that could result in fraud, identity theft, and regulatory penalties.**

> To prevent command injection, it is important to validate and filter all user input in web applications, and avoid using shell commands in web applications. In addition, it is important to keep all applications and systems up to date and patched to prevent known vulnerabilities from being exploited.

## Solution

> To prevent and remediate advanced SQL injection, the following steps can be taken:

- **Validate and sanitize all data inputs**: Ensure that all data inputs, whether provided by users or other sources, are properly validated and sanitized before being used in an SQL query.
- **Use parameterized queries:** Instead of building an SQL query dynamically using text strings, use parameterized queries that allow parameters to be passed as separate arguments. This will reduce the possibility of SQL injection, since parameter values are treated as data, not as part of the SQL query.
- **Limit database permissions:** Ensure that database users have only the permissions necessary to perform their roles and no more. This will limit the scope of any possible attack.
- **Use security tools and penetration testing:** Perform regular security testing and penetration testing on the application to identify potential security vulnerabilities and bugs. You can also use third-party security tools to protect the application against SQL injection.
- Update and patch database software and use web application firewalls (WAF).

It is a difficult task to determine whether a user string is malicious or not. Therefore, the best way to do this is to “escape” the special characters in the user input. You can escape a string before constructing the query in PHP using the mysql_escape_string() function. Or in MySQL using the mysqli_real_escape_string() function.

While displaying the output as HTML, you will also need to convert the string to ensure that the special characters do not interfere with the HTML markup. You can convert special characters in PHP using the htmlspecialchars() function. Alternatively, you can use prepared statements to avoid SQL injections. A prepared statement is a template for an SQL query, where you specify parameters at a later stage to execute it. Here is an example of a prepared statement in PHP and MySQLi.

```bash
$query = $mysql_connection->prepare("select * from user_table where username = ? and password = ?");`

$query->execute(array($username, $password));
```

> 📖 In summary, to troubleshoot and prevent advanced SQL injection, it is necessary to validate and sanitize all data entries, use parameterized queries, limit database permissions, and use security tools and penetration testing.

REFERENCES

- [https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [https://owasp.org/Top10/A03_2021-Injection/](https://owasp.org/Top10/A03_2021-Injection/)
- [https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection](https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection)
- [https://kinsta.com/es/blog/inyeccion-sql/](https://kinsta.com/es/blog/inyeccion-sql/)
- [https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html)

# SQL injection testing: everything you need to know**.

To improve your web application pentester skills, it is important to learn how to detect SQL injection vulnerabilities. We will delve into the testing principles and methods that can uncover the details of this threat. We will explore manual testing techniques, such as analyzing URLs and forms, understanding user interaction and application processing.

In addition, we will provide real-world examples of SQL injection payloads that you can use in your own testing. To further enhance your skills, we'll cover automation with tools such as SQLmap and Burp Suite, which offer insights from industry experts on modern techniques. You'll also gain insight into interpreting complex error messages that are crucial to identifying and resolving problems. By mastering the basic and advanced techniques described in this article, you will be able to improve the security of your applications and contribute to a more secure digital environment.

## Understanding SQL Injections

SQL injections are a computer vulnerability that can affect web applications and databases that use the SQL language. These attacks exploit vulnerabilities in input forms and URLs within applications. They intentionally insert harmful SQL statements into server requests. The primary goal of a SQL injection attack is to control how the database operates. This allows unauthorized access to sensitive data by extracting, modifying or deleting it.

**SQL injection attacks can be divided into several categories. The most popular are:**

**Error-based injection:** This technique involves inserting malicious entries into a system's database to cause errors. These errors can potentially provide you with useful information.

![SQL 2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql2.png?raw=true)

**Union-based injection:** The UNION operator allows you to combine the results of a malicious query and a valid query. This allows them to access data from other tables without permission.

![SQL 3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql3.png?raw=true)

**Blind injection**: in this type of attack, the perpetrator does not receive a direct response from the server. Instead, they infer information about the behavior of the system to collect data.

![SQL 4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql4.png?raw=true)

**Time-based blind injection**: This technique involves intentionally adding delays to queries to verify the accuracy of specific conditions. By analyzing error messages, you can extract valuable information about the database, which aids further exploitation, such as discovering table names or system details, without generating alarms or suspicion.

## Manual SQL injection testing

Let's now delve into manual SQL injection testing techniques by closely examining the URL structure. By doing so, we can identify potential vulnerabilities and exploit them for security assessment purposes.

**Analyzing the structure of the URL** 

![SQL 5](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql5.png?raw=true)

During the manual SQL injection testing process, an in-depth analysis of the URL structure is essential to identify and assess vulnerabilities in web applications. This approach involves identifying weaknesses in the application by intentionally injecting malicious SQL code through parameters found within URLs.

To analyze the vulnerability of a website to SQL injection attacks, it is important to identify any user input that is transmitted through URL parameters. These parameters can potentially serve as entry points. Once these parameters are identified, testing their manipulability becomes crucial.

This involves inserting various test strings, special characters and escape sequences to determine if the application properly handles such inputs without generating errors.

![SQL 6](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql6.png?raw=true)

Another important step is to thoroughly examine the error messages produced by the application. These messages can inadvertently expose internal vulnerabilities in the system, potentially uncovering SQL injection weaknesses.

For example, in the image above, you can see an error generated by manipulating the **user** parameter in the URL, which helps us identify the **specific SQL query** that is causing the error. This could then be used to try to exploit the vulnerability that is causing the error or launch a denial of service (DoS) attack on the website by sending too many invalid SQL queries.

To further test for this type of URL, you can try to identify where the user input is inserted into the SQL query. It can be an input field, a variable in the URL, or any form of user input.

To get started, you can use a basic SQL payload like this:' OR '1'='1

Insert this payload into the suspect input and see if the SQL error message disappears. If the error message disappears or different behavior occurs, it could be a sign that the site is vulnerable to a SQL injection attack. If the basic payload does not produce significant results, you may want to experiment with more advanced SQL payloads, such as UNION-based or time-based blind SQL injection. For example, a UNION-based payload you might try is: ' UNION

```bash
SELECT null, username, password FROM users--
```

This type of payload attempts to extract information from the users table. However, be careful when using advanced payloads like this, as they can negatively affect the site you are testing, if not used correctly.

In summary, analyzing the URL structure in manual SQL injection testing can help identify potential vulnerabilities and assess an application's ability to handle malicious input, providing you with important data to continue your pentesting.

## Form fields and validation mechanisms

Form fields in a web application serve as an entry point for user input. You can exploit these fields through SQL injections, where you inject harmful SQL code. These form fields are commonly used to collect important user data such as names, email addresses, passwords and more.

Combining well-designed form fields with robust validation mechanisms can effectively mitigate the risk of SQL injections. For example, an email field should strictly accept only valid email addresses, avoiding the insertion of special characters that could manipulate SQL queries. This is not always the case and is subject to abuse.

Testing to see if the form accepts special characters or non-typical input may indicate the possibility of sending malicious commands or requests to the database.

![SQL 7](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql7.png?raw=true)

When manually testing for SQL injection vulnerabilities, existing security measures, such as validation of user input, can sometimes prevent the injection process. In such cases, it is worth exploring basic payloads, such as inserting **'OR 1=1--** into the input field; these types of payloads are called omission payloads because they use a condition that is always true to manipulate a vulnerable input and bypass authentication, access unauthorized data, or execute malicious commands.

![SQL 8](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql8.png?raw=true)

While input validation is an important safeguard, it is not always foolproof, so thorough and comprehensive testing is essential to identify potential vulnerabilities.

## Cookie values and HTTP headers

In manual SQL injection testing, you can manipulate requests by exploiting the values of cookies and HTTP headers in a web application. These elements are considered external inputs, so it is important that you perform proper testing with the right tools (such as Burp Suite).

Cookies, which contain information stored in a user's browser, can be vulnerable to tampering. A common method is to inject malicious SQL code by altering the data inside a cookie. If a cookie is used, for example, to store a user ID in an application, you can attempt to modify that ID within the cookie itself. This type of exploitation could result in unauthorized access to sensitive data or functions.

> 💡 For example, consider an application that uses a cookie to track the currently logged-in user. Now, suppose a hacker with malicious intent manages to alter this cookie by altering the user ID it contains.

If the application does not properly address this modification, it could unintentionally generate a malicious SQL query based on the manipulated ID. This could potentially grant unauthorized access to sensitive data.

In addition, when a browser sends a request to an application, it includes HTTP headers such as User-Agents. You (the attacker) can alter these headers by inserting harmful strings into the requests. For example, you could use the following payload:

```bash
UNION SELECT null, username, password FROM users--
```

This payload is designed to extract data from the “users” table of a database. Suppose you have an HTTP GET request that includes a “cat” parameter in which to place the payload. In the “HTTP Request” tab of Burp Suite, change the “cat” parameter to contain the payload, for example:

```bash
cat=' UNION SELECT null, username, password FROM users--
```

Start sending the request and observe the response. If the site is vulnerable to a UNION-based SQL injection, you will get a response that includes information from the “users” table.

![SQL 9](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql9.png?raw=true)

In both cases, it is essential to ensure that the application handles cookie values and HTTP headers securely. Manual testing involves analyzing the impact of such manipulations on the application's inputs and verifying its response to possible SQL injection attacks.

**User Controlled Input (UCI) processed by the application**.

When manually testing for SQL injection vulnerabilities, the concept of “User Controlled Input” or UCI refers to any input provided by the user and subsequently processed by the application. This can include data entered into form fields, cookie values, parameters in URLs or HTTP headers (which we saw earlier), you can take advantage of these opportunities to inject malicious SQL code and cause great damage.

In this approach, you intentionally manipulate the input provided to insert special characters or escape sequences (such as '' or =). These manipulations can alter the SQL queries generated by the application and exploit vulnerabilities in its input processing. The goal is to trick the application into executing unwanted SQL queries, resulting in unauthorized data extraction or system compromise.

### You must have a list of SQL injection payloads

Payloads are code snippets that are intentionally inserted into input fields of web applications. These snippets are intended to exploit vulnerabilities in database management systems. Security professionals and penetration testers often use these tools to assess the level of resistance an application has against potential attacks. The following is a list of the most common SQL injection payloads used by

SQL injection payloads used by **Pentesters** and **Bug Bounty Hunters** (in an ethical hacking context) to manually test forms for SQL injection vulnerabilities:

- Basic SQL injection payload: **' OR '1'='1** (used to bypass authentication by entering a condition that is always true).
- Retrieve information: **' UNION SELECT null,username,password FROM users--** (Used to extract sensitive data such as username and password from the database).
- Query manipulation: **'; DROP TABLE users; --** (Used to cause the “users” table to be deleted).
- Get table names: **' AND 1=0 UNION SELECT table_name, null FROM information_schema.tables--** (Used to extract table names in the database).
- Extract database name: **' AND 1=0 UNION SELECT null, database()--** (Used to extract the name of the current database).
- Use UNION to extract data: **' UNION SELECT username, password FROM users--** (Used to extract sensitive data using a UNION operation).
- Use of comments to omit: **admin' --** (Use a comment to skip the rest of the entry and log in as administrator).
- Use of time-based blind SQLi: **' OR IF(1=1, SLEEP(5), 0)--** (Delay server response to confirm SQL injection vulnerability).
- Use of error-based SQLi: **' AND 1=CONVERT(int, (SELECT @@version))--** (forces a SQL error to reveal database information).

All of these payloads can be used (and are the most effective) on vulnerable **login forms** , **URLs** (used as malicious queries) and **applications** (captured and modified by you with the correct payload).

### Automated SQL injection tests

When it comes to information security, tools such as SQLmap and Burp Suite are highly regarded in the field of SQL injection testing.

### Overview of the tools: SQLmap and Burp Suite

These tools are widely used by security professionals and provide effective automated solutions for detecting and exploiting SQL injection vulnerabilities in web applications. While SQLmap specializes in advanced testing and automation, Burp Suite offers a complete ecosystem for analyzing application security. It enables experts to identify, assess and address critical vulnerabilities, including those related to SQL injection attacks.

Now let's take a closer look at what these tools are for and what they are used for:

- **SQLmap**: is a valuable open source tool that automates SQL injection testing. It efficiently detects vulnerabilities, extracts data and compromises database systems using a variety of payloads and techniques. Penetration testers rely primarily on SQLmap to assess application security.

![SQL 10](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql10.png?raw=true)

- Burp Suite**: is a comprehensive set of tools designed for web application security. Among its features, the tool includes a Web Application Security (WAS) module, which helps security specialists identify and address vulnerabilities in websites. This module can detect common security threats including, as expected, SQL injection attacks.

![SQL 11](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql11.png?raw=true)

### Running SQLmap to find and exploit SQL injections

Now, let's use SQLmap to systematically discover SQL injection vulnerabilities in a deliberately vulnerable website. Our target will be VulnWeb (http://testphp.vulnweb.com), a website designed specifically for Cyber Security students to learn by attacking and exploiting vulnerabilities.

If you encounter a web URL such as, in this case, [http://testphp.vulnweb.com/listproducts.php](http://testphp.vulnweb.com/listproducts.php)? **cat=1** , where the 'GET' parameter is highlighted, it could indicate that the website is susceptible to SQL injection attacks. In such cases, you may be able to access sensitive database information. SQLmap is known to be the most effective in scenarios involving PHP-based websites.

![SQL 12](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql12.png?raw=true)

**Step 1: Evaluating the URL Parameter**

A simple way to determine if your website is vulnerable is to replace the value in the fetch request parameter with an ***** (asterisk).

![SQL 13](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql13.png?raw=true)

This type of error suggests that the web site is vulnerable to some type of SQL injection attack.

**Step 2: Check the URL with SQLmap**

We need to enter the desired web URL to be checked, using the -u parameter. Usually the main goal is to determine if it is possible to access a database, so we can use the --dbs option for this purpose. By using --dbs, we can get a list of all available databases.

The first command will be:

```bash
sqlmap -u [http://testphp.vulnweb.com/listproducts.php?cat=1](http://testphp.vulnweb.com/listproducts.php?cat=1) --dbs
```

![SQL 14](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql14.png?raw=true)

**Step 3: Understand the output**

In the above output, you can see in yellow the parts where SQLmap found SQL injection vulnerabilities and in orange the best payloads, suggested by SQLmap, to use that specific type of SQL injection (for example, the first vulnerability found is a boolean vulnerability). **Blind SQL injection** based and the suggested payload is: cat-1 AND 1050-1050). Take, for example, the last part of the result, highlighted in yellow, which says: The GET parameter **‘cat’** is ‘**Generic UNION query**’.

This part of the result tells us that the “cat” parameter of a GET request (which is the type of web request that, in this case, SQLmap is using to test the URL) within “[http://testphp.vulnweb.com](http://testphp.vulnweb.com/) /listproducts.php? **cat** =1” is vulnerable to a generic UNION query.

**But what is a Generic UNION query?**

It is an attack that typically involves manipulating the SQL query to combine the results of 2 or more database tables, allowing you to gain unauthorized access to sensitive data. In summary, this SQLmap result suggests that further testing is needed to confirm whether the **'cat'** parameter is indeed vulnerable to a SQL injection attack from “generic UNION query”. It is a signal to investigate and potentially exploit a vulnerability in the application input validation (which is the part of the web application that verifies and allows user input according to the query used).

And that's why we can see, in the last result highlighted in orange, that SQLmap suggests a specific payload, to manually test the vulnerable website for that type of SQL injection attack.

## Error message analysis

During the error analysis process in SQL injection testing, errors generated by an application can provide important information about the existence of vulnerabilities. For example, error messages containing sensitive information such as table names, blatant SQL syntax errors in application comments, and inconsistent responses such as missing or duplicate results can indicate possible query manipulation.

![SQL 15](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql15.png?raw=true)

These error messages can provide valuable information about the internal workings of the system. To trigger these messages, malicious data can be intentionally entered to cause queries to fail. In the image above, you can see a SQL syntax error (which we mentioned earlier) that appears after changing the value of the **cat parameter from “1**” to ***** (example of malicious input).

If you encounter SQL syntax errors, such as the commonly seen “You have an error in your SQL syntax” (which we can see in the image), it usually means that the input is included directly in queries without proper verification. These types of errors often indicate internal system behavior and help security experts identify potential weaknesses in applications.

## Frequently Asked Questions

- **Is it illegal to test for SQL injections?**

The legality of any Pentest depends solely on the local and federal laws of your country, so it is a good practice to be informed about them before performing any kind of active testing. However, there should be no problem as long as the activity is done responsibly and on platforms where you have obtained **written permission** from the owner.

- **What are SQL injection techniques?**

There are several techniques that can be used to manipulate queries, such as UNION attacks, time-based attacks and error-based attacks. These techniques involve the use of malicious data to exploit vulnerabilities.

- **What is the best SQL injection tool?**

For automation purposes, SQLmap is widely used, while Burp Suite offers a versatile solution for security analysis.

- **Do I need to learn SQL for SQL injections?**

Having some knowledge of SQL can be helpful, but there are also tools available that can simplify the process of identifying vulnerabilities.

## Blind SQL Injection

Blind SQL injection, a stealthy and cunning form of SQL injection attack, poses a unique challenge for security professionals due to its elusive nature and difficulty of detection and exploitation. In this comprehensive article, we will delve into the world of blind SQL injection and uncover the subtle nuances that distinguish it from other SQL injection attacks.

Throughout the article, we will discuss various tools and methods, focusing on Kali Linux as our platform of choice, although you can use the aforementioned tools on most operating systems. As we conclude, we will provide you with a set of proven best practices for defending your web applications against these elusive and potentially damaging attacks. By the end of this article, you will be well versed in how to understand, exploit and defend against blind SQL injection vulnerabilities.

Now, let's delve into this detailed guide and prepare yourself with the essential knowledge and techniques to effectively address the challenges posed by this type of vulnerability.

### What is blind SQL injection?

SQL injection is a common web application vulnerability that occurs when an attacker manages to execute unauthorized **SQL code** in a web application's database. Attackers do this by inserting malicious SQL statements into user input fields, such as search boxes or login forms. When successful, an attacker can obtain sensitive information from the database, modify or delete data, and even execute administrative commands.

Blind SQL injection, a more hidden variant, occurs when the attacker **cannot directly see the result** of their injected queries. In this case, they must infer the results indirectly using content-based or time-based techniques. This type of attack is used when the application does not visibly display the results of an injected SQL query, making it difficult for the attacker to confirm the success of his actions.

The benefit of using blind SQL injection over a standard SQL injection attack lies in its subtlety. Since the attacker does not directly see the result, it can be more difficult for security systems or administrators to detect the attack. The attacker often uses conditional responses (**boolean-based**) or application response time delays (**time-based**) to infer whether the injected SQL code has had the desired effect.

By slowly and methodically gathering information about database structure and content, an attacker can still exploit a blind SQL injection vulnerability to access sensitive data and manipulate the system without raising immediate suspicion.

## Disclaimer

We want to be absolutely clear about the importance of complying with applicable laws regarding the scanning and exploitation of web application vulnerabilities. Before performing any form of ethical hacking or penetration testing on a system, **be sure you have obtained explicit permission** from the system or network owner.

Unauthorized hacking or scanning may seem trivial, but it can carry serious legal consequences, including fines or imprisonment, depending on your jurisdiction. **Don't do it.** Some of the laws governing this activity include:

- The Computer Fraud and Abuse Act (United States).
- Sections 184, 342.1, 380 and 430 of the Criminal Code of Canada (Canada).
- Computer Misuse Act 1990 (England).
- Second. 202a and 202b of the German Criminal Code (Germany)
- Information Technology Act Sec. 43 and 66 (India)
- Law on Prohibition of Unauthorized Access to Computers (Japan)

 If you doubt whether you are acting clearly, check the agreement or scope of your authorized activities with a specific entity or review the code of conduct or disclosure guidelines with any of the bug bounty programs mentioned at the end of this article.

## Discovering and exploiting blind SQLi

Now that you have a solid understanding of blind SQL injection and how it differs from normal SQL injection, let's delve into the **process of discovering** and exploiting these vulnerabilities.  First, we'll walk you through setting up your lab environment, then we'll perform manual blind SQL injection testing, and finally, we'll use tools like SQLMap and Burp Suite to streamline the exploitation process.

### Configuring your lab

To begin, you will need to set up your lab to discover and exploit blind SQL injection vulnerabilities. There are **several tools you can use** and we will use the following tools and resources:

**Damn Vulnerable Web Application (DVWA):** DVWA is an intentionally vulnerable web application that provides a secure environment to practice various techniques. **It comes pre-installed in Kali Linux** or you can download it with sudo apt install dvwa. Once installed, set the difficulty level to “low” or “medium” and navigate to the “SQL Injection (blind)” challenge. We will use this to simulate a real-world scenario and demonstrate testing methods. To start the DVWA application:

1. Open the terminal and type the command: dvwa-start.
2. If you are not in the root account, you will be prompted to allow it.
3. The browser should automatically open in DVWA.
4. (Alternatively) If it does not open, go to the browser and enter: **[http://127.0.0.1:42001](http://127.0.0.1:42001/)** in the address bar.
5. To stop the DVWA server, go back to the terminal and type the command: dvwa-stop.

**SQLMap:** This powerful open source tool automates the detection and exploitation of SQL injection vulnerabilities. **It comes pre-installed on Kali Linux**, so if that is the operating system you are using, you don't need to download it separately. We will use SQLMap to automate the exploitation of the blind SQL injection vulnerability discovered in DVWA.

**Burp Suite:** Burp Suite is a widely used web application security testing toolkit. For this article, we will use the Community Edition, **which comes pre-installed on Kali Linux**. This will be used to intercept requests made to DVWA. We will demonstrate an alternative method of testing with SQLMap by capturing a request with Burp, saving it as a text file and then running it through SQLMap. It is recommended that you only run DVWA or other intentionally vulnerable applications in a virtual environment.

## Blind SQL injection testing

Detecting blind SQL injection involves sending queries that produce conditional responses or delay server response time. We will walk you through each step of the process so that you can perform thorough blind SQL injection testing and understand the reasoning or behavior behind each action. As a note, the exact query structure or commands may vary depending on the database used. MySQL is demonstrated.

**Step 1: Normal response**

Start by sending a normal response, such as entering '2', to see how the application behaves under normal circumstances. This helps to establish a baseline for expected behavior without the need to inject SQL code.

![SQL 16](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql16.png?raw=true)

**Step 2: simple test**

Perform a simple test by entering a single quote ( 2'#) after the '2' to see if this could indicate a potential vulnerability in the web application. If an error occurs or the behavior changes, it could suggest that the application is incorrectly handling user input and may be susceptible to SQL injection. This ( ') is not mandatory in all cases and may vary depending on the database you are testing against.

> NOTE: When testing within a form field, you should place a # at the end of your query to comment out any text that the program may later add.

![SQL 17](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql17.png?raw=true)

**Step 3: True/false test**

Perform the true/false tests by injecting conditions “ ‘ 2’ AND 1=1#(always true) and ‘ 2’ AND 1=0#” (always false) and observe the application's responses to both queries. If the application's behavior changes depending on the truth of the injected condition, it indicates that SQL code is being executed, confirming the presence of a vulnerability.

In a normal SQL injection attack, this true condition might return additional information from a table, but that is not the case in a blind attack. Again, you are looking for changes in the response.

![SQL 18](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql18.png?raw=true)

*The result of 1=1, an intentionally true condition.*

![SQL 19](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql19.png?raw=true)

*Result of 1=0, an intentionally false condition.*

**Step 4: Time-based test**

Test the time-based method by entering “ 2' AND SLEEP(5)#” in the query. Compare the response time with and without the suspend command. A noticeable delay indicates a potential vulnerability, as it shows that the application is executing the injected SQL command and waiting for the specified time before returning a response.

![SQL 20](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql20.png?raw=true)

> *Execute time-based attack.*

![SQL 21](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql21.png?raw=true)

> *Full time based attack.*

**Step 5: Determine the columns**

Determine the number of columns in the database using the 2' ORDER BY X#condition “ ”, where X is the number of columns we are testing. Increase the number until the behavior of the application changes, which means that you have found the correct length. This step is essential to understand the database structure, which can be useful when exploiting the vulnerability.

![SQL 22](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql22.png?raw=true)

> *Manual test for a column length of 1.*

![SQL 23](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql23.png?raw=true)

> *Manual test for a column length of 2.*

> 👉 In our case, the web application threw an error when we tested a column length of 3. This change in behavior lets us know that we have identified that the correct number of columns is 2, since that was the last successful test prior to the change. This is learned by observing the change in response.

**Step 6: Determine the length of DB**

Next, we will demonstrate the 2' AND LENGTH(DATABASE())=X#condition “ ”, where X is the number of characters being tested. This can be used to determine the length of the database name. We will use the same approach we just used to determine the number of columns, except this time we try to get the number of characters in the database name. To do this, we will try by character length iteratively.

![SQL 24](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql24.png?raw=true)

> *Test for a character length of 1.*

![SQL 25](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql25.png?raw=true)

> *Finally, a change indicates a database name length of 4.*

This can also be done with a suspend command in cases where a visual indicator is not available. For example, use “ 2' AND LENGTH(DATABASE())=X AND SLEEP(5)#” where X is the suspected database length. If the suspend command delays the application response, confirm the correct database length.

![SQL 26](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql26.png?raw=true)

**Step 7: Determine the name of the database**

Finally, we can begin to enumerate the actual database name. We already know that it has four characters, but we can do more by determining what those characters are. To do this, we will try different ASCII characters using 2' AND ASCII(SUBSTR(DATABASE(),X,X))>YYY#. In this case X is the position of the character we are testing and YY is the **[ASCII decimal character](https://www.asciitable.com/)** .

With this method, it asks the database if the first character is greater than a set letter. If it is not, it will respond with a negative. We will start somewhere near the middle of the lowercase alphabet with “l” (which is ASCII decimal 108). Then the query looks like this: 2' AND ASCII(SUBSTR(DATABASE(),1,1))>108#.

![SQL 27](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql27.png?raw=true)))

Based on the response, we know that the first character is not greater than “l”, so we need to change the operation to ask if it is less than “l”. We do this by changing the query to 2' AND ASCII(SUBSTR(DATABASE(),1,1))<108#.

![SQL 28](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql28.png?raw=true)

![SQL 29](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql29.png?raw=true)

Based on this answer, we now know that the first letter is somewhere between the lowercase “l” and all previous ASCII characters. Technically, this includes all capital letters, numbers and special characters. Knowing this we can start testing incrementally until we see a change in the response. In our case, we see a modified response once we enter 100.

![SQL 30](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql30.png?raw=true)

![SQL 31](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql31.png?raw=true)

This now tells us that the character is not less than a lower case “d”. We can confirm that this is the correct letter by inverting the query.

![SQL 32](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql32.png?raw=true)

![SQL 33](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql33.png?raw=true)

We have successfully confirmed the first character. Now, we can use this same method by changing the query to the location of the second character and repeating this again. We will make sure to change the location by entering 2' AND ASCII(SUBSTR(DATABASE(),2,2))<108#.

![SQL 34](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql34.png?raw=true)

![SQL 35](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql35.png?raw=true)

![SQL 36](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql36.png?raw=true)

> *With this result, we know that the second character is greater than the lowercase “l”.*

By now, you should understand the rationale behind each step. By observing application behavior in response to various injected SQL commands, you can effectively identify and understand blind SQL injection vulnerabilities.

In the next section, we will demonstrate how to exploit these vulnerabilities with the help of SQLMap. Continue practicing these techniques in a controlled environment to hone your skills and become an expert in detecting and exploiting blind SQL injection attacks.

### Example 1: Blind SQL Injection Exploitation*

Now that we have confirmed the vulnerability, we will follow the steps to exploit it using SQLMap. Pay attention to the screenshots of each step for a better understanding. Even better, follow the instructions to really solidify the process and learning in your mind and develop this skill.

**Step 1: Familiarize yourself with SQLMap**

Open the SQLMap help page to familiarize yourself with the type of information needed for an attack and the command structure of the tool. In particular we will see that we can use a URL with the -uband flag and the cookie information with the 

```bash
--cookie=COOKIE.

sqlmap -h
```

![SQL 37](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql37.png?raw=true)

**Step 2: Retrieve session information**

Collect the required cookies and security level from the browser's Developer Panel under the Storage tab.

![SQL 38](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql38.png?raw=true)

**Step 3: SQLMap URL command**

Run SQLMap with the information -uy --cookie=. Review the resulting information, which includes the parameters, payload, and the location of the output files.

![SQL 39](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql39.png?raw=true)

> *SQLMap executing URL attack.*

![SQL 40](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql40.png?raw=true)

> *Parameter return and output location.*

**Step 4: Open the session file.**

Now we will go to the terminal and navigate to the location of the output file. First, we will use it to see what files we have to work with. Use sqlitebrowser to open the session.sqlitefile.

![SQL 41](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql41.png?raw=true)

**Step 5: Database Browser**

In the sqlitebrowser, browse the database structure and explore the data tabs.

![SQL 42](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql42.png?raw=true)

> *Database structure tab display in DB Browser.*

![SQL 43](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql43.png?raw=true)

> *Display the “Search data” tab in DB Browser.*

**Step 6: view the target file** 

Go back to the terminal and use cat target.txtto view the file containing the command you used.

![SQL 44](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql44.png?raw=true)

**Step 7: View log**

Use cat log to view the contents of the log. This includes the same parameter and payload information we saw earlier, as well as details about the database and web application technology. All of this information could be useful in any follow-up penetration testing we may perform at later stages.

![SQL 45](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql45.png?raw=true)

**Step 8: SQLMap URL with database name indicator**

Now we will go back to the terminal and run the same command in SQLMap, but this time we will add '--dbs' to discover the database name. We know it has four characters because of our previous manual test, but we want to know more about this database.

![SQL 46](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql46.png?raw=true)

> *And there it is, “dvwa”!* 

**Step 9: SQLMap URL with column pointer**

Next, we want to get the user columns with the -D dvwa -T users --columns flags. This will give you much more information about what is actually inside the database.

![SQL 47](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql47.png?raw=true)

![SQL 48](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql48.png?raw=true)

**Step 10: SQLMap URL with user dump indicator**

Now we come to the good part, use `-T users --dump` to extract data from the user table. Review the response and notice how SQLMap prompts you to decrypt the hash of the passwords it discovers and then presents you with the results in a neat and tidy table.

![SQL 49](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql49.png?raw=true)

![SQL 50](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql50.png?raw=true)

> Here it checks the database and extracts information from the user.*

![SQL 51](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql51.png?raw=true)

> *SQLMap offers to decrypt password hashes. Yes, please*

![SQL 52](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql52.png?raw=true)

Note the orderly arrangement of the information in the image above. In addition to simply decrypting the passwords and placing them in a sorted table, SQLMap also automatically generates that information into a .csv file. This can then be incorporated into other tools to perform further exploits during a penetration test case.

### **Example 2: Exploiting blind SQL injection with HTTP data**

We will now demonstrate an alternative method to exploit blind SQL injection using SQLMap and **Burp Suite HTTP data collection**.

**Step 1: Intercept traffic with Burp Suite**.

Open Burp Suite, which you have configured to capture HTTP traffic. Then navigate to the Proxy tab and locate the query submission in the HTTP history.

![SQL 53](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql53.png?raw=true)

**Step 2: send request to the repeater**

In the Request pane, right click on the query submission and select 'Send to Repeater'.

**Step 3: Copy the raw data from Burp Suite**.

Switch to the Repeater tab and copy the raw request data from the panel.

![SQL 54](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql54.png?raw=true)

**Step 4: Create request file** 

Paste the raw request data into a new file that you will use with SQLMap. In our example, we call this file request.

![SQL 55](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql55.png?raw=true)

**Step 5: SQLMap loads the HTTP request file**

Go back to the terminal and run the `sqlmap -r request` command. The `-rindicador` tells SQLMap to parse and use the raw HTTP request from the specified file.

![SQL 56](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql56.png?raw=true)

As in the previous method, SQLMap will offer to decrypt the password hashes of the discovered user once it has extracted the data.

![SQL 57](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql57.png?raw=true)

> 👉 This method provides an alternative to manually entering cookie and URL information on the command line, which speeds up the process by using captured HTTP traffic. As with the previous methods, this information is sent to your directory and can be studied or used for future efforts.

## Blind SQL injection defense

By following best practices and guidelines recommended by reputable organizations such as **OWASP**, NIST, W3 and Amazon AWS, you can significantly strengthen your application's defenses against these attacks.

These organizations provide valuable information and resources covering a wide range of topics, including secure coding practices, database security, web application defenses, and incident monitoring and response. In this section, we will explore these best practices in detail and provide you with practical steps to help protect your web application against blind SQL injection vulnerabilities.

### Secure coding practices

Implementing secure coding practices is crucial to defend against blind SQL injection attacks. **[OWASP recommends using prepared statements](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)** or parameterized queries to separate user input from SQL code, which reduces the risk of injection. In addition, incorporating input validation techniques, such as whitelisting, helps **restrict the types of data users can enter**, which further enhances security.

### Database security

Database security measures are essential to minimize the potential impact of an attack. Limiting the privileges of database users ensures that attackers cannot gain access to sensitive information or perform unauthorized actions. Regularly updating and patching your database management system helps address known vulnerabilities, making it more difficult for attackers to exploit them. You can read more about this in **[NIST SP 800-44 version 2](https://csrc.nist.gov/publications/detail/sp/800-44/version-2/final)** (Section 6.4.2 discusses this specifically).

### Web application defenses

Implementing web application defenses, such as a web application firewall (WAF), can help detect and block SQL injection attempts. **[Amazon AWS analyzes](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-use-case.html)** how a WAF analyzes incoming traffic and filters malicious requests through database-managed rule sets, reducing the likelihood of a successful attack.

### Incident monitoring and response

Monitoring and logging application activity is vital to identify suspicious activity and detect potential attacks early on. **[NIST recommends](https://csrc.nist.gov/publications/detail/sp/800-44/version-2/final)** establishing a robust logging and monitoring system, along with a well-defined incident response plan, to ensure quick and effective responses to security incidents.

## Conclusion

Throughout this article, we have delved into blind SQL injection, exploring its unique characteristics and the techniques used to discover and exploit these vulnerabilities. From setting up a test environment with DVWA and Kali Linux to performing manual testing and using tools such as SQLMap and Burp Suite, we provide you with practical guidance and hands-on tips to gain skills in this complex subject.

In addition, we have emphasized the importance of implementing robust security measures such as secure coding practices, database security, web application defenses, and incident monitoring and response to protect against blind SQL injection attacks.

As we have shown, blind SQL injection is a formidable challenge in cyber security for web applications, but with the right knowledge and skills, you can effectively defend against these threats. Continue your learning by taking these courses to strengthen your aptitude in ethical web application defense and hacking:

## Frequently Asked Questions

- **What are the types of blind SQL injection?**

There are two main types of blind SQL injection:

**Boolean-based blind SQL injection**: In this type, attackers infer information from web application responses, such as content changes, error messages or HTTP status codes, although the actual query result is not directly visible.

**Time-based blind SQL injection**: In this type, attackers introduce delays in their SQL queries using time-sensitive functions (e.g. SLEEP or WAITFOR DELAY) and observe the response time of the web application to infer information about the database. The different response times indicate whether the injected condition was true or false.

- **What is a blind conditional SQL injection response?**

A conditional blind SQL injection response, also known as content-based or Boolean blind SQL injection, is a technique used by attackers to extract information from a vulnerable web application without directly seeing the result of their injected SQL queries.

Instead, attackers inject SQL statements with true or false conditions and observe changes in the behavior or content of the web application based on the veracity of these conditions. By analyzing these responses, the attacker can indirectly infer the information they are looking for in the database.

Think of this as a malicious set of 20 questions.

- **Which tools can be used to exploit blind SQL injection?**

There are several tools that can be used to exploit blind SQL injection vulnerabilities. Some of the most popular and effective tools include:

1. SQLMap: SQLMap, a powerful and widely used open source tool, automates the detection and exploitation of SQL injection vulnerabilities.

2. Burp Suite: This is a comprehensive web application security testing platform, which includes a range of tools for detecting and exploiting blind SQL injection vulnerabilities, such as the Repeater and Intruder modules.

3. Manual testing: while automated tools can be very useful, manual testing still plays an essential role in detecting and exploiting blind SQL injection vulnerabilities.

- **What are the signs that a website is vulnerable to blind SQL injection?**

While no indicator guarantees the presence of a vulnerability, the following signs can suggest that a web application may be susceptible to blind SQL injection:

1. Unexpected behavior: if the application exhibits unusual behavior when certain characters (such as single or double quotes) are entered into user input fields, it may indicate that the application is not properly handling or sanitizing user input.

2. Conditional responses: When injecting SQL queries that should return true or false, if the application exhibits different behavior depending on the truth of the injected condition, it may suggest a blind SQL injection vulnerability.

3. Time delays: The application experiences noticeable delays in response time when injecting specific SQL queries (e.g., when using the SLEEP() function).

4. Error messages: while error messages may not be directly visible in blind SQL injection attacks, any unusual error messages or responses from the application should be evaluated.

- **What are the best practices for preventing blind SQL injection?**

Best practices for preventing blind SQL injection involve a combination of secure coding practices, database security measures, web application defenses, and incident monitoring and response strategies.

**Advanced SQL Injection**

Advanced SQL injection is a more sophisticated technique than basic SQL injection, using more complex techniques to exploit vulnerabilities in web applications. This can include manipulating application input data, identifying filtering patterns, exploiting bugs in the application and using automated tools for malicious code injection. This attack can have serious consequences, such as exposure of confidential information, data theft, alteration of information stored in the database and loss of important data. Therefore, it is important that companies and web application developers implement adequate security measures to prevent this type of attack.

![SQL 58](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql58.png?raw=true)

## Consequences

The consequences of an Advanced SQL injection can include:

- **Data loss or alteration:** The attacker can delete, modify or extract information from the database.
- **System instability:** The malicious code can cause the database to stop functioning properly, which can result in downtime and loss of availability.
- **Difficulty in detecting and mitigating the attack:** Due to the malicious code being inserted into a legitimate SQL query.
- **Possibility of attack propagation:** If the attacker has access to sensitive data, such as user passwords, he can use it to propagate the attack to other systems.
- **Unauthorized access:** An attacker could gain unauthorized access to the system or web application, allowing him to access sensitive information or perform malicious actions on the system.
- **Data modification:** An attacker could modify, delete or add data to the system, which could have serious consequences on the integrity and accuracy of the data.
- **Execution of malicious code:** An attacker could execute malicious code on the system, which could result in taking control of the system or stealing confidential information.
- **Denial of service:** An attacker could use command injection to overload the system and render it inoperable.

**Failure to correct this flaw can cause unauthorized disclosure of your and your customers' information that could result in fraud, identity theft and regulatory penalties.** To prevent command injection, it is important to validate and filter all user input in web applications, and avoid using shell commands in web applications.  In addition, it is important to keep all applications and systems up to date and patched to prevent known vulnerabilities from being exploited.

## Solution

To prevent and remediate advanced SQL injection, the following steps can be taken:

- **Validate and sanitize all data inputs**: Ensure that all data inputs, whether provided by users or other sources, are properly validated and sanitized before being used in an SQL query.
- **Use parameterized queries:** Instead of building an SQL query dynamically using text strings, use parameterized queries that allow parameters to be passed as separate arguments. This will reduce the possibility of SQL injection, since parameter values are treated as data, not as part of the SQL query.
- **Limit database permissions:** Ensure that database users have only the permissions necessary to perform their roles and no more. This will limit the scope of any possible attack.
- **Use security tools and penetration testing:** Perform regular security testing and penetration testing on the application to identify potential security vulnerabilities and bugs. You can also use third-party security tools to protect the application against SQL injection.
- ***Update and patch database software and use web application firewalls (WAFs)**.

It is a difficult task to determine whether a user string is malicious or not. Therefore, the best way to do this is to “escape” the special characters in the user input. You can escape a string before constructing the query in PHP using the `mysql_escape_string()` function. Or in MySQL using the `mysqli_real_escape_string()` function.

While displaying the output as HTML, you will also need to convert the string to ensure that the special characters do not interfere with the HTML markup. You can convert special characters in PHP using the `htmlspecialchars()` function.

> 👉 Alternatively, you can use prepared statements to avoid SQL injections. A prepared statement is a template of a SQL query, where you specify the parameters at a later stage to execute it. Here is an example of a prepared statement in PHP and MySQLi.

```bash
$query = $mysql_connection->prepare("select * from user_table where username = ? and password = ?");`

$query->execute(array($username, $password));
```

> 📖 In summary, to troubleshoot and prevent advanced SQL injection, it is necessary to validate and sanitize all data entries, use parameterized queries, limit database permissions, and use security tools and penetration testing.

## References

- [https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [https://owasp.org/Top10/A03_2021-Injection/](https://owasp.org/Top10/A03_2021-Injection/)
- [https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection](https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection)
- [https://kinsta.com/es/blog/inyeccion-sql/](https://kinsta.com/es/blog/inyeccion-sql/)
- [https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html)
- [https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/](https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/)

