# SQL Injection

La inyección SQL es un tipo de ataque de inyección en el cual un atacante inserta código malicioso en una consulta SQL para ejecutar comandos no deseados en la base de datos. Los atacantes pueden utilizar la inyección de comandos para ejecutar comandos arbitrarios en el sistema, lo que podría permitirles obtener acceso no autorizado, modificar o eliminar datos, o incluso tomar el control total del sistema. Las inyecciones a menudo se realizan a través de campos de entrada, como formularios web, parámetros de URL o encabezados HTTP.

Los complementos de WordPress más útiles tienen algún tipo de interacción con la base de datos. La entrada del usuario se envía con frecuencia a la base de datos, ya sea porque necesita almacenarse en la base de datos, necesita modificar algo en la base de datos o porque se utiliza como parte de una declaración SELECT. Si la entrada del usuario no se valida ni se escapa correctamente, un atacante puede reemplazar esa entrada del usuario con comandos que puede enviar directamente a la base de datos.

Hay dos tipos de inyección SQL. Una vulnerabilidad de inyección SQL "clásica" es aquella en la que la entrada del usuario sin filtrar permite a un atacante enviar comandos a la base de datos y la salida se envía de vuelta al atacante. Una vulnerabilidad de inyección SQL "ciega" se produce cuando el atacante puede enviar comandos a la base de datos pero en realidad no ve la salida de la base de datos.

Según el análisis de Wordfence las vulnerabilidades de inyección SQL son la segunda vulnerabilidad más común que se encuentra en los complementos de WordPress.

![SQL 1](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql1.png?raw=true)

[https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/](https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/)

Cómo funciona una vulnerabilidad de inyección SQL clásica

Para comprender cómo funciona una vulnerabilidad de inyección SQL clásica, veamos un ejemplo de WordPress:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var("select post_title from " . $wpdb->posts . " where ID=" . $_GET['id']);
echo $title;
 |
| --- | --- |

El código anterior es un ejemplo de una vulnerabilidad de inyección SQL (SQLi). Es una vulnerabilidad de SQLi porque la entrada del usuario en $_GET['id'] se envía directamente a la base de datos sin desinfección ni escape. Esto permite a un atacante enviar comandos directamente a la base de datos.

Luego, la salida de la base de datos se envía directamente al navegador del usuario. Debido a que el resultado se envía al navegador, esto convierte a la vulnerabilidad en una vulnerabilidad SQLi clásica, a diferencia de una vulnerabilidad de inyección SQL ciega, que se analiza a continuación.

Al utilizar esta vulnerabilidad, un atacante puede enviar comandos directamente a la base de datos. Estos incluyen comandos SELECT para descargar su base de datos completa, incluida la información de identificación personal (PII) del usuario. En algunos casos, también incluye comandos INSERTAR y ACTUALIZAR para crear nuevas cuentas de usuario o modificar cuentas de usuario existentes.

Corregir la vulnerabilidad anterior es relativamente fácil. En WordPress simplemente necesita usar el método de preparación que desinfectará y escapará automáticamente cualquier dato que envíe a la base de datos. El código anterior se puede modificar de la siguiente manera para eliminar la vulnerabilidad SQLi:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var($wpdb->prepare("select post_title from " . $wpdb->posts . " where ID=%d", $_GET['id']));
echo $title;
 |
| --- | --- |

Tenga en cuenta que utilizamos el método $wpdb->prepare() para escapar de los datos que estamos enviando a la base de datos. Tiene una sintaxis similar a la función sprintf() que le permite utilizar marcadores de posición. %d es un número entero, %f es un flotante (o decimal) y %s es una cadena (o texto). Si utiliza %s como marcador de posición, no necesita incluir comillas, ya que se agregan automáticamente.

### ¿Cómo funciona una inyección SQL ciega?

Una vulnerabilidad de inyección SQL ciega se parece a la siguiente:

| 1
2
3 | global $wpdb;
$title = $wpdb->get_var("select post_title from " . $wpdb->posts . " where ID=" . $_GET['id']);
//Do something with title, but don't echo.
 |
| --- | --- |

En el ejemplo anterior, la entrada del usuario sin procesar y no desinfectada se envía directamente a la base de datos concatenando la variable $_GET['id'] directamente a la consulta SQL. Para corregir esta vulnerabilidad, simplemente usaría el método prepare() como se indicó anteriormente para desinfectar y escapar de cualquier entrada de la base de datos.

La diferencia aquí es que el resultado nunca se envía al navegador. Una vulnerabilidad SQLi ciega es tan grave como una vulnerabilidad SQLi normal porque, en algunos casos, un atacante puede insertar o actualizar datos fácilmente en su base de datos. La diferencia es que resulta más difícil extraer datos de la base de datos porque el atacante no puede ver el resultado de la base de datos porque no está escrito en el navegador web.

## Ataques SQL ciegos basados ​​en el tiempo

Generalmente, hay dos formas en que un atacante extrae datos de una base de datos mediante un ataque de inyección SQL ciega. El primero es utilizar un ataque basado en el tiempo. Supongamos que, utilizando la vulnerabilidad SQLi anterior, un atacante puede enviar cualquier comando a la base de datos, pero no puede ver el resultado. Sólo pueden ver la página web resultante.

Un atacante podría hacerle a la base de datos una pregunta como “¿La primera letra de la primera cuenta de administrador comienza con 'a'? Si es así, duerme 5 segundos y si no es así, no duermas nada. Si la página web tarda menos de 5 segundos en generarse y regresar al navegador web, saben que la cuenta de administrador no comienza con la letra 'a' y pasan a la siguiente letra, 'b', y preguntan. la misma pregunta.

Con esta técnica, un atacante puede lanzar un ataque basado en el tiempo en un sitio web y determinar los nombres de las cuentas de administrador y puede extraer contraseñas de usuario con hash.

El SQL real enviado a la base de datos podría verse similar al siguiente:

| 1
2
3
4
5
6 | select post_title from wp_posts where ID=1
  union select IF(
    substring(wp_users.user_login,1,1)='a',
    BENCHMARK(5000000,ENCODE('blah','asdf')),
    null)
  from wp_users where ID=1
 |
| --- | --- |

Lo que dice este SQL es "seleccione el título de la publicación donde el ID de la publicación es 1, pero combine en una consulta que llevará mucho tiempo si suponemos que la cuenta de usuario con ID 1 (que generalmente es una cuenta de administrador) tiene la letra ' a' como primera letra del nombre de usuario”.

Cuando se ejecuta esta consulta, si la página tarda mucho en cargarse, el atacante ha adivinado correctamente la primera letra del nombre de usuario del administrador. Luego pueden pasar a las letras dos y tres hasta que tengan su nombre de usuario de administrador. Una vez que lo tengan, pueden extraer su contraseña hash de administrador, su correo electrónico de administrador, cualquier correo electrónico de usuario o cualquier dato que deseen, siempre que se tomen el tiempo suficiente para ejecutar el ataque.

Recuerde, estos ataques son automatizados y las conjeturas incorrectas no toman tiempo, por lo que los datos se pueden extraer con relativa rapidez utilizando esta técnica.

Ataques de inyección SQL ciegos basados ​​en contenido

Un ataque de inyección SQL ciega basado en contenido es otra forma en que un atacante extrae datos de una base de datos cuando no puede ver la salida de la base de datos.

Si la consulta que genera el contenido es la siguiente (recuerde, el resultado de la consulta no se envía al usuario)

| 1 | select post_status from wp_posts where ID=1 |

Supongamos que el valor '1' anterior es un parámetro de consulta sin filtrar agregado a la consulta de la base de datos como en nuestro ejemplo anterior. Por tanto, un atacante puede controlar todo el texto después de 'ID='.

Un atacante puede agregar lo siguiente a la consulta para verificar que si incluye una condición falsa, verá generado contenido inusual:

| 1 | select post_status from wp_posts where ID=1 and 1=2 |

Obviamente, 1 no es igual a 2, por lo que en la consulta anterior la base de datos devolverá un conjunto de resultados vacío. El atacante examinará la página resultante y si es una página sin contenido o un mensaje de error que dice algo como "sin contenido", sabrá cómo se ve la respuesta de una consulta vacía con una condición falsa. Luego, el atacante puede incluir algo como lo siguiente:

| 1
2
3 | select post_status from wp_posts where ID=1
  and (select ID from wp_users where
  user_login='admin' and ID=1)
 |
| --- | --- |

La consulta anterior estará vacía si el usuario de la base de datos con ID 1 no tiene el nombre de usuario 'admin'. Sin embargo, devolverá un resultado normal no vacío al navegador si el usuario con ID 1 tiene el nombre de usuario "admin". Con esta técnica, un atacante puede extraer datos de una base de datos comprobando si hay respuestas vacías y no vacías de la aplicación.

Otro ejemplo de una consulta de inyección SQL ciega basada en contenido es:

| 1
2
3 | select post_status from wp_posts where
  ID=1 and (select 1 from wp_users where
  substring(user_pass,1,1) = 'a' and ID=1) |
| --- | --- |

La consulta anterior verificará si la primera letra de la contraseña hash para el usuario con ID 1 es una 'a'. Con esta técnica, un atacante puede revisar cada carácter y extraer la contraseña hash de las cuentas de administrador.

## Consecuencias

> Las consecuencias de una inyección SQL pueden incluir:
> 
- **Pérdida o alteración de datos:** el atacante puede eliminar, modificar o extraer información de la base de datos.
- **Inestabilidad del sistema:** el código malicioso puede causar que la base de datos deje de funcionar correctamente, lo que puede resultar en tiempos de inactividad y pérdida de disponibilidad.
- **Dificultad para detectar y mitigar el ataque:** debido a que el código malicioso se inserta en una consulta SQL legítima.
- **Posibilidad de propagación del ataque:** si el atacante tiene acceso a datos sensibles, como contraseñas de usuario, puede utilizarlos para propagar el ataque a otros sistemas.
- **Acceso no autorizado:** un atacante podría obtener acceso no autorizado al sistema o a la aplicación web, lo que le permitiría acceder a información confidencial o realizar acciones maliciosas en el sistema.
- **Modificación de datos:** un atacante podría modificar, eliminar o agregar datos al sistema, lo que podría tener graves consecuencias en la integridad y exactitud de los datos.
- **Ejecución de código malicioso:** un atacante podría ejecutar código malicioso en el sistema, lo que podría resultar en la toma de control del sistema o en el robo de información confidencial.
- **Denegación de servicio:** un atacante podría utilizar la inyección de comando para sobrecargar el sistema y hacer que se vuelva inoperable.
- **La no corrección de esta falla puede causar divulgación no autorizada de su información y la de sus clientes que podría dar lugar a fraude, usurpación de identidad y a sanciones reglamentarias.**
- Para evitar la inyección de comandos, es importante validar y filtrar todas las entradas de usuario en las aplicaciones web, y evitar el uso de comandos de shell en aplicaciones web. Además, es importante mantener todas las aplicaciones y sistemas actualizados y parcheados para evitar que se exploten vulnerabilidades conocidas.

## **Solución**

> Para prevenir y solucionar la inyección SQL avanzada, se pueden tomar las siguientes medidas:
> 
- **Validar y sanitizar todas las entradas de datos**: Asegúrese de que todas las entradas de datos, ya sean proporcionadas por los usuarios o por otras fuentes, sean validadas y sanitizadas adecuadamente antes de ser utilizadas en una consulta SQL.
- **Utilizar consultas parametrizadas:** En lugar de construir una consulta SQL dinámicamente utilizando cadenas de texto, utilice consultas parametrizadas que permitan que los parámetros sean pasados como argumentos separados. Esto reducirá la posibilidad de inyección SQL, ya que los valores de los parámetros son tratados como datos, no como parte de la consulta SQL.
- **Limitar los permisos de la base de datos:** Asegúrese de que los usuarios de la base de datos tengan solo los permisos necesarios para realizar sus funciones y nada más. Esto limitará el alcance de cualquier posible ataque.
- **Utilizar herramientas de seguridad y pruebas de penetración:** Realice pruebas regulares de seguridad y pruebas de penetración en la aplicación para identificar posibles vulnerabilidades y errores de seguridad. También puede utilizar herramientas de seguridad de terceros para proteger la aplicación contra la inyección SQL.
- Actualización y parcheo del software de la base de datos y uso de firewalls de aplicación web (WAF)

Es una tarea difícil determinar si una cadena de usuario es maliciosa o no. Por lo tanto, la mejor manera de hacerlo es “escapar” de los caracteres especiales en la entrada del usuario. Puede escapar una cadena antes de construir la consulta en PHP usando la función mysql_escape_string(). O en MySQL usando la función mysqli_real_escape_string().

Mientras se muestra la salida como HTML, también tendrá que convertir la cadena para asegurarse de que los caracteres especiales no interfieren con el marcado HTML. Puede convertir caracteres especiales en PHP usando la función htmlspecialchars(). Alternativamente, puede usar sentencias preparadas para evitar las inyecciones de SQL. Una sentencia preparada es una plantilla de una consulta SQL, en la que se especifican los parámetros en una etapa posterior para ejecutarla. Aquí hay un ejemplo de una declaración preparada en PHP y MySQLi.

`$query = $mysql_connection->prepare("select * from user_table where username = ? and password = ?");`

`$query->execute(array($username, $password));`

> 📖 En resumen, para solucionar y prevenir la inyección SQL avanzada, es necesario validar y sanitizar todas las entradas de datos, utilizar consultas parametrizadas, limitar los permisos de la base de datos y utilizar herramientas de seguridad y pruebas de penetración.

</aside>

REFERENCIAS

- [https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [https://owasp.org/Top10/A03_2021-Injection/](https://owasp.org/Top10/A03_2021-Injection/)
- [https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection](https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection)
- [https://kinsta.com/es/blog/inyeccion-sql/](https://kinsta.com/es/blog/inyeccion-sql/)
- [https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html)

# **Pruebas de inyección SQL: todo lo que necesita saber**

Para mejorar sus habilidades de pentester de aplicaciones web, es importante aprender a detectar vulnerabilidades de inyección SQL. Profundizarwmoa en los principios y métodos de prueba que pueden descubrir los detalles de esta amenaza. Exploraremos técnicas de prueba manuales, como analizar URL y formularios, comprender la interacción del usuario y el procesamiento de aplicaciones.

Además, proporcionaremos ejemplos reales de cargas útiles de inyección SQL que puede utilizar en sus propias pruebas. Para mejorar aún más sus habilidades, cubriremos la automatización con herramientas como SQLmap y Burp Suite, que ofrecen información de expertos de la industria sobre técnicas modernas. También obtendrá conocimientos sobre la interpretación de mensajes de error complejos que son cruciales para identificar y resolver problemas. Al dominar las técnicas básicas y avanzadas descritas en este artículo, podrá mejorar la seguridad de sus aplicaciones y contribuir a un entorno digital más seguro.

## **Comprender las inyecciones SQL**

Las inyecciones SQL son una vulnerabilidad informática que puede afectar aplicaciones web y bases de datos que utilizan el lenguaje SQL. Estos ataques aprovechan las vulnerabilidades en los formularios de entrada y las URL dentro de las aplicaciones. Insertan intencionalmente declaraciones SQL dañinas en las solicitudes del servidor. El objetivo principal de un ataque de inyección SQL es controlar cómo funciona la base de datos. Esto permite el acceso no autorizado a datos confidenciales extrayéndolos, modificándolos o eliminándolos.

**Los ataques de inyección SQL se pueden dividir en varias categorías. Los más conocidos son:**

**Inyección basada en errores:** esta técnica implica insertar entradas dañinas en la base de datos de un sistema para provocar errores. Estos errores potencialmente pueden brindarle información útil.

![SQL 2](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql2.png?raw=true)

**Inyección basada en unión:** el operador UNION le permite combinar los resultados de una consulta dañina y una consulta válida. Esto les permite acceder a datos de otras tablas sin permiso.

![SQL 3](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql3.png?raw=true)

**Inyección ciega** : en este tipo de ataque, el perpetrador no recibe una respuesta directa del servidor. En cambio, infieren información sobre el comportamiento del sistema para recopilar datos.

![SQL 4](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql4.png?raw=true)

**Inyección ciega basada en el tiempo** : esta técnica implica agregar intencionalmente retrasos a las consultas para verificar la precisión de condiciones específicas. Al analizar los mensajes de error, puede extraer información valiosa sobre la base de datos, lo que ayuda a una mayor explotación, como descubrir nombres de tablas o detalles del sistema, sin generar alarmas ni sospechas.

## **Pruebas manuales de inyección SQL**

Profundicemos ahora en las técnicas manuales de prueba de inyección SQL examinando de cerca la estructura de la URL. Al hacerlo, podemos identificar vulnerabilidades potenciales y explotarlas con fines de evaluación de seguridad.

**Analizando la estructura de la URL**

![SQL 5](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql5.png?raw=true)

Durante el proceso de prueba manual de inyección SQL, un análisis profundo de la estructura de la URL es esencial para identificar y evaluar vulnerabilidades en las aplicaciones web. Este enfoque implica identificar debilidades en la aplicación inyectando intencionalmente código SQL malicioso a través de parámetros que se encuentran dentro de las URL.

Para analizar la vulnerabilidad de un sitio web a los ataques de inyección SQL, es importante identificar cualquier entrada del usuario que se transmita a través de los parámetros de la URL. Estos parámetros pueden servirle potencialmente como puntos de entrada. Una vez que se identifican estos parámetros, probar su manipulabilidad se vuelve crucial.

Esto implica insertar varias cadenas de prueba, caracteres especiales y secuencias de escape para determinar si la aplicación maneja adecuadamente dichas entradas sin generar errores.

![SQL 6](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql6.png?raw=true)

Otro paso importante es examinar minuciosamente los mensajes de error que produce la aplicación. Estos mensajes pueden exponer inadvertidamente vulnerabilidades internas en el sistema, descubriendo potencialmente debilidades de inyección SQL.

Por ejemplo, en la imagen de arriba, puede ver un error generado al manipular el parámetro **de usuario** en la URL, lo que nos ayuda a identificar la **consulta SQL específica**  que está causando el error. Esto luego podría usarse para intentar explotar la vulnerabilidad que está causando el error o lanzar un ataque de denegación de servicio (DoS) en el sitio web enviando demasiadas consultas SQL no válidas.

Para profundizar más en las pruebas de este tipo de URL, puede intentar identificar dónde se inserta la entrada del usuario en la consulta SQL. Puede ser un campo de entrada, una variable en la URL o cualquier forma de entrada del usuario.

Para comenzar, puede utilizar una carga útil de SQL básica como esta:' OR '1'='1

Inserte esta carga útil en la entrada sospechosa y vea si el mensaje de error de SQL desaparece. Si el mensaje de error desaparece o se produce un comportamiento diferente, podría ser una señal de que el sitio es vulnerable a un ataque de inyección SQL. Si la carga útil básica no produce resultados significativos, es posible que desee experimentar con cargas útiles de SQL más avanzadas, como la inyección SQL ciega basada en UNION o basada en tiempo. Por ejemplo, una carga útil basada en UNION que podrías probar es: ' UNION

`SELECT null, username, password FROM users--`

Este tipo de carga útil intenta extraer información de la tabla de usuarios. Sin embargo, tenga cuidado al utilizar cargas útiles avanzadas como esta, ya que pueden afectar negativamente al sitio que está probando, si no se usan correctamente.

En resumen, analizar la estructura de la URL en las pruebas manuales de inyección SQL puede ayudar a identificar vulnerabilidades potenciales y evaluar la capacidad de una aplicación para manejar entradas maliciosas, brindándole datos importantes para continuar con su pentest.

## **Campos de formulario y mecanismos de validación**

Los campos de formulario en una aplicación web sirven como punto de entrada para la entrada del usuario. Puede explotar estos campos mediante inyecciones SQL, donde inyecta código SQL dañino. Estos campos de formulario se utilizan comúnmente para recopilar datos importantes del usuario, como nombres, direcciones de correo electrónico, contraseñas y más.

La combinación de campos de formulario bien diseñados con mecanismos de validación sólidos puede mitigar eficazmente el riesgo de inyecciones de SQL. Por ejemplo, un campo de correo electrónico debe aceptar estrictamente sólo direcciones de correo electrónico válidas, evitando la inserción de caracteres especiales que podrían manipular consultas SQL. Este no es siempre el caso y está sujeto a abuso.

Probar para ver si el formulario acepta caracteres especiales o entradas no típicas puede indicar la posibilidad de enviar comandos o solicitudes maliciosos a la base de datos.

![SQL 7](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql7.png?raw=true)

Cuando se prueban manualmente las vulnerabilidades de inyección SQL, las medidas de seguridad existentes, como la validación de las entradas del usuario, a veces pueden impedir el proceso de inyección. En tales casos, vale la pena explorar cargas útiles básicas, como insertar **'OR 1=1--** en el campo de entrada; Este tipo de cargas útiles se denominan cargas útiles de omisión porque utilizan una condición que siempre es verdadera para manipular una entrada vulnerable y omitir la autenticación, acceder a datos no autorizados o ejecutar comandos maliciosos.

![SQL 8](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql8.png?raw=true)

Si bien la validación de entradas es una salvaguarda importante, no siempre es infalible, por lo que para identificar posibles vulnerabilidades es esencial realizar pruebas completas y exhaustivas.

## **Valores de cookies y encabezados HTTP**

En las pruebas de inyección SQL manuales, puede manipular las solicitudes explotando los valores de las cookies y los encabezados HTTP de una aplicación web. Estos elementos se consideran entradas externas, por lo que es importante que realice pruebas adecuadas con las herramientas correctas (como Burp Suite).

Las cookies, que contienen información almacenada en el navegador de un usuario, pueden ser vulnerables a la manipulación. Un método común es inyectar código SQL dañino alterando los datos dentro de una cookie. Si se utiliza una cookie, por ejemplo, para almacenar una identificación de usuario en una aplicación, puede intentar modificar esa identificación dentro de la propia cookie. Este tipo de explotación podría dar lugar a un acceso no autorizado a datos o funciones sensibles.

> 💡 Por ejemplo, considere una aplicación que utiliza una cookie para controlar al usuario que ha iniciado sesión actualmente. Ahora, supongamos que un hacker con intenciones maliciosas logra alterar esta cookie alterando el ID de usuario que contiene.

</aside>

Si la aplicación no aborda adecuadamente esta modificación, podría generar involuntariamente una consulta SQL dañina basada en el ID manipulado. Esto podría potencialmente otorgar acceso no autorizado a datos confidenciales.

Además, cuando un navegador envía una solicitud a una aplicación, incluye encabezados HTTP como User-Agents. Usted (el atacante) puede alterar estos encabezados insertando cadenas dañinas en las solicitudes. Por ejemplo, podría utilizar la siguiente carga útil:'UNION SELECT null, username, password FROM users--

Esta carga útil está diseñada para extraer datos de la tabla de "usuarios" de una base de datos. Supongamos que tiene una solicitud HTTP GET que incluye un parámetro "cat" en el que colocar la carga útil. En la pestaña "Solicitud HTTP" de Burp Suite, cambie el parámetro "cat" para que contenga la carga útil, por ejemplo:cat=' UNION SELECT null, username, password FROM users--

Comience a enviar la solicitud y observe la respuesta. Si el sitio es vulnerable a una inyección SQL basada en UNION, obtendrá una respuesta que incluye información de la tabla "usuarios".

![SQL 9](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql9.png?raw=true)

En ambos casos, es esencial garantizar que la aplicación maneje de forma segura los valores de las cookies y los encabezados HTTP. Las pruebas manuales implican analizar el impacto de dichas manipulaciones en las entradas de la aplicación y verificar su respuesta a posibles ataques de inyección SQL.

**Entrada controlada por el usuario (UCI) procesada por la aplicación**

Cuando se prueban manualmente las vulnerabilidades de inyección SQL, el concepto de "Entrada controlada por el usuario" o UCI se refiere a cualquier entrada proporcionada por el usuario y posteriormente procesada por la aplicación. Esto puede incluir datos ingresados ​​en campos de formulario, valores de cookies, parámetros en URLs o encabezados HTTP (que ya vimos antes), puedes aprovechar estas oportunidades para inyectar código SQL malicioso y causar grandes daños.

En este enfoque, manipula intencionalmente la entrada proporcionada para insertar caracteres especiales o secuencias de escape (como ‘’ o =). Estas manipulaciones pueden alterar las consultas SQL generadas por la aplicación y explotar vulnerabilidades en su procesamiento de entrada. El objetivo es engañar a la aplicación para que ejecute consultas SQL no deseadas, lo que resulta en una extracción de datos no autorizada o en un compromiso del sistema.

### **Debe tener una lista de cargas útiles de inyección SQL**

Las cargas útiles son fragmentos de código que se insertan intencionalmente en los campos de entrada de las aplicaciones web. Estos fragmentos tienen como objetivo explotar las vulnerabilidades en los sistemas de gestión de bases de datos. Los profesionales de la seguridad y los evaluadores de penetración suelen utilizar estas herramientas para evaluar el nivel de resistencia que tiene una aplicación contra posibles ataques. A continuación, se muestra una lista de las cargas útiles de

inyección SQL más comunes utilizadas por **Pentesters**  y **Bug Bounty Hunters**  (en un contexto de piratería ética) para probar manualmente formularios en busca de vulnerabilidades de inyección SQL:

- payload de inyección SQL básica: **' OR '1'='1** (se utiliza para omitir la autenticación ingresando una condición que siempre es verdadera).
- Recuperar información: **' UNION SELECT null,username,password FROM users--** (Se utiliza para extraer datos confidenciales como nombre de usuario y contraseña de la base de datos).
- Manipulación de consultas: **'; DROP TABLE users; --** (Se utiliza para provocar la eliminación de la tabla "usuarios").
- Obtener los nombres de las tablas: **' AND 1=0 UNION SELECT table_name, null FROM information_schema.tables--** (Se utiliza para extraer los nombres de las tablas en la base de datos).
- Extraer nombre de la base de datos: **' AND 1=0 UNION SELECT null, database()--** (Se utiliza para extraer el nombre de la base de datos actual).
- Uso de UNION para extraer datos: **' UNION SELECT username, password FROM users--** (Se utiliza para extraer datos confidenciales mediante una operación UNION).
- Uso de comentarios para omitir: **admin' --** (Utiliza un comentario para omitir el resto de la entrada e iniciar sesión como administrador).
- Uso de SQLi ciego basado en tiempo: **' OR IF(1=1, SLEEP(5), 0)--** (Retrasa la respuesta del servidor para confirmar la vulnerabilidad de inyección SQL).
- Uso de SQLi basado en errores: **' AND 1=CONVERT(int, (SELECT @@version))--** (fuerza un error de SQL a revelar información de la base de datos).

Todas estas cargas útiles se pueden usar (y son las más efectivas) en **formularios de inicio de sesión** vulnerables , **URL** (usadas como consultas maliciosas) y **solicitudes** (capturadas y modificadas por usted con la carga útil correcta).

### **Pruebas automatizadas de inyección de SQL**

Cuando se trata de seguridad de la información, herramientas como SQLmap y Burp Suite gozan de gran prestigio en el campo de las pruebas de inyección SQL.

### **Descripción general de las herramientas: SQLmap y Burp Suite**

Estas herramientas son ampliamente utilizadas por los profesionales de la seguridad y brindan soluciones automatizadas efectivas para detectar y explotar vulnerabilidades de inyección SQL en aplicaciones web. Si bien SQLmap se especializa en pruebas y automatización avanzadas, Burp Suite ofrece un ecosistema completo para analizar la seguridad de las aplicaciones. Permite a los expertos identificar, evaluar y abordar vulnerabilidades críticas, incluidas aquellas relacionadas con ataques de inyección SQL.

Ahora veamos en detalle para qué sirven estas herramientas y para qué se utilizan:

- **SQLmap** : es una valiosa herramienta de código abierto que automatiza las pruebas de inyección de SQL. Detecta vulnerabilidades de forma eficaz, extrae datos y compromete los sistemas de bases de datos utilizando una variedad de cargas útiles y técnicas. Los probadores de penetración dependen principalmente de SQLmap para evaluar la seguridad de las aplicaciones.

![SQL 10](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql10.png?raw=true)

- **Burp Suite** : es un conjunto completo de herramientas diseñadas para la seguridad de aplicaciones web. Entre sus características, la herramienta incluye un módulo de Seguridad de Aplicaciones Web (WAS), que ayuda a los especialistas en seguridad a identificar y abordar vulnerabilidades en sitios web. Este módulo puede detectar amenazas de seguridad comunes que incluyen, como es de esperar, ataques de inyección SQL.

![SQL 11](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql11.png?raw=true)

### **Ejecución de SQLmap para buscar y explotar inyecciones de SQL**

Ahora, usemos SQLmap para descubrir sistemáticamente vulnerabilidades de inyección SQL en un sitio web deliberadamente vulnerable. Nuestro objetivo será VulnWeb ( http://testphp.vulnweb.com ), un sitio web diseñado específicamente para que los estudiantes de Seguridad Cibernética aprendan atacando y explotando sus vulnerabilidades.

Si encuentra una URL web como, en este caso, [http://testphp.vulnweb.com/listproducts.php](http://testphp.vulnweb.com/listproducts.php)? **cat=1** , donde el parámetro 'GET' está resaltado, podría indicar que el sitio web es susceptible a ataques de inyección SQL. En tales casos, es posible que pueda acceder a información confidencial de la base de datos. Se sabe que SQLmap es el más eficaz en escenarios que involucran sitios web basados ​​en PHP.

![SQL 12](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql12.png?raw=true)

**Paso 1: Evaluación del parámetro de la URL**

Una forma sencilla de determinar si su sitio web es vulnerable es reemplazar el valor en el parámetro de solicitud de obtención con un *****  (asterisco).

![SQL 13](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql13.png?raw=true)

Este tipo de error sugiere que el sitio web es vulnerable a algún tipo de ataques de inyección SQL.

**Paso 2: comprobar la URL con SQLmap**

Necesitamos ingresar la URL web deseada que debe verificarse, usando el parámetro -u . Generalmente el objetivo principal es determinar si es posible acceder a una base de datos, por lo que podemos utilizar la opción --dbs  para este propósito. Al utilizar --dbs, podemos obtener una lista de todas las bases de datos disponibles.

El primer comando será:

`sqlmap -u [http://testphp.vulnweb.com/listproducts.php?cat=1](http://testphp.vulnweb.com/listproducts.php?cat=1) --dbs`

![SQL 14](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql14.png?raw=true)

**Paso 3: comprender el resultado**

En el resultado anterior, puede ver en amarillo las partes donde SQLmap encontró vulnerabilidades de inyección SQL y en naranja las mejores cargas útiles, sugeridas por SQLmap, para usar ese tipo específico de inyección SQL (por ejemplo, la primera vulnerabilidad encontrada es una vulnerabilidad booleana). **Inyección SQL ciega** basada y la carga útil sugerida es: cat-1 AND 1050-1050). Tomemos, por ejemplo, la última parte del resultado, resaltada en amarillo, que dice: “El parámetro GET **'cat'** es ' **Consulta UNION genérica** '.

Esta parte del resultado nos dice que el parámetro "cat" de una solicitud GET (que es el tipo de solicitud web que, en este caso, SQLmap está usando para probar la URL) dentro de "[http://testphp.vulnweb.com](http://testphp.vulnweb.com/) /listaproductos.php? **cat** =1” es vulnerable a una consulta UNION genérica.

**Pero ¿qué es una consulta UNION Genérica?**

Es un ataque que normalmente implica manipular la consulta SQL para combinar los resultados de 2 o más tablas de bases de datos, lo que le permite obtener acceso no autorizado a datos confidenciales. En resumen, este resultado de SQLmap sugiere que se necesitan más pruebas para confirmar si el parámetro **'cat'** es realmente vulnerable a un ataque de inyección SQL de "consulta UNION genérica". Es una señal para investigar y potencialmente explotar una vulnerabilidad en la validación de entrada de la aplicación (que es la parte de la aplicación web que verifica y permite la entrada del usuario según la consulta utilizada).

Y es por eso que podemos ver, en el último resultado resaltado en naranja, que SQLmap sugiere una carga útil específica, para probar manualmente el sitio web vulnerable para ese tipo de ataque de inyección SQL.

## **Análisis de mensajes de error**

Durante el proceso de análisis de errores en las pruebas de inyección SQL, los errores generados por una aplicación pueden ofrecer información importante sobre la existencia de vulnerabilidades. Por ejemplo, los mensajes de error que contienen información confidencial como nombres de tablas, errores flagrantes de sintaxis SQL en los comentarios de la aplicación y respuestas inconsistentes, como resultados faltantes o duplicados, pueden indicar una posible manipulación de la consulta.

![SQL 15](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql15.png?raw=true)

Estos mensajes de error pueden ofrecer información valiosa sobre el funcionamiento interno del sistema. Para activar estos mensajes, se pueden ingresar intencionalmente datos maliciosos que provoquen que las consultas fallen. En la imagen de arriba, puede ver un error de sintaxis SQL (que ya mencionamos antes) que aparece después de cambiar el valor del parámetro **cat de " 1** " a ***** (ejemplo de entrada maliciosa).

Si encuentra errores de sintaxis SQL, como el comúnmente visto "Tiene un error en su sintaxis SQL" (que podemos ver en la imagen), generalmente significa que la entrada se incluye directamente en las consultas sin la verificación adecuada. Este tipo de errores a menudo indican un comportamiento interno del sistema y ayudan a los expertos en seguridad a identificar posibles debilidades en las aplicaciones.

## **Preguntas frecuentes**

- **¿Es ilegal realizar pruebas de inyecciones de SQL?**

La legalidad de cualquier Pentest depende únicamente de las leyes locales y federales de su país, por lo que es una buena práctica estar informado sobre ellas antes de realizar cualquier tipo de prueba activa. Sin embargo, no debería haber ningún problema siempre que la actividad se realice de manera responsable y en plataformas donde se haya obtenido el **permiso por escrito**  del propietario.

- **¿Qué son las técnicas de inyección SQL?**

Existen varias técnicas que se pueden utilizar para manipular consultas, como ataques UNION, ataques basados ​​en tiempo y ataques basados ​​en errores. Estas técnicas implican el uso de datos maliciosos para explotar vulnerabilidades.

- **¿Cuál es la mejor herramienta de inyección SQL?**

Para fines de automatización, SQLmap se utiliza ampliamente, mientras que Burp Suite ofrece una solución versátil para análisis de seguridad.

- **¿Necesito aprender SQL para inyecciones de SQL?**

Tener algunos conocimientos de SQL puede resultar útil, pero también hay herramientas disponibles que pueden simplificar el proceso de identificación de vulnerabilidades.

## **Inyección SQL ciega**

La inyección ciega de SQL, una forma sigilosa y astuta de ataque de inyección de SQL, plantea un desafío único para los profesionales de la seguridad debido a su naturaleza esquiva y su dificultad de detección y explotación. En este completo artículo, profundizaremos en el mundo de la inyección SQL ciega y descubriremos los matices sutiles que la distinguen de otros ataques de inyección SQL.

A lo largo del artículo, analizaremos varias herramientas y métodos, centrándonos en Kali Linux como nuestra plataforma preferida, aunque puede utilizar las herramientas mencionadas en la mayoría de los sistemas operativos. A medida que concluimos, le brindaremos un conjunto de mejores prácticas probadas para defender sus aplicaciones web contra estos ataques esquivos y potencialmente dañinos. Al final de este artículo, estará bien versado en cómo comprender, explotar y defenderse contra las vulnerabilidades de inyección SQL ciega.

Ahora, profundicemos en esta guía detallada y prepárese con los conocimientos y técnicas esenciales para abordar de manera efectiva los desafíos que plantea este tipo de vulnerabilidad.

### **¿Qué es la inyección SQL ciega?**

La inyección SQL es una vulnerabilidad frecuente de las aplicaciones web que ocurre cuando un atacante logra ejecutar **código SQL** no autorizado en la base de datos de una aplicación web. Los atacantes hacen esto insertando declaraciones SQL maliciosas en los campos de entrada del usuario, como cuadros de búsqueda o formularios de inicio de sesión. Cuando tiene éxito, un atacante puede obtener información confidencial de la base de datos, modificar o eliminar datos e incluso ejecutar comandos administrativos.

La inyección ciega de SQL, una variante más oculta, ocurre cuando el atacante **no puede ver directamente el resultado** de sus consultas inyectadas. En este caso, deben deducir los resultados indirectamente utilizando técnicas basadas en contenido o en tiempo. Este tipo de ataque se utiliza cuando la aplicación no muestra visiblemente los resultados de una consulta SQL inyectada, lo que dificulta que el atacante confirme el éxito de sus acciones.

El beneficio de utilizar la inyección SQL ciega sobre un ataque de inyección SQL estándar radica en su sutileza. Dado que el atacante no ve directamente el resultado, puede resultar más difícil para los sistemas de seguridad o los administradores detectar el ataque. El atacante suele utilizar respuestas condicionales ( **basadas en booleanos** ) o retrasos en el tiempo de respuesta de la aplicación ( **basadas en tiempos** ) para inferir si el código SQL inyectado ha tenido el efecto deseado.

Al recopilar lenta y metódicamente información sobre la estructura y el contenido de la base de datos, un atacante aún puede explotar una vulnerabilidad de inyección SQL ciega para acceder a datos confidenciales y manipular el sistema sin levantar sospechas inmediatas.

## **Descargo de responsabilidad**

Queremos ser absolutamente claros sobre la importancia de cumplir con las leyes aplicables con respecto al escaneo y la explotación de vulnerabilidades de aplicaciones web. Antes de realizar cualquier forma de piratería ética o prueba de penetración en un sistema, **asegúrese de haber obtenido el permiso explícito** del sistema o del propietario de la red.

La piratería o el escaneo no autorizados pueden parecer triviales, pero pueden acarrear graves consecuencias legales, incluidas multas o prisión, según su jurisdicción. **No lo hagas.** Algunas de las leyes que rigen esta actividad incluyen:

- La Ley de Abuso y Fraude Informático (Estados Unidos)
- Secciones 184, 342.1, 380 y 430 del Código Penal de Canadá (Canadá)
- Ley de uso indebido de computadoras de 1990 (Inglaterra)
- Segundo. 202a y 202b del Código Penal alemán (Alemania)
- Ley de Tecnología de la Información Sec. 43 y 66 (India)
- Ley sobre la prohibición del acceso no autorizado a ordenadores (Japón)

 Si duda si está actuando con claridad, consulte el acuerdo o el alcance de sus actividades autorizadas con una entidad específica o revise el código de conducta o las pautas de divulgación con cualquiera de los programas de recompensas por errores mencionados al final de este artículo.

## **Descubriendo y explotando SQLi ciego**

Ahora que tiene un conocimiento sólido de la inyección SQL ciega y en qué se diferencia de la inyección SQL normal, profundicemos en el **proceso de descubrir** y explotar estas vulnerabilidades.  Primero, lo guiaremos en la configuración de su entorno de laboratorio, luego realizaremos pruebas manuales de inyección ciega de SQL y, finalmente, usaremos herramientas como SQLMap y Burp Suite para agilizar el proceso de explotación.

### **Configurando su laboratorio**

Para comenzar, deberá configurar su laboratorio para descubrir y explotar vulnerabilidades de inyección SQL ciega. Hay **varias herramientas que puede utilizar** y usaremos las siguientes herramientas y recursos:

**Maldita aplicación web vulnerable (DVWA):** DVWA es una aplicación web intencionalmente vulnerable que proporciona un entorno seguro para practicar diversas técnicas. **Viene preinstalado en Kali Linux** o puedes descargarlo con sudo apt install dvwa. Una vez instalado, establezca el nivel de dificultad en "bajo" o "medio" y navegue hasta el desafío "Inyección SQL (ciega)". Usaremos esto para simular un escenario del mundo real y demostrar métodos de prueba. Para iniciar la aplicación DVWA:

1. Abra la terminal y escriba el comando: dvwa-start.
2. Si no está en la cuenta raíz, se le pedirá que lo permita.
3. El navegador debería abrirse automáticamente en DVWA.
4. (Alternativamente) Si no se abre, vaya al navegador e ingrese: **[http://127.0.0.1:42001](http://127.0.0.1:42001/)**en la barra de direcciones.
5. Para detener el servidor DVWA, regrese a la terminal y escriba el comando: dvwa-stop.

**SQLMap:** esta poderosa herramienta de código abierto automatiza la detección y explotación de vulnerabilidades de inyección SQL. **Viene preinstalado en Kali Linux** , por lo que si ese es el sistema operativo que estás usando, no necesitas descargarlo por separado. Usaremos SQLMap para automatizar la explotación de la vulnerabilidad de inyección SQL ciega descubierta en DVWA.

**Burp Suite:** Burp Suite es un conjunto de herramientas de prueba de seguridad de aplicaciones web ampliamente utilizado. Para este artículo, usaremos la Community Edition, **que viene preinstalada en Kali Linux** . Esto se utilizará para interceptar las solicitudes realizadas a la DVWA. Demostraremos un método alternativo de prueba con SQLMap capturando una solicitud con Burp, guardándola como un archivo de texto y luego ejecutándola a través de SQLMap. Se recomienda que sólo ejecute DVWA u otras aplicaciones intencionalmente vulnerables en un entorno virtual.

## **Pruebas de inyección SQL ciega**

La detección de una inyección SQL ciega implica enviar consultas que producen respuestas condicionales o retrasan el tiempo de respuesta del servidor. Lo guiaremos a través de cada paso del proceso para que pueda realizar pruebas exhaustivas de inyección SQL ciega y comprender el razonamiento o el comportamiento detrás de cada acción. Como nota, la estructura de consulta exacta o los comandos pueden variar según la base de datos utilizada. Se demuestra MySQL.

**Paso 1: respuesta normal**

Comience enviando una respuesta normal, como ingresar '2', para ver cómo se comporta la aplicación en circunstancias normales. Esto ayuda a establecer una base para el comportamiento esperado sin necesidad de inyectar código SQL.

![SQL 16](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql16.png?raw=true)

**Paso 2: prueba sencilla**

Realice una prueba sencilla ingresando una comilla simple ( 2‘#) después del '2' para verificar si esto podría indicar una vulnerabilidad potencial en la aplicación web. Si se produce un error o el comportamiento cambia, podría sugerir que la aplicación está manejando incorrectamente la entrada del usuario y puede ser susceptible a la inyección SQL. Este ( ‘) no es obligatorio en todos los casos y puede variar según la base de datos en la que esté probando.

NOTA: Al realizar pruebas dentro de un campo de formulario, debe colocar un #al final de su consulta para comentar cualquier texto que el programa pueda agregar posteriormente.

![SQL 17](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql17.png?raw=true)

**Paso 3: prueba de verdadero/falso**

Realice las pruebas de verdadero/falso inyectando condiciones " " 2’ AND 1=1#(siempre verdadera) y " 2’ AND 1=0#" (siempre falsa) y observe las respuestas de la aplicación a ambas consultas. Si el comportamiento de la aplicación cambia según la veracidad de la condición inyectada, indica que el código SQL se está ejecutando, confirmando la presencia de una vulnerabilidad.

En un ataque de inyección SQL normal, esta condición verdadera podría devolver información adicional de una tabla, pero ese no es el caso en un ataque ciego. Nuevamente, estás buscando cambios en la respuesta.

![SQL 18](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql18.png?raw=true)

*El resultado de 1=1, una condición intencionalmente verdadera.*

![SQL 19](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql19.png?raw=true)

*El resultado de 1=0, una condición intencionalmente falsa.*

**Paso 4: prueba basada en el tiempo**

Pruebe el método basado en tiempos introduciendo " 2’ AND SLEEP(5)#" en la consulta. Compare el tiempo de respuesta con y sin el comando de suspensión. Un retraso notable indica una vulnerabilidad potencial, ya que demuestra que la aplicación está ejecutando el comando SQL inyectado y esperando el tiempo especificado antes de devolver una respuesta.

![SQL 20](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql20.png?raw=true)

> *Ejecutar el ataque basado en el tiempo.*

![SQL 21](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql21.png?raw=true)

> *Ataque basado en tiempo completo.*

**Paso 5: determinar las columnas**

Determine la cantidad de columnas en la base de datos usando la 2’ ORDER BY X#condición " ", donde X es la cantidad de columnas que estamos probando. Incremente el número hasta que cambie el comportamiento de la aplicación, lo que significa que ha encontrado la longitud correcta. Este paso es esencial para comprender la estructura de la base de datos, lo que puede resultar útil a la hora de explotar la vulnerabilidad.

![SQL 22](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql22.png?raw=true)

> *Prueba manual para una longitud de columna de 1.*

![SQL 23](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql23.png?raw=true)

> *Prueba manual para una longitud de columna de 2.*

> 👉 En nuestro caso, la aplicación web arrojó un error cuando probamos una longitud de columna de 3. Este cambio en el comportamiento nos permite saber que hemos identificado que el número correcto de columnas es 2, ya que esa fue la última prueba exitosa antes del cambio. . Esto se aprende observando el cambio en respuesta.

</aside>

**Paso 6: Determinar la longitud de DB**

A continuación, demostraremos la 2’ AND LENGTH(DATABASE())=X#condición " ", donde X es el número de caracteres que se prueban. Esto se puede utilizar para determinar la longitud del nombre de la base de datos. Usaremos el mismo enfoque que acabamos de usar para determinar el número de columnas, excepto que esta vez intentamos obtener el número de caracteres en el nombre de la base de datos. Para hacer esto, probaremos por longitud de caracteres de manera iterativa.

![SQL 24](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql24.png?raw=true)

> *Prueba para una longitud de carácter de 1.*

![SQL 25](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql25.png?raw=true)

> *Finalmente, un cambio indica una longitud de nombre de base de datos de 4.*

Esto también se puede realizar con un comando de suspensión en los casos en que no haya un indicador visual disponible. Por ejemplo, utilice " 2’ AND LENGTH(DATABASE())=X AND SLEEP(5)#" donde X es la longitud sospechosa de la base de datos. Si el comando de suspensión retrasa la respuesta de la aplicación, confirma la longitud correcta de la base de datos.

![SQL 26](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql26.png?raw=true)

**Paso 7: determinar el nombre de la base de datos**

Finalmente, podemos comenzar a enumerar el nombre real de la base de datos. Ya sabemos que tiene cuatro caracteres, pero podemos hacer más determinando cuáles son esos caracteres. Para hacer esto, probaremos diferentes caracteres ASCII usando 2’ AND ASCII(SUBSTR(DATABASE(),X,X))>YY#. En este caso X, es la posición del carácter que estamos probando y YYes el **[carácter decimal ASCII](https://www.asciitable.com/)** .

Con este método, le pregunta a la base de datos si el primer carácter es mayor que una letra establecida. Si no es así, responderá con una negativa. Comenzaremos en algún lugar cerca de la mitad del alfabeto minúsculo con “l” (que es el decimal ASCII 108). Entonces la consulta se ve así: 2’ AND ASCII(SUBSTR(DATABASE(),1,1))>108#.

![SQL 27](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql27.png?raw=true))

Según la respuesta, sabemos que el primer carácter no es mayor que “l”, por lo que tenemos que cambiar la operación para preguntar si es menor que “l”. Hacemos esto cambiando la consulta a 2’ AND ASCII(SUBSTR(DATABASE(),1,1))<108#.

![SQL 28](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql28.png?raw=true)

![SQL 29](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql29.png?raw=true)

Según esta respuesta, ahora sabemos que la primera letra está en algún lugar entre la “l” minúscula y todos los caracteres ASCII anteriores. Técnicamente, esto incluye todas las mayúsculas, números y caracteres especiales. Sabiendo esto podemos empezar a probar de forma incremental hasta que veamos un cambio en la respuesta. En nuestro caso, vemos una respuesta modificada una vez que ingresamos 100.

![SQL 30](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql30.png?raw=true)

![SQL 31](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql31.png?raw=true)

Esto ahora nos dice que el carácter no es menor que una “d” minúscula. Podemos confirmar que esta es la letra correcta invirtiendo la consulta.

![SQL 32](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql32.png?raw=true)

![SQL 33](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql33.png?raw=true)

Hemos confirmado con éxito el primer personaje. Ahora, podemos usar este mismo método cambiando la consulta a la ubicación del segundo carácter y repitiendo esto nuevamente. Nos aseguraremos de cambiar la ubicación ingresando 2’ AND ASCII(SUBSTR(DATABASE(),2,2))<108#.

![SQL 34](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql34.png?raw=true)

![SQL 35](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql35.png?raw=true)

![SQL 36](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql36.png?raw=true)

> *Con este resultado, sabemos que el segundo carácter es mayor que la “l” minúscula.*

A estas alturas, debería comprender el fundamento de cada paso. Al observar el comportamiento de la aplicación en respuesta a varios comandos SQL inyectados, puede identificar y comprender eficazmente las vulnerabilidades de inyección SQL ciega.

En la siguiente sección, demostraremos cómo explotar estas vulnerabilidades con la ayuda de SQLMap. Continúe practicando estas técnicas en un entorno controlado para perfeccionar sus habilidades y convertirse en un experto en la detección y explotación de ataques de inyección SQL ciega.

### **Ejemplo 1: Explotación de la inyección SQL ciega**

Ahora que hemos confirmado la vulnerabilidad, seguiremos los pasos para explotarla usando SQLMap. Preste atención a las capturas de pantalla de cada paso para una mejor comprensión. Aún mejor, sigue las instrucciones para consolidar realmente el proceso y el aprendizaje en tu mente y desarrollar esta habilidad.

**Paso 1: familiarizarse con SQLMap**

Abra la página de ayuda de SQLMap para familiarizarse con el tipo de información necesaria para un ataque y la estructura de comando de la herramienta. En concreto veremos que podemos utilizar una URL con la -ubandera y la información de la cookie con la bandera `--cookie=COOKIE.`

`sqlmap -h`

![SQL 37](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql37.png?raw=true)

**Paso 2: recuperar información de la sesión**

Recopile las cookies requeridas y el nivel de seguridad del Panel de desarrollador del navegador en la pestaña Almacenamiento.

![SQL 38](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql38.png?raw=true)

**Paso 3: comando URL de SQLMap**

Ejecute SQLMap con la información -uy --cookie=. Revise la información resultante, que incluye los parámetros, la carga útil y la ubicación de los archivos de salida.

![SQL 39](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql39.png?raw=true)

> *SQLMap ejecutando ataque URL.*

![SQL 40](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql40.png?raw=true)

> *Devolución de parámetros y ubicación de salida.*

**Paso 4: abrir el archivo de sesión**

Ahora iremos a la terminal y navegaremos hasta la ubicación del archivo de salida. Primero, lo usaremos para ver con qué archivos tenemos para trabajar. Utilícelo sqlitebrowserpara abrir el session.sqlitearchivo.

![SQL 41](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql41.png?raw=true)

**Paso 5: Navegador de base de datos**

En el navegador sqlite, examine la estructura de la base de datos y explore las pestañas de datos.

![SQL 42](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql42.png?raw=true)

> *Visualización de la pestaña "Estructura de la base de datos" en DB Browser.*

![SQL 43](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql43.png?raw=true)

> *Visualización de la pestaña "Buscar datos" en DB Browser.*

**Paso 6: ver el archivo de destino**

Regrese a la terminal y use cat target.txtpara ver el archivo que contiene el comando que usó.

![SQL 44](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql44.png?raw=true)

**Paso 7: Ver registro**

Úselo cat log para ver el contenido del registro. Esto incluye la misma información de parámetros y carga útil que vimos anteriormente, así como detalles sobre la base de datos y la tecnología de la aplicación web. Toda esta información podría ser útil en cualquier seguimiento de las pruebas de penetración que podamos realizar en etapas posteriores.

![SQL 45](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql45.png?raw=true)

**Paso 8: URL de SQLMap con indicador de nombre de base de datos**

Ahora regresaremos a la terminal y ejecutaremos el mismo comando en SQLMap, pero esta vez agregaremos '--dbs' para descubrir el nombre de la base de datos. Sabemos que tiene cuatro caracteres debido a nuestra prueba manual anterior, pero queremos saber más sobre esta base de datos.

![SQL 46](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql46.png?raw=true)

> *¡Y ahí está, “dvwa”!*

**Paso 9: URL de SQLMap con indicador de columna**

A continuación, queremos obtener las columnas de usuario con las banderas -D dvwa -T users --columns. Esto le proporcionará mucha más información sobre lo que realmente hay dentro de la base de datos.

![SQL 47](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql47.png?raw=true)

![SQL 48](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql48.png?raw=true)

**Paso 10: URL de SQLMap con indicador de volcado de usuario**

Ahora llegamos a la parte buena, utilícela -T users --dumppara extraer datos de la tabla del usuario. Revise la respuesta y observe cómo SQLMap le solicita que descifre el hash de las contraseñas que descubre y luego le presenta los resultados en una tabla clara y ordenada.

![SQL 49](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql49.png?raw=true)

![SQL 50](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql50.png?raw=true)

> *Aquí revisa la base de datos y extrae información del usuario.*

![SQL 51](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql51.png?raw=true)

> *SQLMap ofrece descifrar los hashes de contraseñas. ¡Sí, por favor!*

![SQL 52](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql52.png?raw=true)

Observe la ordenada disposición de la información en la imagen de arriba. Además de simplemente descifrar las contraseñas y colocarlas en una tabla ordenada, SQLMap también genera automáticamente esa información en un archivo .csv. Luego, esto se puede incorporar a otras herramientas para realizar más exploits durante un caso de prueba de penetración.

### **Ejemplo 2: Explotación de la inyección SQL ciega con datos HTTP**

Ahora demostraremos un método alternativo para explotar la inyección SQL ciega utilizando SQLMap y **la recopilación de datos HTTP de Burp Suite** .

**Paso 1: Intercepta el tráfico con Burp Suite**

Abra Burp Suite, que ha configurado para capturar el tráfico HTTP. Luego navegue hasta la pestaña Proxy y localice el envío de la consulta en el historial HTTP.

![SQL 53](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql53.png?raw=true)

**Paso 2: enviar solicitud al repetidor**

En el panel Solicitud, haga clic derecho en el envío de la consulta y seleccione 'Enviar al repetidor'.

**Paso 3: copie los datos sin procesar de Burp Suite**

Cambie a la pestaña Repetidor y copie los datos de la solicitud sin procesar del panel.

![SQL 54](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql54.png?raw=true)

**Paso 4: crear archivo de solicitud**

Pegue los datos de la solicitud sin procesar en un archivo nuevo que usará con SQLMap. En nuestro ejemplo, llamamos a este archivo request.

![SQL 55](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql55.png?raw=true)

**Paso 5: SQLMap carga el archivo de solicitud HTTP**

Regrese a la terminal y ejecute el comando sqlmap -r request. El -rindicador le indica a SQLMap que analice y utilice la solicitud HTTP sin formato del archivo especificado.

![SQL 56](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql56.png?raw=true)

Como en el método anterior, SQLMap ofrecerá descifrar los hash de contraseña del usuario descubierto una vez que haya extraído los datos.

![SQL 57](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql57.png?raw=true)

> 👉 Este método proporciona una alternativa a la introducción manual de información de cookies y URL en la línea de comando, lo que agiliza el proceso utilizando el tráfico HTTP capturado. Como en los métodos anteriores, esta información se envía a su directorio y puede estudiarse o utilizarse para esfuerzos futuros.

</aside>

## **Defensa contra la inyección SQL ciega**

Si sigue las mejores prácticas y pautas recomendadas por organizaciones acreditadas como **OWASP** , NIST, W3 y Amazon AWS, puede fortalecer significativamente las defensas de su aplicación contra estos ataques.

Estas organizaciones proporcionan información y recursos valiosos que cubren una amplia gama de temas, incluidas prácticas de codificación segura, seguridad de bases de datos, defensas de aplicaciones web y monitoreo y respuesta a incidentes. En esta sección, exploraremos estas mejores prácticas en detalle y le brindaremos pasos prácticos para ayudar a proteger su aplicación web contra vulnerabilidades de inyección SQL ciega.

### **Prácticas de codificación segura**

La implementación de prácticas de codificación segura es crucial para defenderse contra ataques de inyección SQL ciega. **[OWASP recomienda utilizar declaraciones preparadas](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)** o consultas parametrizadas para separar la entrada del usuario del código SQL, lo que reduce el riesgo de inyección. Además, la incorporación de técnicas de validación de entradas, como las listas blancas, ayuda a **restringir los tipos de datos que pueden introducir** los usuarios, lo que mejora aún más la seguridad.

### **Seguridad de la base de datos**

Las medidas de seguridad de la base de datos son esenciales para minimizar el impacto potencial de un ataque. Limitar los privilegios de los usuarios de la base de datos garantiza que los atacantes no puedan obtener acceso a información confidencial ni realizar acciones no autorizadas. Actualizar y parchear periódicamente su sistema de administración de bases de datos ayuda a abordar las vulnerabilidades conocidas, lo que dificulta que los atacantes las exploten. Puede leer más sobre esto en **[NIST SP 800-44 versión 2](https://csrc.nist.gov/publications/detail/sp/800-44/version-2/final)** (la Sección 6.4.2 analiza esto específicamente).

### **Defensas de aplicaciones web**

La implementación de defensas de aplicaciones web, como un firewall de aplicaciones web (WAF), puede ayudar a detectar y bloquear los intentos de inyección de SQL. **[Amazon AWS analiza](https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-use-case.html)** cómo un WAF analiza el tráfico entrante y filtra solicitudes maliciosas a través de grupos de reglas administrados por bases de datos, lo que reduce la probabilidad de un ataque exitoso.

### **Seguimiento y respuesta a incidentes**

Monitorear y registrar la actividad de las aplicaciones es vital para identificar actividades sospechosas y detectar posibles ataques desde el principio. **[NIST recomienda](https://csrc.nist.gov/publications/detail/sp/800-44/version-2/final)** establecer un sistema sólido de registro y monitoreo, junto con un plan de respuesta a incidentes bien definido, que garantice respuestas rápidas y efectivas a los incidentes de seguridad.

## **Conclusión**

A lo largo de este artículo, hemos profundizado en la inyección SQL ciega, explorando sus características únicas y las técnicas utilizadas para descubrir y explotar estas vulnerabilidades. Desde configurar un entorno de prueba con DVWA y Kali Linux hasta realizar pruebas manuales y utilizar herramientas como SQLMap y Burp Suite, le proporcionamos orientación práctica y consejos prácticos para adquirir habilidades en este tema complejo.

Además, hemos enfatizado la importancia de implementar medidas de seguridad sólidas, como prácticas de codificación segura, seguridad de bases de datos, defensas de aplicaciones web y monitoreo y respuesta a incidentes para protegerse contra ataques de inyección SQL ciega.

Como hemos demostrado, la inyección ciega de SQL es un desafío formidable en la seguridad cibernética para aplicaciones web, pero con el conocimiento y las habilidades adecuados, puede defenderse eficazmente contra estas amenazas. Continúe su aprendizaje tomando estos cursos para reforzar su aptitud en defensa y piratería ética de aplicaciones web:

## **Preguntas frecuentes**

- **¿Cuáles son los tipos de inyección SQL ciega?**

Hay dos tipos principales de inyección SQL ciega:

**Inyección SQL ciega basada en booleanos** : en este tipo, los atacantes infieren información de las respuestas de la aplicación web, como cambios en el contenido, mensajes de error o códigos de estado HTTP, aunque el resultado de la consulta real no es directamente visible.

**Inyección SQL ciega basada en el tiempo** : en este tipo, los atacantes introducen retrasos en sus consultas SQL utilizando funciones sensibles al tiempo (por ejemplo, SLEEP o WAITFOR DELAY) y observan el tiempo de respuesta de la aplicación web para inferir información sobre la base de datos. Los diferentes tiempos de respuesta indican si la condición inyectada era verdadera o falsa.

- **¿Qué es la respuesta condicional de inyección SQL ciega?**

Una respuesta condicional de inyección SQL ciega, también conocida como inyección SQL ciega basada en contenido o booleana, es una técnica utilizada por los atacantes para extraer información de una aplicación web vulnerable sin ver directamente el resultado de sus consultas SQL inyectadas.

En cambio, los atacantes inyectan declaraciones SQL con condiciones verdaderas o falsas y observan cambios en el comportamiento o contenido de la aplicación web en función de la veracidad de estas condiciones. Al analizar estas respuestas, el atacante puede inferir indirectamente la información que busca en la base de datos.

Piense en esto como un juego malicioso de 20 preguntas.

- **¿Qué herramientas se pueden utilizar para explotar la inyección SQL ciega?**

Existen varias herramientas que se pueden utilizar para explotar las vulnerabilidades de inyección SQL ciega. Algunas de las herramientas más populares y efectivas incluyen:

1. SQLMap: SQLMap, una herramienta de código abierto poderosa y ampliamente utilizada, automatiza la detección y explotación de vulnerabilidades de inyección SQL.

2. Burp Suite: Esta es una plataforma integral de prueba de seguridad de aplicaciones web, que incluye una gama de herramientas para detectar y explotar vulnerabilidades de inyección SQL ciega, como los módulos Repetidor e Intruso.

3. Pruebas manuales: si bien las herramientas automatizadas pueden resultar muy útiles, las pruebas manuales siguen desempeñando un papel esencial en la detección y explotación de vulnerabilidades de inyección SQL ciega.

- **¿Cuáles son las señales de que un sitio web es vulnerable a la inyección SQL ciega?**

Si bien ningún indicador garantiza la presencia de una vulnerabilidad, los siguientes signos pueden sugerir que una aplicación web podría ser susceptible a una inyección SQL ciega:

1. Comportamiento inesperado: si la aplicación muestra un comportamiento inusual cuando ciertos caracteres (como comillas simples o dobles) se ingresan en los campos de entrada del usuario, puede indicar que la aplicación no está manejando o desinfectando adecuadamente la entrada del usuario.

2. Respuestas condicionales: al inyectar consultas SQL que deberían devolver verdadero o falso, si la aplicación muestra un comportamiento diferente según la veracidad de la condición inyectada, puede sugerir una vulnerabilidad de inyección SQL ciega.

3. Retrasos de tiempo: la aplicación experimenta retrasos notables en el tiempo de respuesta cuando se inyectan consultas SQL específicas (por ejemplo, al usar la SLEEP()función).

4. Mensajes de error: si bien es posible que los mensajes de error no sean directamente visibles en los ataques de inyección SQL ciega, se debe evaluar cualquier mensaje de error o respuesta inusual de la aplicación.

- **¿Cuáles son las mejores prácticas para prevenir la inyección SQL ciega?**

Las mejores prácticas para prevenir la inyección ciega de SQL implican una combinación de prácticas de codificación segura, medidas de seguridad de bases de datos, defensas de aplicaciones web y estrategias de monitoreo y respuesta a incidentes.

**Advanced SQL Injection**

La inyección SQL avanzada es una técnica más sofisticada que la inyección SQL básica, que utiliza técnicas más complejas para explotar vulnerabilidades en las aplicaciones web. Esto puede incluir la manipulación de los datos de entrada de la aplicación, la identificación de patrones de filtrado, la explotación de errores en la aplicación y la utilización de herramientas automatizadas para la inyección de código malicioso. Este ataque puede tener consecuencias graves, como la exposición de información confidencial, el robo de datos, la alteración de la información almacenada en la base de datos y la pérdida de datos importantes. Por lo tanto, es importante que las empresas y desarrolladores de aplicaciones web implementen medidas de seguridad adecuadas para evitar este tipo de ataques.

![SQL 58](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/sql58.png?raw=true)

## Consecuencias

Las consecuencias de una inyección SQL Avanzadas pueden incluir:

- **Pérdida o alteración de datos:** el atacante puede eliminar, modificar o extraer información de la base de datos.
- **Inestabilidad del sistema:** el código malicioso puede causar que la base de datos deje de funcionar correctamente, lo que puede resultar en tiempos de inactividad y pérdida de disponibilidad.
- **Dificultad para detectar y mitigar el ataque:** debido a que el código malicioso se inserta en una consulta SQL legítima.
- **Posibilidad de propagación del ataque:** si el atacante tiene acceso a datos sensibles, como contraseñas de usuario, puede utilizarlos para propagar el ataque a otros sistemas.
- **Acceso no autorizado:** un atacante podría obtener acceso no autorizado al sistema o a la aplicación web, lo que le permitiría acceder a información confidencial o realizar acciones maliciosas en el sistema.
- **Modificación de datos:** un atacante podría modificar, eliminar o agregar datos al sistema, lo que podría tener graves consecuencias en la integridad y exactitud de los datos.
- **Ejecución de código malicioso:** un atacante podría ejecutar código malicioso en el sistema, lo que podría resultar en la toma de control del sistema o en el robo de información confidencial.
- **Denegación de servicio:** un atacante podría utilizar la inyección de comando para sobrecargar el sistema y hacer que se vuelva inoperable.

**La no corrección de esta falla puede causar divulgación no autorizada de su información y la de sus clientes que podría dar lugar a fraude, usurpación de identidad y a sanciones reglamentarias.** Para evitar la inyección de comandos, es importante validar y filtrar todas las entradas de usuario en las aplicaciones web, y evitar el uso de comandos de shell en aplicaciones web.  Además, es importante mantener todas las aplicaciones y sistemas actualizados y parcheados para evitar que se exploten vulnerabilidades conocidas.

## Solución

Para prevenir y solucionar la inyección SQL avanzada, se pueden tomar las siguientes medidas:

- **Validar y sanitizar todas las entradas de datos**: Asegúrese de que todas las entradas de datos, ya sean proporcionadas por los usuarios o por otras fuentes, sean validadas y sanitizadas adecuadamente antes de ser utilizadas en una consulta SQL.
- **Utilizar consultas parametrizadas:** En lugar de construir una consulta SQL dinámicamente utilizando cadenas de texto, utilice consultas parametrizadas que permitan que los parámetros sean pasados como argumentos separados. Esto reducirá la posibilidad de inyección SQL, ya que los valores de los parámetros son tratados como datos, no como parte de la consulta SQL.
- **Limitar los permisos de la base de datos:** Asegúrese de que los usuarios de la base de datos tengan solo los permisos necesarios para realizar sus funciones y nada más. Esto limitará el alcance de cualquier posible ataque.
- **Utilizar herramientas de seguridad y pruebas de penetración:** Realice pruebas regulares de seguridad y pruebas de penetración en la aplicación para identificar posibles vulnerabilidades y errores de seguridad. También puede utilizar herramientas de seguridad de terceros para proteger la aplicación contra la inyección SQL.
- **Actualización y parcheo del software de la base de datos y uso de firewalls de aplicación web (WAF)**

Es una tarea difícil determinar si una cadena de usuario es maliciosa o no. Por lo tanto, la mejor manera de hacerlo es “escapar” de los caracteres especiales en la entrada del usuario. Puede escapar una cadena antes de construir la consulta en PHP usando la función `mysql_escape_string()`. O en MySQL usando la función `mysqli_real_escape_string()`.

Mientras se muestra la salida como HTML, también tendrá que convertir la cadena para asegurarse de que los caracteres especiales no interfieren con el marcado HTML. Puede convertir caracteres especiales en PHP usando la función htmlspecialchars().

> 👉 Alternativamente, puede usar sentencias preparadas para evitar las inyecciones de SQL. Una sentencia preparada es una plantilla de una consulta SQL, en la que se especifican los parámetros en una etapa posterior para ejecutarla. Aquí hay un ejemplo de una declaración preparada en PHP y MySQLi.

</aside>

`$query = $mysql_connection->prepare("select * from user_table where username = ? and password = ?");`

`$query->execute(array($username, $password));`

> 📖 En resumen, para solucionar y prevenir la inyección SQL avanzada, es necesario validar y sanitizar todas las entradas de datos, utilizar consultas parametrizadas, limitar los permisos de la base de datos y utilizar herramientas de seguridad y pruebas de penetración.

</aside>

## Referencias

- [https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [https://owasp.org/Top10/A03_2021-Injection/](https://owasp.org/Top10/A03_2021-Injection/)
- [https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection](https://owasp.org/www-project-web-security-testing-guide/v42/4Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection)
- [https://kinsta.com/es/blog/inyeccion-sql/](https://kinsta.com/es/blog/inyeccion-sql/)
- [https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection.html)
- [https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/](https://www.wordfence.com/learn/how-to-prevent-sql-injection-attacks/)
