---
title: "Comunicación de vulnerabilidades encontradas y recomendaciones de mitigación"  
subtitle: "Identifica vulnerabilidades como la falta de tokens anti-CSRF en formularios HTML y aprende soluciones efectivas para mitigar ataques CSRF y mejorar la seguridad."  
tags: ["pentesting"]  
authors: ["blindma1den", "lorenagubaira"]  

---

## Nivel alto - ausencia de fichas (tokens) anti-csrf

No se encontraron fichas (tokens) Anti-CSRF en formularios HTML. Esto permite una solicitud falsa entre sitios en un ataque que compromete y obliga a una víctima a enviar su solicitud HTTP a un destino objetivo sin su conocimiento o intención para poder realizar una acción como si fuera el usuario legitimo. La causa es la funcionalidad oculta de la aplicación utilizando acciones de URL/formulario que pueden ser adivinados de forma repetible.

![tokens](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/tokens.png?raw=true)

La naturaleza del ataque es que CSRG explota la confianza que un sitio web proporciona a un usuario. Por el contrario, las cadenas de comandos de los sitios cruzados (XSS) explotan la confianza que un usuario proporciona en un sitio web.

Al igual que XSS, los ataques CSRG no tienen por qué ser de sitios cruzados, pero hay la posibilidad de que puedan serlo. La falsificación de las solicitudes ente los sitios también se conoce como CSRF, XSRG y ataques con un solo clic. Los ataques de CSRG son muy efectivos en varias situaciones, que incluyen:

- La victima tiene una sesión activa en el sitio de destino.
- La víctima se autoriza por medio de la autenticación HTTP en el sitio de destino.
- La víctima se encuentra en la misma red local que el sitio de destino.

CSRF se ha utilizado especialmente para poder realizar una acción contra un sitio objetivo utilizando los privilegios de la víctima, pero se han revelado técnicas recientes para difundir información al obtener el acceso a la respuesta.

El riesgo de divulgación de información aumenta de forma drástica cuando el sitio de destino se encuentra vulnerable a XSS, porque XSS se puede utilizar como una plataforma para CSRF, lo que le permite al atacante que opere desde adentro de los límites de la misma política de origen.

## Consecuencias

Cuando se lleva a cabo con éxito, un ataque CSRF puede tener una amplia variedad de repercusiones, según los privilegios de la víctima. Si el objetivo es un usuario estándar, es probable que toda su cuenta se vea comprometida, desde su información personal hasta sus privilegios en el sitio.

Y eso no es nada comparado con el impacto de un ataque CSRF en la cuenta de un administrador: podría paralizar todo el sitio. Dada la magnitud de un posible ataque CSRF, es esencial que cualquier paquete de seguridad web pueda proteger contra él.

![csrf](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/usuario-victima.png?raw=true)

El objetivo más común de un ataque CSRF es el robo de datos, identidad o dinero. Estos son algunos de los usos más comunes de CSRF:

- **Puede comprometer todo el sistema de administración de contenido**: Puede agregar o eliminar contenido en un sitio web. Si la víctima es el administrador, el atacante toma el control de todo el sitio.
- **Cambiar la contraseña de un usuario:** Si la víctima ha iniciado sesión en su cuenta, el atacante puede falsificar una solicitud para cambiar su correo electrónico. Después de eso, puede falsificar una solicitud de restablecimiento de contraseña y tomar el control total de la cuenta de la víctima.
- **Agregar artículos al carrito de un usuario o cambiar la dirección de entrega de un pedido:** En el caso de un ataque CSRF, el atacante puede modificar esta información. En el sitio web, la víctima aparece como autora de estas modificaciones.

## Solución

Utiliza una biblioteca o marco comprobado que no acepte que ocurra esta debilidad o que proporcione construcciones que permitan que esta debilidad sea más sencilla de evitar. Por ejemplo, utiliza el paquete anti-CSRG como el CSRGuard de OWASP.

Asegúrate de que su aplicación esté libre de fallas de secuencias de comandos entre sitios, ya que la mayoría de las defensas de CSRF pueden detenerse por medio del uso de secuencias de comandos manejadas por el atacante.

Origina un nonce único para cada uno de los formularios, colócalo en el formulario y confirme la independencia al obtener el formulario. Asegúrate de que el nonce no sea predecible (CWE-330). Debes tener en cuenta que esto puede pasar desapercibido utilizando XSS.

Identificar las operaciones que sean especialmente peligrosas. Cuando el usuario desarrolla una operación peligrosa, envíe una solicitud de confirmación de forma separada para poder garantizar que el usuario tenga la intención de desarrollar esa operación.

Utiliza el control de gestión de la sesión de ESAPI. Este control introduce un elemento para CSRF y no utilice el método GET para ninguna de las solicitudes que puedan desencadenar un cambio de estado. Revisa que la solicitud se creó en la página esperada.

Un token anti-CSRF es un valor oculto que se envía con las cookies y la solicitud del usuario en particular. Así es como funciona:

- El servidor web genera este token y se coloca como un campo oculto en el formulario.
- Cuando el usuario completa y envía el formulario, el token se incluye en la solicitud POST.
- El servidor comparará el token generado y el token enviado por el usuario.

Si coincide, la solicitud será válida. Si no coincide, la solicitud se considera inválida. Esto evita que se produzcan ataques CSRF.

**O mediante plugins:** Headers Security Advanced & HSTS WP

[https://wordpress.org/plugins/headers-security-advanced-hsts-wp/](https://wordpress.org/plugins/headers-security-advanced-hsts-wp/)

## Evidencias

![evidencia y referencias](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/evidencias.png?raw=true)

## Referencias:

- [https://wordpress.org/plugins/headers-security-advanced-hsts-wp](https://wordpress.org/plugins/headers-security-advanced-hsts-wp)
- [https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control.html](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control.html)
- [https://owasp.org/www-project-web-security-testing-guide/v42/4](https://owasp.org/www-project-web-security-testing-guide/v42/4)-
- Web_Application_Security_Testing/06-Session_Management_Testing/05- Testing_for_Cross_Site_Request_Forgery
- [http://projects.webappsec.org/Cross-Site-Request-Forgery](http://projects.webappsec.org/Cross-Site-Request-Forgery)
- [http://cwe.mitre.org/data/definitions/352.html](http://cwe.mitre.org/data/definitions/352.html)
- [https://owasp.org/Top10/A01_2021-Broken_Access_Control/](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)
- **[https://kinsta.com/es/base-de-conocimiento/hsts-missing-from-https-server/](https://kinsta.com/es/base-de-conocimiento/hsts-missing-from-https-server/)**

### Ejemplo

NIVEL MEDIO - SSL/TLS usa algoritmos hashing y cifrado débiles

SSL (Secure Sockets Layer) y TLS (Transport Layer Security) son protocolos de seguridad utilizados para cifrar y proteger las comunicaciones en línea entre un cliente (como un navegador web) y un servidor. Estos protocolos garantizan la confidencialidad y la integridad de los datos transmitidos a través de Internet.

Los algoritmos de hash y cifrado son componentes esenciales de SSL/TLS, pero si se utilizan algoritmos débiles, la seguridad de las comunicaciones puede estar comprometida.

![SSL](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/ssl-es.png?raw=true)

- **Algoritmos de Hash**: Los algoritmos de hash son funciones matemáticas que convierten un conjunto de datos en una cadena de caracteres de longitud fija. Se utilizan para generar resúmenes únicos (hashes) de los datos, que luego se pueden comparar para verificar la integridad de los datos.

- **Algoritmos de Cifrado**: Los algoritmos de cifrado son utilizados por SSL/TLS para cifrar los datos transmitidos, de modo que solo el destinatario legítimo pueda descifrarlos. Estos algoritmos aseguran la confidencialidad de la información.

- **Consecuencias de Hashing Débil**: Si se utilizan algoritmos de hash débiles, un atacante podría calcular fácilmente colisiones (dos conjuntos diferentes de datos que generan el mismo hash), lo que comprometería la integridad de la comunicación. Esto podría llevar a la manipulación de datos en tránsito sin ser detectado.

- **Manipulación de Datos**: Un atacante podría modificar los datos en tránsito sin ser detectado, ya que podría generar un nuevo conjunto de datos que produzca el mismo hash que el conjunto original.

- **Integridad Comprometida**: Las verificaciones de integridad se vuelven ineficaces, ya que los hashes no garantizan que los datos no hayan sido alterados.

- **Consecuencias de Cifrado Débil**: Si se utilizan algoritmos de cifrado débiles, la información podría ser descifrada fácilmente por atacantes, lo que expondría los datos sensibles a la interceptación y el robo.

- **Intercepción de Datos**: Atacantes pueden descifrar y robar información confidencial, como contraseñas y datos financieros.

- **Exposición a Ataques**: Algoritmos de cifrado débiles pueden ser vulnerables a ataques de fuerza bruta y otros métodos de criptoanálisis.

## Solución

Para garantizar una conexión segura con SSL/TLS, es importante:

1. Utilizar Algoritmos Fuertes: Se deben usar algoritmos de hash y cifrado robustos y actualizados que sean resistentes a los ataques actuales y futuros.
2. Actualizar Versiones: Utilizar las versiones más recientes de SSL/TLS, ya que implementan mejoras de seguridad y retiran el soporte a algoritmos obsoletos.
3. Configurar Ajustes de Seguridad: Configurar adecuadamente los ajustes de seguridad en el servidor para deshabilitar algoritmos débiles y priorizar aquellos más seguros.
4. Evaluar y Monitorear Regularmente: Realizar evaluaciones de seguridad periódicas para identificar posibles debilidades y mantenerse informado sobre las últimas amenazas y soluciones.

La elección de algoritmos de hash y cifrado sólidos es fundamental para asegurar que las comunicaciones a través de SSL/TLS sean seguras y confiables.

### Solucion de Hashing Débil:

- Utilizar Algoritmos Fuertes: Implementar algoritmos de hash robustos y resistentes a colisiones, como SHA-256 o superior, que sean menos susceptibles a ataques.
- Actualizar Software: Mantener actualizado el software y las bibliotecas de criptografía para asegurarse de que estén utilizando las últimas y más seguras implementaciones de algoritmos de hash.

**Consecuencias de Cifrado Débil:**

- Priorizar Algoritmos Fuertes: Configurar los servidores para priorizar el uso de algoritmos de cifrado seguros y resistente, como AES en modo Galois/Counter Mode (AES-GCM) o ChaCha20-Poly1305.
- Desactivar Algoritmos Débiles: Eliminar del conjunto de algoritmos permitidos aquellos que sean considerados débiles o inseguros.
- Actualizar Protocolos: Utilizar versiones actualizadas de TLS, como TLS 1.3, que han eliminado algoritmos de cifrado obsoletos y débiles.

> Evidencia y Referencias

![report](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/report.png?raw=true)

- [https://www.schneier.com/paper-ssl.pdf](https://www.schneier.com/paper-ssl.pdf)
- [http://www.phreedom.org/research/rogue-ca](http://www.phreedom.org/research/rogue-ca)
- [http://www.microsoft.com/technet/security/advisory/961509.mspx](http://www.microsoft.com/technet/security/advisory/961509.mspx)
- [http://www.kb.cert.org/vuls/id/836068](http://www.kb.cert.org/vuls/id/836068)
- [http://tools.ietf.org/html/rfc3279](http://tools.ietf.org/html/rfc3279)
- [https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc770833(v=ws.11)](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc770833(v=ws.11))
- [https://technet.microsoft.com/en-us/library/ff458357.aspx](https://technet.microsoft.com/en-us/library/ff458357.aspx)
- [https://www.acunetix.com/blog/articles/tls-ssl-cipher-hardening/](https://www.acunetix.com/blog/articles/tls-ssl-cipher-hardening/)
- [https://www.owasp.org/index.php/Testing_for_Weak_SSL/TLS_Ciphers,_Insufficient_Transport_Layer_Protection_(OTG-CRYPST-001)](https://www.owasp.org/index.php/Testing_for_Weak_SSL/TLS_Ciphers,_Insufficient_Transport_Layer_Protection_(OTG-CRYPST-001))
- [https://www.acunetix.com/blog/articles/tls-ssl-cipher-hardening/](https://www.acunetix.com/blog/articles/tls-ssl-cipher-hardening/)

## Ejemplo 3

Uploading de archivos sin restricción

A través de funcionalidades de la aplicación es posible subir archivos a los servidores de la organización. Es posible subir cualquier tipo de archivo ya que los mismos no son controlados. De esta manera es posible tomar control completo del servidor a través de la subida de una Shell PHP.

**Dispositivos o sistemas afectados**

![descargas](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/descargas.png?raw=true)

![php](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/php-es.png?raw=true)

## Recomendaciones y enlaces de referencia

Se recomienda controlar los tipos de archivos subidos a la plataforma y solo permitir archivos predeterminados, como PDF/DOC/XLS, controlando el tipo de archivo a través de su *MIME Type*. Controlar el tipo de archivo por extensión no es suficiente.

En PHP se debe utilizar la función *fileinfo()* para controlar el tipo de archivo subido.

**Más información**

- [https://www.owasp.org/index.php/Unrestricted_File_Upload](https://www.owasp.org/index.php/Unrestricted_File_Upload)
- [https://www.owasp.org/index.php/Protect_FileUpload_Against_Malicious_File](https://www.owasp.org/index.php/Protect_FileUpload_Against_Malicious_File)
- [https://stackoverflow.com/questions/11601342/upload-doc-or-pdf-using-php](https://stackoverflow.com/questions/11601342/upload-doc-or-pdf-using-php)
- [http://php.net/fileinfo](http://php.net/fileinfo)

## Ejemplo 4

PHP múltiples vulnerabilidades

Se ha detectado que uno de los servidores utiliza PHP con versiones que ya no son soportadas, que tienen múltiples vulnerabilidades conocidas y públicas que permiten tomar el control del servidor web y realizar ataques de Denegación de Servicio (DoS).

Adicionalmente, la rama 5.3.x ya no es soportada por el fabricante.

**Dispositivos o sistemas afectados**

- PHP 7.0.7
- Versiones soportadas: 7.1.x / 7.0.x

![Versiones soportadas:](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/versiones-soportadas.png?raw=true)

Algunas de estas vulnerabilidades tienen *exploits* disponibles que pueden ser aprovechados a través de herramientas como *CoreImpact o Metaexploit*.

**Recomendaciones y enlaces de referencia**

Se recomienda instalar la última actualización de PHP (5.3.29 o superior) de forma inmediata y proceder a la migración a una versión soportada (5.6.x o superior, y 7.1.x o superior).

**Más información**

- [http://www.php.net/releases/5_3_7.php](http://www.php.net/releases/5_3_7.php)
- [http://php.net/eol.php](http://php.net/eol.php)
- [https://www.exploit-db.com/exploits/29290](https://www.exploit-db.com/exploits/29290)
- [https://www.exploit-db.com/exploits/18836](https://www.exploit-db.com/exploits/18836)
- [https://www.cvedetails.com/vulnerability-list/vendor_id-74/product_id-128/version_id-90936/PHP-PHP-5.3.2.html](https://www.cvedetails.com/vulnerability-list/vendor_id-74/product_id-128/version_id-90936/PHP-PHP-5.3.2.html)
- [http://blog.kotowicz.net/2011/06/file-path-injection-in-php-536-file.html](http://blog.kotowicz.net/2011/06/file-path-injection-in-php-536-file.html)

## Ejemplo 5

Apache no soportado

Se ha detectado que uno de los servidores utiliza Apache 2.0.x y 2.2.x, el cual tiene múltiples vulnerabilidades conocidas y públicas que permiten tomar el control del servidor web y/o realizar ataques de DoS.

### Dispositivos o sistemas afectados

- imss.institutoseguro.com.ar
- Versión instalada: Apache 2.2.15 (Linux/SUSE)
- Fin de soporte: 2017-07-11 (2.2.34)
- Anuncio: [http://archive.apache.org/dist/httpd/Announcement2.2.html](http://archive.apache.org/dist/httpd/Announcement2.2.html)
- Versiones soportadas: Apache 2.4.x

![Apache Linux](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/apache-linux.png?raw=true)

- 200.45.107.99
- Versión instalada: Apache 2.0.50
- Anuncio: [http://archive.apache.org/dist/httpd/Announcement2.0.html](http://archive.apache.org/dist/httpd/Announcement2.0.html)
- Versiones soportadas: Apache 2.4.x

Estas versiones tienen vulnerabilidades conocidas con exploits disponibles que puede ser aprovechados a través de herramientas como CoreImpact o Metaexploit.

### Recomendaciones y enlaces de referencia

Se recomienda instalar la última esta actualización de Apache (2.0.59 y 2.2.34 o superior) de forma inmediata y proceder a la migración a una versión soportada (2.4.38 o superior).

**Más información**

- [http://archive.apache.org/dist/httpd/Announcement2.2.html](http://archive.apache.org/dist/httpd/Announcement2.2.html)
- [https://github.com/apache/httpd/releases](https://github.com/apache/httpd/releases)

## Ejemplo 6

Directivas inseguras de PHP

En las distintas instalaciones de PHP se han encontrado errores de configuración.

**PHPinfo habilitado**

Se encontró un archivo que ejecuta la función *phpinfo()*, encarga de brindar información del servidor.

**Aplicaciones afectadas**

![server-adr](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/server-adr.png?raw=true)

![allow_url_fopen](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/allow_url_fopen.png?raw=true)

> PHP allow_url_fopen habilitado

La directiva de configuración de PHP *“allow_url_fopen”* está habilitada por defecto. Cuando está habilitada, esta directiva permite la recuperación de datos desde ubicaciones remotas (sitio web o servidor FTP). Un gran número de vulnerabilidades de inyección de código reportadas en aplicaciones web basadas en PHP son causadas por la combinación de habilitación de *“allow_url_fopen”* y un mal filtrado de entrada.

**PHP open_basedir no especificado**

La directiva de configuración *“open_basedir”* permite limitar los archivos que PHP puede abrir al árbol de directorios especificado. Cuando un script intenta abrir un archivo con, por ejemplo, *fopen()* o *gzopen()*, se comprueba la ubicación del archivo. Cuando el archivo está fuera del árbol de directorios especificado, PHP rechazará abrirlo. *“open_basedir”* es una buena protección contra las vulnerabilidades de inclusión remota de archivos.

**Directorio PHPMyAdmin encontrado**

Se encuentra un directorio *“phpmyadmin”* habilitado que finalmente impacta contra una dirección IP interna de la organización: [https://192.168.3.21/phpMyAdmin/](https://192.168.3.21/phpMyAdmin/)

### Aplicaciones afectadas

![register_globals](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/register_globals.png?raw=true)

- **PHP register_globals habilitado**

Cuando *“register_globals”* está habilitado, PHP creará automáticamente variables en el ámbito global para cualquier valor pasado en GET, POST o COOKIE. Esto, combinado con el uso de variables sin inicialización, puede llevar a numerosas vulnerabilidades de seguridad.

- **PHP display_errors habilitado**

La directiva *“display_errors”* determina si se deben enviar mensajes de error al navegador. Con frecuencia, estos mensajes contienen información confidencial sobre el entorno de su aplicación web y nunca deben presentarse a fuentes que no sean de confianza.

- **PHP session.use_only_cookies desactivado**

Cuando *“use_only_cookies”* está deshabilitado, PHP pasará el ID de sesión a través de la URL. Esto hace que la aplicación sea más vulnerable a los ataques de secuestro de sesión. El secuestro de la sesión es básicamente una forma de robo de identidad en la que un atacante se hace pasar por un usuario legítimo al robar su ID de sesión. Cuando el *token* de sesión se transmite en una *cookie* y la solicitud se realiza en un canal seguro (se utiliza SSL/TLS), este *token* es seguro.

### Recomendaciones y enlaces de referencia

- Se debe deshabilitar la directiva de PHP “allow_url_fopen” desde php.ini.

- Habilitar un directorio base a través de la directiva *“open_basedir”* desde *php.ini.*

- Eliminar cualquier archivo que brinde información sobre el servidor y las aplicaciones instaladas (*phpinfo*, *test*, *phpmyadmin*, etc).

- Desactivar *“register_globals”* desde *php.ini* o *.htaccess*.

- Desactivar *“display_errors”* desde *php.ini* o *.htaccess*.

- Activar *“session.use_only_cookies”* desde *php.ini* o *.htaccess.*

**Más información:**

- [http://php.net/manual/en/filesystem.configuration.php](http://php.net/manual/en/filesystem.configuration.php)
- [http://www.php.net/manual/en/security.globals.php](http://www.php.net/manual/en/security.globals.php)
- [http://www.php.net/manual/en/errorfunc.configuration.php#ini.error-reporting](http://www.php.net/manual/en/errorfunc.configuration.php#ini.error-reporting)
- [http://php.net/ini.core](http://php.net/ini.core)
- [http://www.php.net/session.configuration](http://www.php.net/session.configuration)
- [http://www.php.net/manual/en/function.phpinfo.php](http://www.php.net/manual/en/function.phpinfo.php)
