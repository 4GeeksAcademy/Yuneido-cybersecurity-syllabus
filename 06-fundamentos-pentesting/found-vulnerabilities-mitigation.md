---
title: "Communication of vulnerabilities found and mitigation recommendations"
subtitle: "Identify vulnerabilities like lack of anti-CSRF tokens in HTML forms and learn effective solutions to mitigate CSRF attacks and enhance security."
tags: ["pentesting"]
authors: ["blindma1den", "lorenagubaira"]

---

## High level - absence of anti-csrf tokens

No Anti-CSRF tokens were found in HTML forms. This allows a fake cross-site request in an attack that compromises and forces a victim to send their HTTP request to a target destination without their knowledge or intent to act as if they were the legitimate user. It is caused by hidden application functionality using URL/form actions that can be repeatedly guessed.

![tokens](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/tokens.png?raw=true)

The nature of the attack is that CSRG exploits the trust that a website provides to a user. In contrast, cross-site scripting (XSS) exploits a user's trust in a website.

Like XSS, CSRG attacks do not have to be cross-site but could be. Cross-site request forgery is also known as CSRF, XSRG and one-click attacks. CSRG attacks are very effective in several situations, which include:

- The victim has an active session on the target site.
- The victim is authorized via HTTP authentication at the target site.
- The victim is on the same local network as the target site.

CSRF has been used especially to be able to perform an action against a target site using the victim's privileges, but recent techniques have been revealed to disseminate information by gaining access to the response.

The risk of information disclosure increases dramatically when the target site is vulnerable to XSS because XSS can be used as a platform for CSRF, allowing the attacker to operate from within the boundaries of the same source policy.

## Consequences

When carried out successfully, a CSRF attack can have a wide variety of repercussions, depending on the privileges of the victim. If the target is a standard user, their entire account is likely to be compromised, from their personal information to their privileges on the site.

And that's nothing compared to the impact of a CSRF attack on an administrator's account: it could cripple the entire site. Given the magnitude of a potential CSRF attack, it is essential that any web security package can protect against it.

![csrf](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/csrf.png?raw=true)

The most common target of a CSRF attack is the theft of data, identity, or money. Here are some of the most common uses of CSRF:

- **Can compromise the entire content management system**: Can add or delete content on a website. If the victim is the administrator, the attacker takes control of the entire site.
- **Change a user's password:** If the victim is logged into his account, the attacker can forge a request to change his email. After that, he can forge a password reset request and take full control of the victim's account.
- **Adding items to a user's cart or changing the delivery address of an order:** In the case of a CSRF attack, the attacker can modify this information. On the website, the victim appears as the author of these modifications.

## Solution

Use a proven library or framework that does not allow this weakness to occur, or provide constructs that make this weakness easier to avoid. For example, use the anti-CSRG package, such as OWASP's CSRGuard.

Ensure that your application is free of cross-site scripting flaws, as most CSRF defenses can be stopped through the use of attacker-driven scripting.

Originate a unique nonce for each of the forms, place it on the form, and confirm independence by fetching the form. Make sure that the nonce is not predictable (CWE-330). Be aware that this can be missed using XSS.

Identify particularly dangerous operations. When the user performs a dangerous operation, send a separate confirmation request so that you can ensure that the user intends to perform that operation.

Use the ESAPI session management control. This control introduces an element for CSRF and does not use the GET method for any requests that may trigger a change of state. It checks that the request was created on the expected page.

An anti-CSRF token is a hidden value that is sent with cookies and a particular user request. Here's how it works:

- This token is generated by the web server and placed as a hidden field in the form.
- When the user completes and submits the form, the token is included in the POST request.
- The server will compare the generated token and the token submitted by the user.

If it matches, the request is valid. If it does not match, the request is considered invalid. This prevents CSRF attacks.

**Or via plugins:** Headers Security Advanced & HSTS WP

[https://wordpress.org/plugins/headers-security-advanced-hsts-wp/](https://wordpress.org/plugins/headers-security-advanced-hsts-wp/)

## Evidence

![evidence and references](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/evidencias.png?raw=true)

## References:

- [https://wordpress.org/plugins/headers-security-advanced-hsts-wp](https://wordpress.org/plugins/headers-security-advanced-hsts-wp)
- [https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control.html](https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control.html)
- [https://owasp.org/www-project-web-security-testing-guide/v42/4](https://owasp.org/www-project-web-security-testing-guide/v42/4)-
- Web_Application_Security_Testing/06-Session_Management_Testing/05- Testing_for_Cross_Site_Request_Forgery
- [http://projects.webappsec.org/Cross-Site-Request-Forgery](http://projects.webappsec.org/Cross-Site-Request-Forgery)
- [http://cwe.mitre.org/data/definitions/352.html](http://cwe.mitre.org/data/definitions/352.html)
- [https://owasp.org/Top10/A01_2021-Broken_Access_Control/](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)
- **[https://kinsta.com/es/base-de-conocimiento/hsts-missing-from-https-server/](https://kinsta.com/es/base-de-conocimiento/hsts-missing-from-https-server/)**

### Example

MEDIUM LEVEL - SSL/TLS uses weak hashing and encryption algorithms

SSL (Secure Sockets Layer) and TLS (Transport Layer Security) are security protocols used to encrypt and protect online communications between a client (such as a web browser) and a server. These protocols ensure the confidentiality and integrity of data transmitted over the Internet.

Hashing and encryption algorithms are essential components of SSL/TLS, but if weak algorithms are used, the security of communications may be compromised.

![SSL](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/ssl-tls.png?raw=true)

- **Hash algorithms**: Hash algorithms are mathematical functions that convert a set of data into a fixed-length string of characters. They are used to generate unique summaries (hashes) of the data, which can then be compared to verify the integrity of the data.

- **Encryption Algorithms**: Encryption algorithms are used by SSL/TLS to encrypt transmitted data so that only the legitimate recipient can decrypt it. These algorithms ensure the confidentiality of the information.

- **Consequences of Weak Hashing**: If weak hashing algorithms are used, an attacker could easily calculate collisions (two different sets of data generating the same hash), which would compromise the integrity of the communication. This could lead to undetected manipulation of data in transit.

- **Data Manipulation**: An attacker could modify data in transit without being detected, as he could generate a new data set that produces the same hash as the original set.

- **Compromised Integrity**: Integrity checks become ineffective, as hashes do not guarantee that the data has not been altered.

- **Consequences of Weak Encryption**: If weak encryption algorithms are used, information could be easily decrypted by attackers, exposing sensitive data to interception and theft.

- **Data Interception**: Attackers can decrypt and steal sensitive information such as passwords and financial data.

- **Exposure to Attack**: Weak encryption algorithms can be vulnerable to brute force attacks and other cryptanalysis methods.

## Solution

To ensure a secure connection with SSL/TLS, it is important to:

1. Use Strong Algorithms: Robust, up-to-date hashing and encryption algorithms that are resistant to current and future attacks should be used.
2. Upgrade Versions: Use the latest versions of SSL/TLS, as they implement security enhancements and remove support for obsolete algorithms.
3. Configure Security Settings: Properly configure security settings on the server to disable weak algorithms and prioritize more secure ones.
4. Evaluate and Monitor Regularly: Perform regular security assessments to identify potential weaknesses and keep informed about the latest threats and solutions.

Choosing strong hashing and encryption algorithms is critical to ensure that communications over SSL/TLS are secure and reliable.

### Weak Hashing Solution:

- Use Strong Algorithms: Implement robust, collision-resistant hashing algorithms, such as SHA-256 or higher, that are less susceptible to attack.
- Update Software: Keep cryptographic software and libraries up to date to ensure they are using the latest and most secure hash algorithm implementations.

**Consequences of Weak Encryption:**

- Prioritize Strong Algorithms: Configure servers to prioritize the use of secure and strong encryption algorithms, such as AES in Galois/Counter Mode (AES-GCM) or ChaCha20-Poly1305.
- Disable Weak Algorithms: Eliminate from the set of allowed algorithms those that are considered weak or insecure.
- Update Protocols: Use updated versions of TLS, such as TLS 1.3, which have removed obsolete and weak encryption algorithms.

> Evidence and References

![report](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/report.png?raw=true)

- [https://www.schneier.com/paper-ssl.pdf](https://www.schneier.com/paper-ssl.pdf)
- [http://www.phreedom.org/research/rogue-ca](http://www.phreedom.org/research/rogue-ca)
- [http://www.microsoft.com/technet/security/advisory/961509.mspx](http://www.microsoft.com/technet/security/advisory/961509.mspx)
- [http://www.kb.cert.org/vuls/id/836068](http://www.kb.cert.org/vuls/id/836068)
- [http://tools.ietf.org/html/rfc3279](http://tools.ietf.org/html/rfc3279)
- [https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc770833(v=ws.11)](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc770833(v=ws.11))
- [https://technet.microsoft.com/en-us/library/ff458357.aspx](https://technet.microsoft.com/en-us/library/ff458357.aspx)
- [https://www.acunetix.com/blog/articles/tls-ssl-cipher-hardening/](https://www.acunetix.com/blog/articles/tls-ssl-cipher-hardening/)
- [https://www.owasp.org/index.php/Testing_for_Weak_SSL/TLS_Ciphers,_Insufficient_Transport_Layer_Protection_(OTG-CRYPST-001)](https://www.owasp.org/index.php/Testing_for_Weak_SSL/TLS_Ciphers,_Insufficient_Transport_Layer_Protection_(OTG-CRYPST-001))
- [https://www.acunetix.com/blog/articles/tls-ssl-cipher-hardening/](https://www.acunetix.com/blog/articles/tls-ssl-cipher-hardening/)

## Example 3

Unrestricted file uploading

Through application functionalities, it is possible to upload files to the organization's servers. It is possible to upload any type of file since the files are not controlled. In this way, it is possible to take complete control of the server by uploading a PHP shell.

**Affected devices or systems**

![downloads](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/descargas.png?raw=true)

![php](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/php.png?raw=true)

## Recommendations and reference links

It is recommended to control the file types uploaded to the platform and only allow default files, such as PDF/DOC/XLS, by controlling the file type through its *MIME Type*. Controlling the file type by extension is not enough.

In PHP you must use the *fileinfo()* function to control the type of the uploaded file.

**More information**

- [https://www.owasp.org/index.php/Unrestricted_File_Upload](https://www.owasp.org/index.php/Unrestricted_File_Upload)
- [https://www.owasp.org/index.php/Protect_FileUpload_Against_Malicious_File](https://www.owasp.org/index.php/Protect_FileUpload_Against_Malicious_File)
- [https://stackoverflow.com/questions/11601342/upload-doc-or-pdf-using-php](https://stackoverflow.com/questions/11601342/upload-doc-or-pdf-using-php)
- [http://php.net/fileinfo](http://php.net/fileinfo)

## Example 4

PHP multiple vulnerabilities

It has been detected that one of the servers uses PHP with versions that are no longer supported, which have multiple known and public vulnerabilities that allow it to take control of the web server and perform Denial of Service (DoS) attacks.

Additionally, the 5.3.x branch is no longer supported by the manufacturer.

**Affected devices or systems

- PHP 7.0.7
- Supported versions: 7.1.x / 7.0.x

Supported versions:](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/versiones-soportadas.png?raw=true)

Some of these vulnerabilities have *exploits* available that can be exploited through tools such as *CoreImpact or Metaexploit*.

**Recommendations and reference links**.

It is recommended to install the latest PHP update (5.3.29 or higher) immediately and migrate to a supported version (5.6.x or higher, and 7.1.x or higher).

**More information**

- [http://www.php.net/releases/5_3_7.php](http://www.php.net/releases/5_3_7.php)
- [http://php.net/eol.php](http://php.net/eol.php)
- [https://www.exploit-db.com/exploits/29290](https://www.exploit-db.com/exploits/29290)
- [https://www.exploit-db.com/exploits/18836](https://www.exploit-db.com/exploits/18836)
- [https://www.cvedetails.com/vulnerability-list/vendor_id-74/product_id-128/version_id-90936/PHP-PHP-5.3.2.html](https://www.cvedetails.com/vulnerability-list/vendor_id-74/product_id-128/version_id-90936/PHP-PHP-5.3.2.html)
- [http://blog.kotowicz.net/2011/06/file-path-injection-in-php-536-file.html](http://blog.kotowicz.net/2011/06/file-path-injection-in-php-536-file.html)

## Example 5

Apache not supported

It has been detected that one of the servers uses Apache 2.0.x and 2.2.x, which have multiple known and public vulnerabilities that allow them to take control of the web server and/or perform DoS attacks.

### Devices or systems affected

- imss.institutoseguro.com.ar
- Version installed: Apache 2.2.15 (Linux/SUSE)
- End of support: 2017-07-11 (2.2.34)
- Announcement: [http://archive.apache.org/dist/httpd/Announcement2.2.html](http://archive.apache.org/dist/httpd/Announcement2.2.html)
- Supported versions: Apache 2.4.x

Apache Linux](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/apache-linux.png?raw=true)

- 200.45.107.99
- Installed version: Apache 2.0.50
- Announcement: [http://archive.apache.org/dist/httpd/Announcement2.0.html](http://archive.apache.org/dist/httpd/Announcement2.0.html)
- Supported versions: Apache 2.4.x

These versions have known vulnerabilities with exploits available that can be exploited through tools such as CoreImpact or Metaexploit.

### Recommendations and reference links

It is recommended to install the latest Apache update (2.0.59 and 2.2.34 or higher) immediately and migrate to a supported version (2.4.38 or higher).

**More information**

- [http://archive.apache.org/dist/httpd/Announcement2.2.html](http://archive.apache.org/dist/httpd/Announcement2.2.html)
- [https://github.com/apache/httpd/releases](https://github.com/apache/httpd/releases)

## Example 6

Insecure PHP directives

Configuration errors have been found in the various PHP installations.

**PHPinfo enabled**

A file was found that executes the *phpinfo()* function, which is responsible for providing server information.

**Applications affected**

![server-adr](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/server-adr.png?raw=true)

![allow_url_fopen](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/allow_url_fopen.png?raw=true)

> PHP allow_url_fopen enabled

The PHP configuration directive *"allow_url_fopen ”* is enabled by default. When enabled, this directive allows data retrieval from remote locations (website or FTP server). A large number of reported code injection vulnerabilities in PHP-based web applications are caused by the combination of *"allow_url_fopen ”* enablement and bad input filtering.

**PHP open_basedir not specified**.

The *"open_basedir ”* configuration directive allows limiting the files PHP can open to the specified directory tree. When a script attempts to open a file with, for example, *fopen()* or *gzopen()*, the location of the file is checked. When the file is outside the specified directory tree, PHP will refuse to open it. *open_basedir “* is a good protection against remote file inclusion vulnerabilities.

**PHPMyAdmin directory found**

A *"phpmyadmin”* directory is found enabled which eventually hits an internal IP address of the organization: [https://192.168.3.21/phpMyAdmin/](https://192.168.3.21/phpMyAdmin/)

### Applications affected

![register_globals](https://github.com/4GeeksAcademy/cybersecurity-syllabus/blob/main/assets/register_globals.png?raw=true)

- **PHP register_globals enabled**

When *"register_globals”* is enabled, PHP will automatically create variables in the global scope for any values passed in GET, POST or COOKIE. This, combined with the use of variables without initialization, can lead to numerous security vulnerabilities.

- PHP display_errors enabled**

The *"display_errors”* directive determines whether error messages should be sent to the browser. These messages often contain sensitive information about your web application environment and should never be presented to untrusted sources.

- PHP session.session.use_only_cookies disabled**

When *"use_only_cookies”* is disabled, PHP will pass the session ID through the URL. This makes the application more vulnerable to session hijacking attacks. Session hijacking is a form of identity theft in which an attacker impersonates a legitimate user by stealing their session ID. When the session *token* is transmitted in a *cookie* and the request is made over a secure channel (SSL/TLS is used), this *token* is secure.

### Recommendations and reference links

- Disable the PHP directive “allow_url_fopen” from php.ini.

- Enable a base directory via the *"open_basedir”* directive from *php.ini.*.

- Remove any files that provide information about the server and installed applications (*phpinfo*, *test*, *phpmyadmin*, etc).

- Disable *"register_globals ”* from *php.ini* or *.htaccess*.

- Disable *"display_errors ”* from *php.ini* or *.htaccess*.

- Enable *"session.use_only_cookies ”* from *php.ini* or *.htaccess*.

**More information:**

- [http://php.net/manual/en/filesystem.configuration.php](http://php.net/manual/en/filesystem.configuration.php)
- [http://www.php.net/manual/en/security.globals.php](http://www.php.net/manual/en/security.globals.php)
- [http://www.php.net/manual/en/errorfunc.configuration.php#ini.error-reporting](http://www.php.net/manual/en/errorfunc.configuration.php#ini.error-reporting)
- [http://php.net/ini.core](http://php.net/ini.core)
- [http://www.php.net/session.configuration](http://www.php.net/session.configuration)
- [http://www.php.net/manual/en/function.phpinfo.php](http://www.php.net/manual/en/function.phpinfo.php)
